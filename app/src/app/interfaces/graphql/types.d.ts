export type Maybe<T> = T | null;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: string;
  String: string;
  Boolean: boolean;
  Int: number;
  Float: number;
  /** A floating point number that requires more precision than IEEE 754 binary 64 */
  BigFloat: any;
  /**
   * A signed eight-byte integer. The upper big integer values are greater than the
   * max value for a JavaScript number. Therefore all big integers will be output as
   * strings and not numbers.
   */
  BigInt: any;
  /** A location in a connection that can be used for resuming pagination. */
  Cursor: any;
  /**
   * A point in time as described by the [ISO
   * 8601](https://en.wikipedia.org/wiki/ISO_8601) standard. May or may not include a timezone.
   */
  Datetime: any;
};

/** Table is used to store alerts when certain events are passed from vehicles */
export type Alert = Node & {
  __typename?: 'Alert';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  /** Id for the alert assigned by database */
  id: Scalars['BigInt'];
  /** Stores any and all messages from the event */
  message: Scalars['String'];
  /** Is the alert type */
  alertTypeId: Scalars['BigInt'];
  /** IS the status this alert is linked to */
  vehicleStatusId: Scalars['BigInt'];
  /** Indicates if the alert has been ackowledged by a user */
  read: Scalars['Boolean'];
  /** Indicates if the alert has been dismissed by a user */
  dismissed: Scalars['Boolean'];
  /** Reads a single `AlertType` that is related to this `Alert`. */
  alertType?: Maybe<AlertType>;
  /** Reads a single `VehicleStatus` that is related to this `Alert`. */
  vehicleStatus?: Maybe<VehicleStatus>;
};

/** A condition to be used against `Alert` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type AlertCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `message` field. */
  message?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `alertTypeId` field. */
  alertTypeId?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `vehicleStatusId` field. */
  vehicleStatusId?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `read` field. */
  read?: Maybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `dismissed` field. */
  dismissed?: Maybe<Scalars['Boolean']>;
};

/** A filter to be used against `Alert` object types. All fields are combined with a logical ‘and.’ */
export type AlertFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `message` field. */
  message?: Maybe<StringFilter>;
  /** Filter by the object’s `alertTypeId` field. */
  alertTypeId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `vehicleStatusId` field. */
  vehicleStatusId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `read` field. */
  read?: Maybe<BooleanFilter>;
  /** Filter by the object’s `dismissed` field. */
  dismissed?: Maybe<BooleanFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<AlertFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<AlertFilter>>;
  /** Negates the expression. */
  not?: Maybe<AlertFilter>;
};

/** An input for mutations affecting `Alert` */
export type AlertInput = {
  /** Stores any and all messages from the event */
  message: Scalars['String'];
  /** Is the alert type */
  alertTypeId: Scalars['BigInt'];
  /** IS the status this alert is linked to */
  vehicleStatusId: Scalars['BigInt'];
  /** Indicates if the alert has been ackowledged by a user */
  read?: Maybe<Scalars['Boolean']>;
  /** Indicates if the alert has been dismissed by a user */
  dismissed?: Maybe<Scalars['Boolean']>;
};

/** Represents an update to a `Alert`. Fields that are set will be updated. */
export type AlertPatch = {
  /** Stores any and all messages from the event */
  message?: Maybe<Scalars['String']>;
  /** Is the alert type */
  alertTypeId?: Maybe<Scalars['BigInt']>;
  /** IS the status this alert is linked to */
  vehicleStatusId?: Maybe<Scalars['BigInt']>;
  /** Indicates if the alert has been ackowledged by a user */
  read?: Maybe<Scalars['Boolean']>;
  /** Indicates if the alert has been dismissed by a user */
  dismissed?: Maybe<Scalars['Boolean']>;
};

/** Table is used to define alert types */
export type AlertType = Node & {
  __typename?: 'AlertType';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  /** Id for the alert type assigned by database */
  id: Scalars['BigInt'];
  /** The label for the alert type */
  name: Scalars['String'];
  severity: Scalars['Int'];
  /** Reads and enables pagination through a set of `Alert`. */
  alerts: AlertsConnection;
};


/** Table is used to define alert types */
export type AlertTypeAlertsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<AlertsOrderBy>>;
  condition?: Maybe<AlertCondition>;
  filter?: Maybe<AlertFilter>;
};

/**
 * A condition to be used against `AlertType` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type AlertTypeCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `name` field. */
  name?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `severity` field. */
  severity?: Maybe<Scalars['Int']>;
};

/** A filter to be used against `AlertType` object types. All fields are combined with a logical ‘and.’ */
export type AlertTypeFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `name` field. */
  name?: Maybe<StringFilter>;
  /** Filter by the object’s `severity` field. */
  severity?: Maybe<IntFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<AlertTypeFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<AlertTypeFilter>>;
  /** Negates the expression. */
  not?: Maybe<AlertTypeFilter>;
};

/** An input for mutations affecting `AlertType` */
export type AlertTypeInput = {
  /** The label for the alert type */
  name: Scalars['String'];
  severity?: Maybe<Scalars['Int']>;
};

/** Represents an update to a `AlertType`. Fields that are set will be updated. */
export type AlertTypePatch = {
  /** The label for the alert type */
  name?: Maybe<Scalars['String']>;
  severity?: Maybe<Scalars['Int']>;
};

/** A connection to a list of `AlertType` values. */
export type AlertTypesConnection = {
  __typename?: 'AlertTypesConnection';
  /** A list of `AlertType` objects. */
  nodes: Array<Maybe<AlertType>>;
  /** A list of edges which contains the `AlertType` and cursor to aid in pagination. */
  edges: Array<AlertTypesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `AlertType` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `AlertType` edge in the connection. */
export type AlertTypesEdge = {
  __typename?: 'AlertTypesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `AlertType` at the end of the edge. */
  node?: Maybe<AlertType>;
};

/** Methods to use when ordering `AlertType`. */
export enum AlertTypesOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  SeverityAsc = 'SEVERITY_ASC',
  SeverityDesc = 'SEVERITY_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/** A connection to a list of `Alert` values. */
export type AlertsConnection = {
  __typename?: 'AlertsConnection';
  /** A list of `Alert` objects. */
  nodes: Array<Maybe<Alert>>;
  /** A list of edges which contains the `Alert` and cursor to aid in pagination. */
  edges: Array<AlertsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Alert` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `Alert` edge in the connection. */
export type AlertsEdge = {
  __typename?: 'AlertsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Alert` at the end of the edge. */
  node?: Maybe<Alert>;
};

/** Methods to use when ordering `Alert`. */
export enum AlertsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  MessageAsc = 'MESSAGE_ASC',
  MessageDesc = 'MESSAGE_DESC',
  AlertTypeIdAsc = 'ALERT_TYPE_ID_ASC',
  AlertTypeIdDesc = 'ALERT_TYPE_ID_DESC',
  VehicleStatusIdAsc = 'VEHICLE_STATUS_ID_ASC',
  VehicleStatusIdDesc = 'VEHICLE_STATUS_ID_DESC',
  ReadAsc = 'READ_ASC',
  ReadDesc = 'READ_DESC',
  DismissedAsc = 'DISMISSED_ASC',
  DismissedDesc = 'DISMISSED_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}


/** A filter to be used against BigFloat fields. All fields are combined with a logical ‘and.’ */
export type BigFloatFilter = {
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: Maybe<Scalars['Boolean']>;
  /** Equal to the specified value. */
  equalTo?: Maybe<Scalars['BigFloat']>;
  /** Not equal to the specified value. */
  notEqualTo?: Maybe<Scalars['BigFloat']>;
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: Maybe<Scalars['BigFloat']>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: Maybe<Scalars['BigFloat']>;
  /** Included in the specified list. */
  in?: Maybe<Array<Scalars['BigFloat']>>;
  /** Not included in the specified list. */
  notIn?: Maybe<Array<Scalars['BigFloat']>>;
  /** Less than the specified value. */
  lessThan?: Maybe<Scalars['BigFloat']>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: Maybe<Scalars['BigFloat']>;
  /** Greater than the specified value. */
  greaterThan?: Maybe<Scalars['BigFloat']>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: Maybe<Scalars['BigFloat']>;
};


/** A filter to be used against BigInt fields. All fields are combined with a logical ‘and.’ */
export type BigIntFilter = {
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: Maybe<Scalars['Boolean']>;
  /** Equal to the specified value. */
  equalTo?: Maybe<Scalars['BigInt']>;
  /** Not equal to the specified value. */
  notEqualTo?: Maybe<Scalars['BigInt']>;
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: Maybe<Scalars['BigInt']>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: Maybe<Scalars['BigInt']>;
  /** Included in the specified list. */
  in?: Maybe<Array<Scalars['BigInt']>>;
  /** Not included in the specified list. */
  notIn?: Maybe<Array<Scalars['BigInt']>>;
  /** Less than the specified value. */
  lessThan?: Maybe<Scalars['BigInt']>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: Maybe<Scalars['BigInt']>;
  /** Greater than the specified value. */
  greaterThan?: Maybe<Scalars['BigInt']>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: Maybe<Scalars['BigInt']>;
};

/** A filter to be used against Boolean fields. All fields are combined with a logical ‘and.’ */
export type BooleanFilter = {
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: Maybe<Scalars['Boolean']>;
  /** Equal to the specified value. */
  equalTo?: Maybe<Scalars['Boolean']>;
  /** Not equal to the specified value. */
  notEqualTo?: Maybe<Scalars['Boolean']>;
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: Maybe<Scalars['Boolean']>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: Maybe<Scalars['Boolean']>;
  /** Included in the specified list. */
  in?: Maybe<Array<Scalars['Boolean']>>;
  /** Not included in the specified list. */
  notIn?: Maybe<Array<Scalars['Boolean']>>;
  /** Less than the specified value. */
  lessThan?: Maybe<Scalars['Boolean']>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: Maybe<Scalars['Boolean']>;
  /** Greater than the specified value. */
  greaterThan?: Maybe<Scalars['Boolean']>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: Maybe<Scalars['Boolean']>;
};

/** Table camera */
export type Camera = Node & {
  __typename?: 'Camera';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  /** id auto-incremented by database */
  id: Scalars['BigInt'];
  /** timestamp for camera */
  readingat: Scalars['Datetime'];
  /** topic for camera */
  topicId: Scalars['BigInt'];
  /** message id for camera */
  msgId: Scalars['BigInt'];
  /** vehicle id for camera */
  vehicleId: Scalars['BigInt'];
  /** Reads a single `Topic` that is related to this `Camera`. */
  topic?: Maybe<Topic>;
  /** Reads a single `CameraMessage` that is related to this `Camera`. */
  msg?: Maybe<CameraMessage>;
  /** Reads a single `Vehicle` that is related to this `Camera`. */
  vehicle?: Maybe<Vehicle>;
};

/** A condition to be used against `Camera` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type CameraCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `readingat` field. */
  readingat?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `topicId` field. */
  topicId?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `msgId` field. */
  msgId?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `vehicleId` field. */
  vehicleId?: Maybe<Scalars['BigInt']>;
};

/** A filter to be used against `Camera` object types. All fields are combined with a logical ‘and.’ */
export type CameraFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `readingat` field. */
  readingat?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `topicId` field. */
  topicId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `msgId` field. */
  msgId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `vehicleId` field. */
  vehicleId?: Maybe<BigIntFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<CameraFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<CameraFilter>>;
  /** Negates the expression. */
  not?: Maybe<CameraFilter>;
};

/** Table small histogram from camera */
export type CameraHistogram = Node & {
  __typename?: 'CameraHistogram';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  /** Id generated by database, auto incremented */
  id: Scalars['BigInt'];
  /** full histogram id for camera histogram */
  fullHistogramId: Scalars['BigInt'];
  /** small histogram id for camera histogram */
  smallHistogramId: Scalars['BigInt'];
  /** Reads a single `FullHistogram` that is related to this `CameraHistogram`. */
  fullHistogram?: Maybe<FullHistogram>;
  /** Reads a single `SmallHistogram` that is related to this `CameraHistogram`. */
  smallHistogram?: Maybe<SmallHistogram>;
  /** Reads and enables pagination through a set of `CameraMeta`. */
  cameraMetasByLeftHistogramId: CameraMetasConnection;
  /** Reads and enables pagination through a set of `CameraMeta`. */
  cameraMetasByRightHistogramId: CameraMetasConnection;
};


/** Table small histogram from camera */
export type CameraHistogramCameraMetasByLeftHistogramIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CameraMetasOrderBy>>;
  condition?: Maybe<CameraMetaCondition>;
  filter?: Maybe<CameraMetaFilter>;
};


/** Table small histogram from camera */
export type CameraHistogramCameraMetasByRightHistogramIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CameraMetasOrderBy>>;
  condition?: Maybe<CameraMetaCondition>;
  filter?: Maybe<CameraMetaFilter>;
};

/**
 * A condition to be used against `CameraHistogram` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type CameraHistogramCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `fullHistogramId` field. */
  fullHistogramId?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `smallHistogramId` field. */
  smallHistogramId?: Maybe<Scalars['BigInt']>;
};

/** A filter to be used against `CameraHistogram` object types. All fields are combined with a logical ‘and.’ */
export type CameraHistogramFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `fullHistogramId` field. */
  fullHistogramId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `smallHistogramId` field. */
  smallHistogramId?: Maybe<BigIntFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<CameraHistogramFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<CameraHistogramFilter>>;
  /** Negates the expression. */
  not?: Maybe<CameraHistogramFilter>;
};

/** A connection to a list of `CameraHistogram` values. */
export type CameraHistogramsConnection = {
  __typename?: 'CameraHistogramsConnection';
  /** A list of `CameraHistogram` objects. */
  nodes: Array<Maybe<CameraHistogram>>;
  /** A list of edges which contains the `CameraHistogram` and cursor to aid in pagination. */
  edges: Array<CameraHistogramsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `CameraHistogram` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `CameraHistogram` edge in the connection. */
export type CameraHistogramsEdge = {
  __typename?: 'CameraHistogramsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `CameraHistogram` at the end of the edge. */
  node?: Maybe<CameraHistogram>;
};

/** Methods to use when ordering `CameraHistogram`. */
export enum CameraHistogramsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  FullHistogramIdAsc = 'FULL_HISTOGRAM_ID_ASC',
  FullHistogramIdDesc = 'FULL_HISTOGRAM_ID_DESC',
  SmallHistogramIdAsc = 'SMALL_HISTOGRAM_ID_ASC',
  SmallHistogramIdDesc = 'SMALL_HISTOGRAM_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/** Table camera message */
export type CameraMessage = Node & {
  __typename?: 'CameraMessage';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  /** id auto-incremented by database */
  id: Scalars['BigInt'];
  /** header id camera message */
  headerId: Scalars['BigInt'];
  /** image id camera message */
  imageId: Scalars['BigInt'];
  /** camera meta id camera message */
  cameraMetaId: Scalars['BigInt'];
  /** Reads a single `CameraMessageHeader` that is related to this `CameraMessage`. */
  header?: Maybe<CameraMessageHeader>;
  /** Reads a single `Image` that is related to this `CameraMessage`. */
  image?: Maybe<Image>;
  /** Reads a single `CameraMeta` that is related to this `CameraMessage`. */
  cameraMeta?: Maybe<CameraMeta>;
  /** Reads and enables pagination through a set of `Camera`. */
  camerasByMsgId: CamerasConnection;
  /** Reads and enables pagination through a set of `SegmentationMap`. */
  segmentationMapsByMsgId: SegmentationMapsConnection;
};


/** Table camera message */
export type CameraMessageCamerasByMsgIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CamerasOrderBy>>;
  condition?: Maybe<CameraCondition>;
  filter?: Maybe<CameraFilter>;
};


/** Table camera message */
export type CameraMessageSegmentationMapsByMsgIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<SegmentationMapsOrderBy>>;
  condition?: Maybe<SegmentationMapCondition>;
  filter?: Maybe<SegmentationMapFilter>;
};

/**
 * A condition to be used against `CameraMessage` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type CameraMessageCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `headerId` field. */
  headerId?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `imageId` field. */
  imageId?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `cameraMetaId` field. */
  cameraMetaId?: Maybe<Scalars['BigInt']>;
};

/** A filter to be used against `CameraMessage` object types. All fields are combined with a logical ‘and.’ */
export type CameraMessageFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `headerId` field. */
  headerId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `imageId` field. */
  imageId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `cameraMetaId` field. */
  cameraMetaId?: Maybe<BigIntFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<CameraMessageFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<CameraMessageFilter>>;
  /** Negates the expression. */
  not?: Maybe<CameraMessageFilter>;
};

/** Table stores the camera message descriptor */
export type CameraMessageHeader = Node & {
  __typename?: 'CameraMessageHeader';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  /** Id generated by database, auto incremented */
  id: Scalars['BigInt'];
  /** descriptor id for message passed from vehicle */
  headerId: Scalars['BigInt'];
  /** timestamp for message passed from vehicle */
  readingat: Scalars['Datetime'];
  /** seq for message passed from vehicle */
  seq: Scalars['BigFloat'];
  /** node for message passed from vehicle */
  node: Scalars['String'];
  /** Reads and enables pagination through a set of `CameraPairMessage`. */
  cameraPairMessagesByHeaderId: CameraPairMessagesConnection;
  /** Reads and enables pagination through a set of `CameraMessage`. */
  cameraMessagesByHeaderId: CameraMessagesConnection;
};


/** Table stores the camera message descriptor */
export type CameraMessageHeaderCameraPairMessagesByHeaderIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CameraPairMessagesOrderBy>>;
  condition?: Maybe<CameraPairMessageCondition>;
  filter?: Maybe<CameraPairMessageFilter>;
};


/** Table stores the camera message descriptor */
export type CameraMessageHeaderCameraMessagesByHeaderIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CameraMessagesOrderBy>>;
  condition?: Maybe<CameraMessageCondition>;
  filter?: Maybe<CameraMessageFilter>;
};

/**
 * A condition to be used against `CameraMessageHeader` object types. All fields
 * are tested for equality and combined with a logical ‘and.’
 */
export type CameraMessageHeaderCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `headerId` field. */
  headerId?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `readingat` field. */
  readingat?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `seq` field. */
  seq?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `node` field. */
  node?: Maybe<Scalars['String']>;
};

/** A filter to be used against `CameraMessageHeader` object types. All fields are combined with a logical ‘and.’ */
export type CameraMessageHeaderFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `headerId` field. */
  headerId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `readingat` field. */
  readingat?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `seq` field. */
  seq?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `node` field. */
  node?: Maybe<StringFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<CameraMessageHeaderFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<CameraMessageHeaderFilter>>;
  /** Negates the expression. */
  not?: Maybe<CameraMessageHeaderFilter>;
};

/** A connection to a list of `CameraMessageHeader` values. */
export type CameraMessageHeadersConnection = {
  __typename?: 'CameraMessageHeadersConnection';
  /** A list of `CameraMessageHeader` objects. */
  nodes: Array<Maybe<CameraMessageHeader>>;
  /** A list of edges which contains the `CameraMessageHeader` and cursor to aid in pagination. */
  edges: Array<CameraMessageHeadersEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `CameraMessageHeader` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `CameraMessageHeader` edge in the connection. */
export type CameraMessageHeadersEdge = {
  __typename?: 'CameraMessageHeadersEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `CameraMessageHeader` at the end of the edge. */
  node?: Maybe<CameraMessageHeader>;
};

/** Methods to use when ordering `CameraMessageHeader`. */
export enum CameraMessageHeadersOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  HeaderIdAsc = 'HEADER_ID_ASC',
  HeaderIdDesc = 'HEADER_ID_DESC',
  ReadingatAsc = 'READINGAT_ASC',
  ReadingatDesc = 'READINGAT_DESC',
  SeqAsc = 'SEQ_ASC',
  SeqDesc = 'SEQ_DESC',
  NodeAsc = 'NODE_ASC',
  NodeDesc = 'NODE_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/** Represents an update to a `CameraMessage`. Fields that are set will be updated. */
export type CameraMessagePatch = {
  /** id auto-incremented by database */
  id?: Maybe<Scalars['BigInt']>;
  /** header id camera message */
  headerId?: Maybe<Scalars['BigInt']>;
  /** image id camera message */
  imageId?: Maybe<Scalars['BigInt']>;
  /** camera meta id camera message */
  cameraMetaId?: Maybe<Scalars['BigInt']>;
};

/** A connection to a list of `CameraMessage` values. */
export type CameraMessagesConnection = {
  __typename?: 'CameraMessagesConnection';
  /** A list of `CameraMessage` objects. */
  nodes: Array<Maybe<CameraMessage>>;
  /** A list of edges which contains the `CameraMessage` and cursor to aid in pagination. */
  edges: Array<CameraMessagesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `CameraMessage` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `CameraMessage` edge in the connection. */
export type CameraMessagesEdge = {
  __typename?: 'CameraMessagesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `CameraMessage` at the end of the edge. */
  node?: Maybe<CameraMessage>;
};

/** Methods to use when ordering `CameraMessage`. */
export enum CameraMessagesOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  HeaderIdAsc = 'HEADER_ID_ASC',
  HeaderIdDesc = 'HEADER_ID_DESC',
  ImageIdAsc = 'IMAGE_ID_ASC',
  ImageIdDesc = 'IMAGE_ID_DESC',
  CameraMetaIdAsc = 'CAMERA_META_ID_ASC',
  CameraMetaIdDesc = 'CAMERA_META_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/** Table camera meta */
export type CameraMeta = Node & {
  __typename?: 'CameraMeta';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  /** id auto-incremented by database */
  id: Scalars['BigInt'];
  /** camera serial number */
  serialNumber: Scalars['String'];
  /** camera name */
  cameraName?: Maybe<Scalars['String']>;
  leftIntrinsicsId: Scalars['BigInt'];
  rightIntrinsicsId: Scalars['BigInt'];
  stereoExtrinsicsId: Scalars['BigInt'];
  tractorExtrinsicsId: Scalars['BigInt'];
  eId: Scalars['BigInt'];
  fId: Scalars['BigInt'];
  r1Id: Scalars['BigInt'];
  r2Id: Scalars['BigInt'];
  p1Id: Scalars['BigInt'];
  p2Id: Scalars['BigInt'];
  qId: Scalars['BigInt'];
  leftRoiId?: Maybe<Scalars['BigInt']>;
  rightRoiId?: Maybe<Scalars['BigInt']>;
  leftExposure?: Maybe<Scalars['BigFloat']>;
  rightExposure?: Maybe<Scalars['BigFloat']>;
  leftGain?: Maybe<Scalars['BigFloat']>;
  rightGain?: Maybe<Scalars['BigFloat']>;
  extra?: Maybe<Scalars['String']>;
  leftHistogramId: Scalars['BigInt'];
  rightHistogramId: Scalars['BigInt'];
  /** Reads a single `SideIntrinsic` that is related to this `CameraMeta`. */
  leftIntrinsics?: Maybe<SideIntrinsic>;
  /** Reads a single `SideIntrinsic` that is related to this `CameraMeta`. */
  rightIntrinsics?: Maybe<SideIntrinsic>;
  /** Reads a single `StereoExtrinsic` that is related to this `CameraMeta`. */
  stereoExtrinsics?: Maybe<StereoExtrinsic>;
  /** Reads a single `TractorExtrinsic` that is related to this `CameraMeta`. */
  tractorExtrinsics?: Maybe<TractorExtrinsic>;
  /** Reads a single `CameraMetaE` that is related to this `CameraMeta`. */
  e?: Maybe<CameraMetaE>;
  /** Reads a single `CameraMetaF` that is related to this `CameraMeta`. */
  f?: Maybe<CameraMetaF>;
  /** Reads a single `CameraMetaR1` that is related to this `CameraMeta`. */
  r1?: Maybe<CameraMetaR1>;
  /** Reads a single `CameraMetaR2` that is related to this `CameraMeta`. */
  r2?: Maybe<CameraMetaR2>;
  /** Reads a single `CameraMetaP1` that is related to this `CameraMeta`. */
  p1?: Maybe<CameraMetaP1>;
  /** Reads a single `CameraMetaP2` that is related to this `CameraMeta`. */
  p2?: Maybe<CameraMetaP2>;
  /** Reads a single `CameraMetaQ` that is related to this `CameraMeta`. */
  q?: Maybe<CameraMetaQ>;
  /** Reads a single `CameraRoi` that is related to this `CameraMeta`. */
  leftRoi?: Maybe<CameraRoi>;
  /** Reads a single `CameraRoi` that is related to this `CameraMeta`. */
  rightRoi?: Maybe<CameraRoi>;
  /** Reads a single `CameraHistogram` that is related to this `CameraMeta`. */
  leftHistogram?: Maybe<CameraHistogram>;
  /** Reads a single `CameraHistogram` that is related to this `CameraMeta`. */
  rightHistogram?: Maybe<CameraHistogram>;
  /** Reads and enables pagination through a set of `CameraPairMessage`. */
  cameraPairMessages: CameraPairMessagesConnection;
  /** Reads and enables pagination through a set of `CameraMessage`. */
  cameraMessages: CameraMessagesConnection;
};


/** Table camera meta */
export type CameraMetaCameraPairMessagesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CameraPairMessagesOrderBy>>;
  condition?: Maybe<CameraPairMessageCondition>;
  filter?: Maybe<CameraPairMessageFilter>;
};


/** Table camera meta */
export type CameraMetaCameraMessagesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CameraMessagesOrderBy>>;
  condition?: Maybe<CameraMessageCondition>;
  filter?: Maybe<CameraMessageFilter>;
};

/**
 * A condition to be used against `CameraMeta` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type CameraMetaCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `serialNumber` field. */
  serialNumber?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `cameraName` field. */
  cameraName?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `leftIntrinsicsId` field. */
  leftIntrinsicsId?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `rightIntrinsicsId` field. */
  rightIntrinsicsId?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `stereoExtrinsicsId` field. */
  stereoExtrinsicsId?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `tractorExtrinsicsId` field. */
  tractorExtrinsicsId?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `eId` field. */
  eId?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `fId` field. */
  fId?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `r1Id` field. */
  r1Id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `r2Id` field. */
  r2Id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `p1Id` field. */
  p1Id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `p2Id` field. */
  p2Id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `qId` field. */
  qId?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `leftRoiId` field. */
  leftRoiId?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `rightRoiId` field. */
  rightRoiId?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `leftExposure` field. */
  leftExposure?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `rightExposure` field. */
  rightExposure?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `leftGain` field. */
  leftGain?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `rightGain` field. */
  rightGain?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `extra` field. */
  extra?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `leftHistogramId` field. */
  leftHistogramId?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `rightHistogramId` field. */
  rightHistogramId?: Maybe<Scalars['BigInt']>;
};

/** Table camera meta e from camera */
export type CameraMetaE = Node & {
  __typename?: 'CameraMetaE';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  /** Id generated by database, auto incremented */
  id: Scalars['BigInt'];
  /** data for camera meta e */
  data: Scalars['String'];
  /** Reads and enables pagination through a set of `CameraMeta`. */
  cameraMetasByEId: CameraMetasConnection;
};


/** Table camera meta e from camera */
export type CameraMetaECameraMetasByEIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CameraMetasOrderBy>>;
  condition?: Maybe<CameraMetaCondition>;
  filter?: Maybe<CameraMetaFilter>;
};

/**
 * A condition to be used against `CameraMetaE` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type CameraMetaECondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `data` field. */
  data?: Maybe<Scalars['String']>;
};

/** A filter to be used against `CameraMetaE` object types. All fields are combined with a logical ‘and.’ */
export type CameraMetaEFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `data` field. */
  data?: Maybe<StringFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<CameraMetaEFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<CameraMetaEFilter>>;
  /** Negates the expression. */
  not?: Maybe<CameraMetaEFilter>;
};

/** A connection to a list of `CameraMetaE` values. */
export type CameraMetaEsConnection = {
  __typename?: 'CameraMetaEsConnection';
  /** A list of `CameraMetaE` objects. */
  nodes: Array<Maybe<CameraMetaE>>;
  /** A list of edges which contains the `CameraMetaE` and cursor to aid in pagination. */
  edges: Array<CameraMetaEsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `CameraMetaE` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `CameraMetaE` edge in the connection. */
export type CameraMetaEsEdge = {
  __typename?: 'CameraMetaEsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `CameraMetaE` at the end of the edge. */
  node?: Maybe<CameraMetaE>;
};

/** Methods to use when ordering `CameraMetaE`. */
export enum CameraMetaEsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  DataAsc = 'DATA_ASC',
  DataDesc = 'DATA_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/** Table camera meta f from camera */
export type CameraMetaF = Node & {
  __typename?: 'CameraMetaF';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  /** Id generated by database, auto incremented */
  id: Scalars['BigInt'];
  /** data for camera meta f */
  data: Scalars['String'];
  /** Reads and enables pagination through a set of `CameraMeta`. */
  cameraMetasByFId: CameraMetasConnection;
};


/** Table camera meta f from camera */
export type CameraMetaFCameraMetasByFIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CameraMetasOrderBy>>;
  condition?: Maybe<CameraMetaCondition>;
  filter?: Maybe<CameraMetaFilter>;
};

/**
 * A condition to be used against `CameraMetaF` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type CameraMetaFCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `data` field. */
  data?: Maybe<Scalars['String']>;
};

/** A filter to be used against `CameraMetaF` object types. All fields are combined with a logical ‘and.’ */
export type CameraMetaFFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `data` field. */
  data?: Maybe<StringFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<CameraMetaFFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<CameraMetaFFilter>>;
  /** Negates the expression. */
  not?: Maybe<CameraMetaFFilter>;
};

/** A filter to be used against `CameraMeta` object types. All fields are combined with a logical ‘and.’ */
export type CameraMetaFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `serialNumber` field. */
  serialNumber?: Maybe<StringFilter>;
  /** Filter by the object’s `cameraName` field. */
  cameraName?: Maybe<StringFilter>;
  /** Filter by the object’s `leftIntrinsicsId` field. */
  leftIntrinsicsId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `rightIntrinsicsId` field. */
  rightIntrinsicsId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `stereoExtrinsicsId` field. */
  stereoExtrinsicsId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `tractorExtrinsicsId` field. */
  tractorExtrinsicsId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `eId` field. */
  eId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `fId` field. */
  fId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `r1Id` field. */
  r1Id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `r2Id` field. */
  r2Id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `p1Id` field. */
  p1Id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `p2Id` field. */
  p2Id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `qId` field. */
  qId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `leftRoiId` field. */
  leftRoiId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `rightRoiId` field. */
  rightRoiId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `leftExposure` field. */
  leftExposure?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `rightExposure` field. */
  rightExposure?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `leftGain` field. */
  leftGain?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `rightGain` field. */
  rightGain?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `extra` field. */
  extra?: Maybe<StringFilter>;
  /** Filter by the object’s `leftHistogramId` field. */
  leftHistogramId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `rightHistogramId` field. */
  rightHistogramId?: Maybe<BigIntFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<CameraMetaFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<CameraMetaFilter>>;
  /** Negates the expression. */
  not?: Maybe<CameraMetaFilter>;
};

/** A connection to a list of `CameraMetaF` values. */
export type CameraMetaFsConnection = {
  __typename?: 'CameraMetaFsConnection';
  /** A list of `CameraMetaF` objects. */
  nodes: Array<Maybe<CameraMetaF>>;
  /** A list of edges which contains the `CameraMetaF` and cursor to aid in pagination. */
  edges: Array<CameraMetaFsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `CameraMetaF` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `CameraMetaF` edge in the connection. */
export type CameraMetaFsEdge = {
  __typename?: 'CameraMetaFsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `CameraMetaF` at the end of the edge. */
  node?: Maybe<CameraMetaF>;
};

/** Methods to use when ordering `CameraMetaF`. */
export enum CameraMetaFsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  DataAsc = 'DATA_ASC',
  DataDesc = 'DATA_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/** Table camera meta p1 from camera */
export type CameraMetaP1 = Node & {
  __typename?: 'CameraMetaP1';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  /** Id generated by database, auto incremented */
  id: Scalars['BigInt'];
  /** data for camera meta p1 */
  data: Scalars['String'];
  /** Reads and enables pagination through a set of `CameraMeta`. */
  cameraMetasByP1Id: CameraMetasConnection;
};


/** Table camera meta p1 from camera */
export type CameraMetaP1CameraMetasByP1IdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CameraMetasOrderBy>>;
  condition?: Maybe<CameraMetaCondition>;
  filter?: Maybe<CameraMetaFilter>;
};

/**
 * A condition to be used against `CameraMetaP1` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type CameraMetaP1Condition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `data` field. */
  data?: Maybe<Scalars['String']>;
};

/** A filter to be used against `CameraMetaP1` object types. All fields are combined with a logical ‘and.’ */
export type CameraMetaP1Filter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `data` field. */
  data?: Maybe<StringFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<CameraMetaP1Filter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<CameraMetaP1Filter>>;
  /** Negates the expression. */
  not?: Maybe<CameraMetaP1Filter>;
};

/** A connection to a list of `CameraMetaP1` values. */
export type CameraMetaP1sConnection = {
  __typename?: 'CameraMetaP1sConnection';
  /** A list of `CameraMetaP1` objects. */
  nodes: Array<Maybe<CameraMetaP1>>;
  /** A list of edges which contains the `CameraMetaP1` and cursor to aid in pagination. */
  edges: Array<CameraMetaP1sEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `CameraMetaP1` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `CameraMetaP1` edge in the connection. */
export type CameraMetaP1sEdge = {
  __typename?: 'CameraMetaP1sEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `CameraMetaP1` at the end of the edge. */
  node?: Maybe<CameraMetaP1>;
};

/** Methods to use when ordering `CameraMetaP1`. */
export enum CameraMetaP1sOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  DataAsc = 'DATA_ASC',
  DataDesc = 'DATA_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/** Table camera meta p2 from camera */
export type CameraMetaP2 = Node & {
  __typename?: 'CameraMetaP2';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  /** Id generated by database, auto incremented */
  id: Scalars['BigInt'];
  /** data for camera meta p2 */
  data: Scalars['String'];
  /** Reads and enables pagination through a set of `CameraMeta`. */
  cameraMetasByP2Id: CameraMetasConnection;
};


/** Table camera meta p2 from camera */
export type CameraMetaP2CameraMetasByP2IdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CameraMetasOrderBy>>;
  condition?: Maybe<CameraMetaCondition>;
  filter?: Maybe<CameraMetaFilter>;
};

/**
 * A condition to be used against `CameraMetaP2` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type CameraMetaP2Condition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `data` field. */
  data?: Maybe<Scalars['String']>;
};

/** A filter to be used against `CameraMetaP2` object types. All fields are combined with a logical ‘and.’ */
export type CameraMetaP2Filter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `data` field. */
  data?: Maybe<StringFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<CameraMetaP2Filter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<CameraMetaP2Filter>>;
  /** Negates the expression. */
  not?: Maybe<CameraMetaP2Filter>;
};

/** A connection to a list of `CameraMetaP2` values. */
export type CameraMetaP2sConnection = {
  __typename?: 'CameraMetaP2sConnection';
  /** A list of `CameraMetaP2` objects. */
  nodes: Array<Maybe<CameraMetaP2>>;
  /** A list of edges which contains the `CameraMetaP2` and cursor to aid in pagination. */
  edges: Array<CameraMetaP2sEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `CameraMetaP2` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `CameraMetaP2` edge in the connection. */
export type CameraMetaP2sEdge = {
  __typename?: 'CameraMetaP2sEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `CameraMetaP2` at the end of the edge. */
  node?: Maybe<CameraMetaP2>;
};

/** Methods to use when ordering `CameraMetaP2`. */
export enum CameraMetaP2sOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  DataAsc = 'DATA_ASC',
  DataDesc = 'DATA_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/** Represents an update to a `CameraMeta`. Fields that are set will be updated. */
export type CameraMetaPatch = {
  /** id auto-incremented by database */
  id?: Maybe<Scalars['BigInt']>;
  /** camera serial number */
  serialNumber?: Maybe<Scalars['String']>;
  /** camera name */
  cameraName?: Maybe<Scalars['String']>;
  leftIntrinsicsId?: Maybe<Scalars['BigInt']>;
  rightIntrinsicsId?: Maybe<Scalars['BigInt']>;
  stereoExtrinsicsId?: Maybe<Scalars['BigInt']>;
  tractorExtrinsicsId?: Maybe<Scalars['BigInt']>;
  eId?: Maybe<Scalars['BigInt']>;
  fId?: Maybe<Scalars['BigInt']>;
  r1Id?: Maybe<Scalars['BigInt']>;
  r2Id?: Maybe<Scalars['BigInt']>;
  p1Id?: Maybe<Scalars['BigInt']>;
  p2Id?: Maybe<Scalars['BigInt']>;
  qId?: Maybe<Scalars['BigInt']>;
  leftRoiId?: Maybe<Scalars['BigInt']>;
  rightRoiId?: Maybe<Scalars['BigInt']>;
  leftExposure?: Maybe<Scalars['BigFloat']>;
  rightExposure?: Maybe<Scalars['BigFloat']>;
  leftGain?: Maybe<Scalars['BigFloat']>;
  rightGain?: Maybe<Scalars['BigFloat']>;
  extra?: Maybe<Scalars['String']>;
  leftHistogramId?: Maybe<Scalars['BigInt']>;
  rightHistogramId?: Maybe<Scalars['BigInt']>;
};

/** Table camera meta q from camera */
export type CameraMetaQ = Node & {
  __typename?: 'CameraMetaQ';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  /** Id generated by database, auto incremented */
  id: Scalars['BigInt'];
  /** data for camera meta q */
  data: Scalars['String'];
  /** Reads and enables pagination through a set of `CameraMeta`. */
  cameraMetasByQId: CameraMetasConnection;
};


/** Table camera meta q from camera */
export type CameraMetaQCameraMetasByQIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CameraMetasOrderBy>>;
  condition?: Maybe<CameraMetaCondition>;
  filter?: Maybe<CameraMetaFilter>;
};

/**
 * A condition to be used against `CameraMetaQ` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type CameraMetaQCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `data` field. */
  data?: Maybe<Scalars['String']>;
};

/** A filter to be used against `CameraMetaQ` object types. All fields are combined with a logical ‘and.’ */
export type CameraMetaQFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `data` field. */
  data?: Maybe<StringFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<CameraMetaQFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<CameraMetaQFilter>>;
  /** Negates the expression. */
  not?: Maybe<CameraMetaQFilter>;
};

/** A connection to a list of `CameraMetaQ` values. */
export type CameraMetaQsConnection = {
  __typename?: 'CameraMetaQsConnection';
  /** A list of `CameraMetaQ` objects. */
  nodes: Array<Maybe<CameraMetaQ>>;
  /** A list of edges which contains the `CameraMetaQ` and cursor to aid in pagination. */
  edges: Array<CameraMetaQsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `CameraMetaQ` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `CameraMetaQ` edge in the connection. */
export type CameraMetaQsEdge = {
  __typename?: 'CameraMetaQsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `CameraMetaQ` at the end of the edge. */
  node?: Maybe<CameraMetaQ>;
};

/** Methods to use when ordering `CameraMetaQ`. */
export enum CameraMetaQsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  DataAsc = 'DATA_ASC',
  DataDesc = 'DATA_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/** Table camera meta r1 from camera */
export type CameraMetaR1 = Node & {
  __typename?: 'CameraMetaR1';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  /** Id generated by database, auto incremented */
  id: Scalars['BigInt'];
  /** data for camera meta r1 */
  data: Scalars['String'];
  /** Reads and enables pagination through a set of `CameraMeta`. */
  cameraMetasByR1Id: CameraMetasConnection;
};


/** Table camera meta r1 from camera */
export type CameraMetaR1CameraMetasByR1IdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CameraMetasOrderBy>>;
  condition?: Maybe<CameraMetaCondition>;
  filter?: Maybe<CameraMetaFilter>;
};

/**
 * A condition to be used against `CameraMetaR1` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type CameraMetaR1Condition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `data` field. */
  data?: Maybe<Scalars['String']>;
};

/** A filter to be used against `CameraMetaR1` object types. All fields are combined with a logical ‘and.’ */
export type CameraMetaR1Filter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `data` field. */
  data?: Maybe<StringFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<CameraMetaR1Filter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<CameraMetaR1Filter>>;
  /** Negates the expression. */
  not?: Maybe<CameraMetaR1Filter>;
};

/** A connection to a list of `CameraMetaR1` values. */
export type CameraMetaR1sConnection = {
  __typename?: 'CameraMetaR1sConnection';
  /** A list of `CameraMetaR1` objects. */
  nodes: Array<Maybe<CameraMetaR1>>;
  /** A list of edges which contains the `CameraMetaR1` and cursor to aid in pagination. */
  edges: Array<CameraMetaR1sEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `CameraMetaR1` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `CameraMetaR1` edge in the connection. */
export type CameraMetaR1sEdge = {
  __typename?: 'CameraMetaR1sEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `CameraMetaR1` at the end of the edge. */
  node?: Maybe<CameraMetaR1>;
};

/** Methods to use when ordering `CameraMetaR1`. */
export enum CameraMetaR1sOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  DataAsc = 'DATA_ASC',
  DataDesc = 'DATA_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/** Table camera meta r2 from camera */
export type CameraMetaR2 = Node & {
  __typename?: 'CameraMetaR2';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  /** Id generated by database, auto incremented */
  id: Scalars['BigInt'];
  /** data for camera meta r2 */
  data: Scalars['String'];
  /** Reads and enables pagination through a set of `CameraMeta`. */
  cameraMetasByR2Id: CameraMetasConnection;
};


/** Table camera meta r2 from camera */
export type CameraMetaR2CameraMetasByR2IdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CameraMetasOrderBy>>;
  condition?: Maybe<CameraMetaCondition>;
  filter?: Maybe<CameraMetaFilter>;
};

/**
 * A condition to be used against `CameraMetaR2` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type CameraMetaR2Condition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `data` field. */
  data?: Maybe<Scalars['String']>;
};

/** A filter to be used against `CameraMetaR2` object types. All fields are combined with a logical ‘and.’ */
export type CameraMetaR2Filter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `data` field. */
  data?: Maybe<StringFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<CameraMetaR2Filter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<CameraMetaR2Filter>>;
  /** Negates the expression. */
  not?: Maybe<CameraMetaR2Filter>;
};

/** A connection to a list of `CameraMetaR2` values. */
export type CameraMetaR2sConnection = {
  __typename?: 'CameraMetaR2sConnection';
  /** A list of `CameraMetaR2` objects. */
  nodes: Array<Maybe<CameraMetaR2>>;
  /** A list of edges which contains the `CameraMetaR2` and cursor to aid in pagination. */
  edges: Array<CameraMetaR2sEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `CameraMetaR2` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `CameraMetaR2` edge in the connection. */
export type CameraMetaR2sEdge = {
  __typename?: 'CameraMetaR2sEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `CameraMetaR2` at the end of the edge. */
  node?: Maybe<CameraMetaR2>;
};

/** Methods to use when ordering `CameraMetaR2`. */
export enum CameraMetaR2sOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  DataAsc = 'DATA_ASC',
  DataDesc = 'DATA_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/** A connection to a list of `CameraMeta` values. */
export type CameraMetasConnection = {
  __typename?: 'CameraMetasConnection';
  /** A list of `CameraMeta` objects. */
  nodes: Array<Maybe<CameraMeta>>;
  /** A list of edges which contains the `CameraMeta` and cursor to aid in pagination. */
  edges: Array<CameraMetasEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `CameraMeta` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `CameraMeta` edge in the connection. */
export type CameraMetasEdge = {
  __typename?: 'CameraMetasEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `CameraMeta` at the end of the edge. */
  node?: Maybe<CameraMeta>;
};

/** Methods to use when ordering `CameraMeta`. */
export enum CameraMetasOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  SerialNumberAsc = 'SERIAL_NUMBER_ASC',
  SerialNumberDesc = 'SERIAL_NUMBER_DESC',
  CameraNameAsc = 'CAMERA_NAME_ASC',
  CameraNameDesc = 'CAMERA_NAME_DESC',
  LeftIntrinsicsIdAsc = 'LEFT_INTRINSICS_ID_ASC',
  LeftIntrinsicsIdDesc = 'LEFT_INTRINSICS_ID_DESC',
  RightIntrinsicsIdAsc = 'RIGHT_INTRINSICS_ID_ASC',
  RightIntrinsicsIdDesc = 'RIGHT_INTRINSICS_ID_DESC',
  StereoExtrinsicsIdAsc = 'STEREO_EXTRINSICS_ID_ASC',
  StereoExtrinsicsIdDesc = 'STEREO_EXTRINSICS_ID_DESC',
  TractorExtrinsicsIdAsc = 'TRACTOR_EXTRINSICS_ID_ASC',
  TractorExtrinsicsIdDesc = 'TRACTOR_EXTRINSICS_ID_DESC',
  EIdAsc = 'E_ID_ASC',
  EIdDesc = 'E_ID_DESC',
  FIdAsc = 'F_ID_ASC',
  FIdDesc = 'F_ID_DESC',
  R1IdAsc = 'R1_ID_ASC',
  R1IdDesc = 'R1_ID_DESC',
  R2IdAsc = 'R2_ID_ASC',
  R2IdDesc = 'R2_ID_DESC',
  P1IdAsc = 'P1_ID_ASC',
  P1IdDesc = 'P1_ID_DESC',
  P2IdAsc = 'P2_ID_ASC',
  P2IdDesc = 'P2_ID_DESC',
  QIdAsc = 'Q_ID_ASC',
  QIdDesc = 'Q_ID_DESC',
  LeftRoiIdAsc = 'LEFT_ROI_ID_ASC',
  LeftRoiIdDesc = 'LEFT_ROI_ID_DESC',
  RightRoiIdAsc = 'RIGHT_ROI_ID_ASC',
  RightRoiIdDesc = 'RIGHT_ROI_ID_DESC',
  LeftExposureAsc = 'LEFT_EXPOSURE_ASC',
  LeftExposureDesc = 'LEFT_EXPOSURE_DESC',
  RightExposureAsc = 'RIGHT_EXPOSURE_ASC',
  RightExposureDesc = 'RIGHT_EXPOSURE_DESC',
  LeftGainAsc = 'LEFT_GAIN_ASC',
  LeftGainDesc = 'LEFT_GAIN_DESC',
  RightGainAsc = 'RIGHT_GAIN_ASC',
  RightGainDesc = 'RIGHT_GAIN_DESC',
  ExtraAsc = 'EXTRA_ASC',
  ExtraDesc = 'EXTRA_DESC',
  LeftHistogramIdAsc = 'LEFT_HISTOGRAM_ID_ASC',
  LeftHistogramIdDesc = 'LEFT_HISTOGRAM_ID_DESC',
  RightHistogramIdAsc = 'RIGHT_HISTOGRAM_ID_ASC',
  RightHistogramIdDesc = 'RIGHT_HISTOGRAM_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/** Table camera pair message */
export type CameraPair = Node & {
  __typename?: 'CameraPair';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  /** id auto-incremented by database */
  id: Scalars['BigInt'];
  /** timestamp for camera pair */
  readingat: Scalars['Datetime'];
  /** topic for camera pair */
  topicId: Scalars['BigInt'];
  /** message for camera pair */
  msgId: Scalars['BigInt'];
  /** topic type for camera pair */
  topicTypeId: Scalars['BigInt'];
  /** vehicle associated with the camera pair */
  vehicleId: Scalars['BigInt'];
  /** Reads a single `Topic` that is related to this `CameraPair`. */
  topic?: Maybe<Topic>;
  /** Reads a single `CameraPairMessage` that is related to this `CameraPair`. */
  msg?: Maybe<CameraPairMessage>;
  /** Reads a single `TopicType` that is related to this `CameraPair`. */
  topicType?: Maybe<TopicType>;
  /** Reads a single `Vehicle` that is related to this `CameraPair`. */
  vehicle?: Maybe<Vehicle>;
};

/**
 * A condition to be used against `CameraPair` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type CameraPairCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `readingat` field. */
  readingat?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `topicId` field. */
  topicId?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `msgId` field. */
  msgId?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `topicTypeId` field. */
  topicTypeId?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `vehicleId` field. */
  vehicleId?: Maybe<Scalars['BigInt']>;
};

/** A filter to be used against `CameraPair` object types. All fields are combined with a logical ‘and.’ */
export type CameraPairFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `readingat` field. */
  readingat?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `topicId` field. */
  topicId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `msgId` field. */
  msgId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `topicTypeId` field. */
  topicTypeId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `vehicleId` field. */
  vehicleId?: Maybe<BigIntFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<CameraPairFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<CameraPairFilter>>;
  /** Negates the expression. */
  not?: Maybe<CameraPairFilter>;
};

/** Table camera pair message */
export type CameraPairMessage = Node & {
  __typename?: 'CameraPairMessage';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  /** id auto-incremented by database */
  id: Scalars['BigInt'];
  headerId: Scalars['BigInt'];
  /** left image id for camera message pair */
  leftImageId: Scalars['BigInt'];
  /** right image id for camera message pair */
  rightImageId: Scalars['BigInt'];
  /** camera meta id for camera message pair */
  cameraMetaId: Scalars['BigInt'];
  /** Reads a single `CameraMessageHeader` that is related to this `CameraPairMessage`. */
  header?: Maybe<CameraMessageHeader>;
  /** Reads a single `Image` that is related to this `CameraPairMessage`. */
  leftImage?: Maybe<Image>;
  /** Reads a single `Image` that is related to this `CameraPairMessage`. */
  rightImage?: Maybe<Image>;
  /** Reads a single `CameraMeta` that is related to this `CameraPairMessage`. */
  cameraMeta?: Maybe<CameraMeta>;
  /** Reads and enables pagination through a set of `CameraPair`. */
  cameraPairsByMsgId: CameraPairsConnection;
};


/** Table camera pair message */
export type CameraPairMessageCameraPairsByMsgIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CameraPairsOrderBy>>;
  condition?: Maybe<CameraPairCondition>;
  filter?: Maybe<CameraPairFilter>;
};

/**
 * A condition to be used against `CameraPairMessage` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type CameraPairMessageCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `headerId` field. */
  headerId?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `leftImageId` field. */
  leftImageId?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `rightImageId` field. */
  rightImageId?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `cameraMetaId` field. */
  cameraMetaId?: Maybe<Scalars['BigInt']>;
};

/** A filter to be used against `CameraPairMessage` object types. All fields are combined with a logical ‘and.’ */
export type CameraPairMessageFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `headerId` field. */
  headerId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `leftImageId` field. */
  leftImageId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `rightImageId` field. */
  rightImageId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `cameraMetaId` field. */
  cameraMetaId?: Maybe<BigIntFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<CameraPairMessageFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<CameraPairMessageFilter>>;
  /** Negates the expression. */
  not?: Maybe<CameraPairMessageFilter>;
};

/** An input for mutations affecting `CameraPairMessage` */
export type CameraPairMessageInput = {
  headerId: Scalars['BigInt'];
};

/** Represents an update to a `CameraPairMessage`. Fields that are set will be updated. */
export type CameraPairMessagePatch = {
  /** id auto-incremented by database */
  id?: Maybe<Scalars['BigInt']>;
  headerId?: Maybe<Scalars['BigInt']>;
  /** left image id for camera message pair */
  leftImageId?: Maybe<Scalars['BigInt']>;
  /** right image id for camera message pair */
  rightImageId?: Maybe<Scalars['BigInt']>;
  /** camera meta id for camera message pair */
  cameraMetaId?: Maybe<Scalars['BigInt']>;
};

/** A connection to a list of `CameraPairMessage` values. */
export type CameraPairMessagesConnection = {
  __typename?: 'CameraPairMessagesConnection';
  /** A list of `CameraPairMessage` objects. */
  nodes: Array<Maybe<CameraPairMessage>>;
  /** A list of edges which contains the `CameraPairMessage` and cursor to aid in pagination. */
  edges: Array<CameraPairMessagesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `CameraPairMessage` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `CameraPairMessage` edge in the connection. */
export type CameraPairMessagesEdge = {
  __typename?: 'CameraPairMessagesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `CameraPairMessage` at the end of the edge. */
  node?: Maybe<CameraPairMessage>;
};

/** Methods to use when ordering `CameraPairMessage`. */
export enum CameraPairMessagesOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  HeaderIdAsc = 'HEADER_ID_ASC',
  HeaderIdDesc = 'HEADER_ID_DESC',
  LeftImageIdAsc = 'LEFT_IMAGE_ID_ASC',
  LeftImageIdDesc = 'LEFT_IMAGE_ID_DESC',
  RightImageIdAsc = 'RIGHT_IMAGE_ID_ASC',
  RightImageIdDesc = 'RIGHT_IMAGE_ID_DESC',
  CameraMetaIdAsc = 'CAMERA_META_ID_ASC',
  CameraMetaIdDesc = 'CAMERA_META_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/** Represents an update to a `CameraPair`. Fields that are set will be updated. */
export type CameraPairPatch = {
  /** id auto-incremented by database */
  id?: Maybe<Scalars['BigInt']>;
  /** timestamp for camera pair */
  readingat?: Maybe<Scalars['Datetime']>;
  /** topic for camera pair */
  topicId?: Maybe<Scalars['BigInt']>;
  /** message for camera pair */
  msgId?: Maybe<Scalars['BigInt']>;
  /** topic type for camera pair */
  topicTypeId?: Maybe<Scalars['BigInt']>;
  /** vehicle associated with the camera pair */
  vehicleId?: Maybe<Scalars['BigInt']>;
};

/** A connection to a list of `CameraPair` values. */
export type CameraPairsConnection = {
  __typename?: 'CameraPairsConnection';
  /** A list of `CameraPair` objects. */
  nodes: Array<Maybe<CameraPair>>;
  /** A list of edges which contains the `CameraPair` and cursor to aid in pagination. */
  edges: Array<CameraPairsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `CameraPair` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `CameraPair` edge in the connection. */
export type CameraPairsEdge = {
  __typename?: 'CameraPairsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `CameraPair` at the end of the edge. */
  node?: Maybe<CameraPair>;
};

/** Methods to use when ordering `CameraPair`. */
export enum CameraPairsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  ReadingatAsc = 'READINGAT_ASC',
  ReadingatDesc = 'READINGAT_DESC',
  TopicIdAsc = 'TOPIC_ID_ASC',
  TopicIdDesc = 'TOPIC_ID_DESC',
  MsgIdAsc = 'MSG_ID_ASC',
  MsgIdDesc = 'MSG_ID_DESC',
  TopicTypeIdAsc = 'TOPIC_TYPE_ID_ASC',
  TopicTypeIdDesc = 'TOPIC_TYPE_ID_DESC',
  VehicleIdAsc = 'VEHICLE_ID_ASC',
  VehicleIdDesc = 'VEHICLE_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/** Represents an update to a `Camera`. Fields that are set will be updated. */
export type CameraPatch = {
  /** id auto-incremented by database */
  id?: Maybe<Scalars['BigInt']>;
  /** timestamp for camera */
  readingat?: Maybe<Scalars['Datetime']>;
  /** topic for camera */
  topicId?: Maybe<Scalars['BigInt']>;
  /** message id for camera */
  msgId?: Maybe<Scalars['BigInt']>;
  /** vehicle id for camera */
  vehicleId?: Maybe<Scalars['BigInt']>;
};

/** Table camera roi from camera */
export type CameraRoi = Node & {
  __typename?: 'CameraRoi';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  /** Id generated by database, auto incremented */
  id: Scalars['BigInt'];
  /** x_offset for camera roi */
  xOffset: Scalars['BigFloat'];
  /** y_offset for camera roi */
  yOffset: Scalars['BigFloat'];
  /** height for camera roi */
  height: Scalars['Int'];
  /** width for camera roi */
  width: Scalars['Int'];
  /** do_rectify for camera roi */
  doRectify: Scalars['Boolean'];
  /** Reads and enables pagination through a set of `CameraMeta`. */
  cameraMetasByLeftRoiId: CameraMetasConnection;
  /** Reads and enables pagination through a set of `CameraMeta`. */
  cameraMetasByRightRoiId: CameraMetasConnection;
};


/** Table camera roi from camera */
export type CameraRoiCameraMetasByLeftRoiIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CameraMetasOrderBy>>;
  condition?: Maybe<CameraMetaCondition>;
  filter?: Maybe<CameraMetaFilter>;
};


/** Table camera roi from camera */
export type CameraRoiCameraMetasByRightRoiIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CameraMetasOrderBy>>;
  condition?: Maybe<CameraMetaCondition>;
  filter?: Maybe<CameraMetaFilter>;
};

/**
 * A condition to be used against `CameraRoi` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type CameraRoiCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `xOffset` field. */
  xOffset?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `yOffset` field. */
  yOffset?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `height` field. */
  height?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `width` field. */
  width?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `doRectify` field. */
  doRectify?: Maybe<Scalars['Boolean']>;
};

/** A filter to be used against `CameraRoi` object types. All fields are combined with a logical ‘and.’ */
export type CameraRoiFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `xOffset` field. */
  xOffset?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `yOffset` field. */
  yOffset?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `height` field. */
  height?: Maybe<IntFilter>;
  /** Filter by the object’s `width` field. */
  width?: Maybe<IntFilter>;
  /** Filter by the object’s `doRectify` field. */
  doRectify?: Maybe<BooleanFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<CameraRoiFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<CameraRoiFilter>>;
  /** Negates the expression. */
  not?: Maybe<CameraRoiFilter>;
};

/** A connection to a list of `CameraRoi` values. */
export type CameraRoisConnection = {
  __typename?: 'CameraRoisConnection';
  /** A list of `CameraRoi` objects. */
  nodes: Array<Maybe<CameraRoi>>;
  /** A list of edges which contains the `CameraRoi` and cursor to aid in pagination. */
  edges: Array<CameraRoisEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `CameraRoi` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `CameraRoi` edge in the connection. */
export type CameraRoisEdge = {
  __typename?: 'CameraRoisEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `CameraRoi` at the end of the edge. */
  node?: Maybe<CameraRoi>;
};

/** Methods to use when ordering `CameraRoi`. */
export enum CameraRoisOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  XOffsetAsc = 'X_OFFSET_ASC',
  XOffsetDesc = 'X_OFFSET_DESC',
  YOffsetAsc = 'Y_OFFSET_ASC',
  YOffsetDesc = 'Y_OFFSET_DESC',
  HeightAsc = 'HEIGHT_ASC',
  HeightDesc = 'HEIGHT_DESC',
  WidthAsc = 'WIDTH_ASC',
  WidthDesc = 'WIDTH_DESC',
  DoRectifyAsc = 'DO_RECTIFY_ASC',
  DoRectifyDesc = 'DO_RECTIFY_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/** A connection to a list of `Camera` values. */
export type CamerasConnection = {
  __typename?: 'CamerasConnection';
  /** A list of `Camera` objects. */
  nodes: Array<Maybe<Camera>>;
  /** A list of edges which contains the `Camera` and cursor to aid in pagination. */
  edges: Array<CamerasEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Camera` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `Camera` edge in the connection. */
export type CamerasEdge = {
  __typename?: 'CamerasEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Camera` at the end of the edge. */
  node?: Maybe<Camera>;
};

/** Methods to use when ordering `Camera`. */
export enum CamerasOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  ReadingatAsc = 'READINGAT_ASC',
  ReadingatDesc = 'READINGAT_DESC',
  TopicIdAsc = 'TOPIC_ID_ASC',
  TopicIdDesc = 'TOPIC_ID_DESC',
  MsgIdAsc = 'MSG_ID_ASC',
  MsgIdDesc = 'MSG_ID_DESC',
  VehicleIdAsc = 'VEHICLE_ID_ASC',
  VehicleIdDesc = 'VEHICLE_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/** All input for the create `Alert` mutation. */
export type CreateAlertInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Alert` to be created by this mutation. */
  alert: AlertInput;
};

/** The output of our create `Alert` mutation. */
export type CreateAlertPayload = {
  __typename?: 'CreateAlertPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Alert` that was created by this mutation. */
  alert?: Maybe<Alert>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `AlertType` that is related to this `Alert`. */
  alertType?: Maybe<AlertType>;
  /** Reads a single `VehicleStatus` that is related to this `Alert`. */
  vehicleStatus?: Maybe<VehicleStatus>;
  /** An edge for our `Alert`. May be used by Relay 1. */
  alertEdge?: Maybe<AlertsEdge>;
};


/** The output of our create `Alert` mutation. */
export type CreateAlertPayloadAlertEdgeArgs = {
  orderBy?: Maybe<Array<AlertsOrderBy>>;
};

/** All input for the create `AlertType` mutation. */
export type CreateAlertTypeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `AlertType` to be created by this mutation. */
  alertType: AlertTypeInput;
};

/** The output of our create `AlertType` mutation. */
export type CreateAlertTypePayload = {
  __typename?: 'CreateAlertTypePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `AlertType` that was created by this mutation. */
  alertType?: Maybe<AlertType>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `AlertType`. May be used by Relay 1. */
  alertTypeEdge?: Maybe<AlertTypesEdge>;
};


/** The output of our create `AlertType` mutation. */
export type CreateAlertTypePayloadAlertTypeEdgeArgs = {
  orderBy?: Maybe<Array<AlertTypesOrderBy>>;
};

/** All input for the create `CameraHistogram` mutation. */
export type CreateCameraHistogramInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** The output of our create `CameraHistogram` mutation. */
export type CreateCameraHistogramPayload = {
  __typename?: 'CreateCameraHistogramPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CameraHistogram` that was created by this mutation. */
  cameraHistogram?: Maybe<CameraHistogram>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `FullHistogram` that is related to this `CameraHistogram`. */
  fullHistogram?: Maybe<FullHistogram>;
  /** Reads a single `SmallHistogram` that is related to this `CameraHistogram`. */
  smallHistogram?: Maybe<SmallHistogram>;
  /** An edge for our `CameraHistogram`. May be used by Relay 1. */
  cameraHistogramEdge?: Maybe<CameraHistogramsEdge>;
};


/** The output of our create `CameraHistogram` mutation. */
export type CreateCameraHistogramPayloadCameraHistogramEdgeArgs = {
  orderBy?: Maybe<Array<CameraHistogramsOrderBy>>;
};

/** All input for the create `Camera` mutation. */
export type CreateCameraInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** All input for the create `CameraMessageHeader` mutation. */
export type CreateCameraMessageHeaderInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** The output of our create `CameraMessageHeader` mutation. */
export type CreateCameraMessageHeaderPayload = {
  __typename?: 'CreateCameraMessageHeaderPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CameraMessageHeader` that was created by this mutation. */
  cameraMessageHeader?: Maybe<CameraMessageHeader>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `CameraMessageHeader`. May be used by Relay 1. */
  cameraMessageHeaderEdge?: Maybe<CameraMessageHeadersEdge>;
};


/** The output of our create `CameraMessageHeader` mutation. */
export type CreateCameraMessageHeaderPayloadCameraMessageHeaderEdgeArgs = {
  orderBy?: Maybe<Array<CameraMessageHeadersOrderBy>>;
};

/** All input for the create `CameraMessage` mutation. */
export type CreateCameraMessageInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** The output of our create `CameraMessage` mutation. */
export type CreateCameraMessagePayload = {
  __typename?: 'CreateCameraMessagePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CameraMessage` that was created by this mutation. */
  cameraMessage?: Maybe<CameraMessage>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `CameraMessageHeader` that is related to this `CameraMessage`. */
  header?: Maybe<CameraMessageHeader>;
  /** Reads a single `Image` that is related to this `CameraMessage`. */
  image?: Maybe<Image>;
  /** Reads a single `CameraMeta` that is related to this `CameraMessage`. */
  cameraMeta?: Maybe<CameraMeta>;
  /** An edge for our `CameraMessage`. May be used by Relay 1. */
  cameraMessageEdge?: Maybe<CameraMessagesEdge>;
};


/** The output of our create `CameraMessage` mutation. */
export type CreateCameraMessagePayloadCameraMessageEdgeArgs = {
  orderBy?: Maybe<Array<CameraMessagesOrderBy>>;
};

/** All input for the create `CameraMetaE` mutation. */
export type CreateCameraMetaEInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** The output of our create `CameraMetaE` mutation. */
export type CreateCameraMetaEPayload = {
  __typename?: 'CreateCameraMetaEPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CameraMetaE` that was created by this mutation. */
  cameraMetaE?: Maybe<CameraMetaE>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `CameraMetaE`. May be used by Relay 1. */
  cameraMetaEEdge?: Maybe<CameraMetaEsEdge>;
};


/** The output of our create `CameraMetaE` mutation. */
export type CreateCameraMetaEPayloadCameraMetaEEdgeArgs = {
  orderBy?: Maybe<Array<CameraMetaEsOrderBy>>;
};

/** All input for the create `CameraMetaF` mutation. */
export type CreateCameraMetaFInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** The output of our create `CameraMetaF` mutation. */
export type CreateCameraMetaFPayload = {
  __typename?: 'CreateCameraMetaFPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CameraMetaF` that was created by this mutation. */
  cameraMetaF?: Maybe<CameraMetaF>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `CameraMetaF`. May be used by Relay 1. */
  cameraMetaFEdge?: Maybe<CameraMetaFsEdge>;
};


/** The output of our create `CameraMetaF` mutation. */
export type CreateCameraMetaFPayloadCameraMetaFEdgeArgs = {
  orderBy?: Maybe<Array<CameraMetaFsOrderBy>>;
};

/** All input for the create `CameraMeta` mutation. */
export type CreateCameraMetaInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** All input for the create `CameraMetaP1` mutation. */
export type CreateCameraMetaP1Input = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** The output of our create `CameraMetaP1` mutation. */
export type CreateCameraMetaP1Payload = {
  __typename?: 'CreateCameraMetaP1Payload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CameraMetaP1` that was created by this mutation. */
  cameraMetaP1?: Maybe<CameraMetaP1>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `CameraMetaP1`. May be used by Relay 1. */
  cameraMetaP1Edge?: Maybe<CameraMetaP1sEdge>;
};


/** The output of our create `CameraMetaP1` mutation. */
export type CreateCameraMetaP1PayloadCameraMetaP1EdgeArgs = {
  orderBy?: Maybe<Array<CameraMetaP1sOrderBy>>;
};

/** All input for the create `CameraMetaP2` mutation. */
export type CreateCameraMetaP2Input = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** The output of our create `CameraMetaP2` mutation. */
export type CreateCameraMetaP2Payload = {
  __typename?: 'CreateCameraMetaP2Payload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CameraMetaP2` that was created by this mutation. */
  cameraMetaP2?: Maybe<CameraMetaP2>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `CameraMetaP2`. May be used by Relay 1. */
  cameraMetaP2Edge?: Maybe<CameraMetaP2sEdge>;
};


/** The output of our create `CameraMetaP2` mutation. */
export type CreateCameraMetaP2PayloadCameraMetaP2EdgeArgs = {
  orderBy?: Maybe<Array<CameraMetaP2sOrderBy>>;
};

/** The output of our create `CameraMeta` mutation. */
export type CreateCameraMetaPayload = {
  __typename?: 'CreateCameraMetaPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CameraMeta` that was created by this mutation. */
  cameraMeta?: Maybe<CameraMeta>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `SideIntrinsic` that is related to this `CameraMeta`. */
  leftIntrinsics?: Maybe<SideIntrinsic>;
  /** Reads a single `SideIntrinsic` that is related to this `CameraMeta`. */
  rightIntrinsics?: Maybe<SideIntrinsic>;
  /** Reads a single `StereoExtrinsic` that is related to this `CameraMeta`. */
  stereoExtrinsics?: Maybe<StereoExtrinsic>;
  /** Reads a single `TractorExtrinsic` that is related to this `CameraMeta`. */
  tractorExtrinsics?: Maybe<TractorExtrinsic>;
  /** Reads a single `CameraMetaE` that is related to this `CameraMeta`. */
  e?: Maybe<CameraMetaE>;
  /** Reads a single `CameraMetaF` that is related to this `CameraMeta`. */
  f?: Maybe<CameraMetaF>;
  /** Reads a single `CameraMetaR1` that is related to this `CameraMeta`. */
  r1?: Maybe<CameraMetaR1>;
  /** Reads a single `CameraMetaR2` that is related to this `CameraMeta`. */
  r2?: Maybe<CameraMetaR2>;
  /** Reads a single `CameraMetaP1` that is related to this `CameraMeta`. */
  p1?: Maybe<CameraMetaP1>;
  /** Reads a single `CameraMetaP2` that is related to this `CameraMeta`. */
  p2?: Maybe<CameraMetaP2>;
  /** Reads a single `CameraMetaQ` that is related to this `CameraMeta`. */
  q?: Maybe<CameraMetaQ>;
  /** Reads a single `CameraRoi` that is related to this `CameraMeta`. */
  leftRoi?: Maybe<CameraRoi>;
  /** Reads a single `CameraRoi` that is related to this `CameraMeta`. */
  rightRoi?: Maybe<CameraRoi>;
  /** Reads a single `CameraHistogram` that is related to this `CameraMeta`. */
  leftHistogram?: Maybe<CameraHistogram>;
  /** Reads a single `CameraHistogram` that is related to this `CameraMeta`. */
  rightHistogram?: Maybe<CameraHistogram>;
  /** An edge for our `CameraMeta`. May be used by Relay 1. */
  cameraMetaEdge?: Maybe<CameraMetasEdge>;
};


/** The output of our create `CameraMeta` mutation. */
export type CreateCameraMetaPayloadCameraMetaEdgeArgs = {
  orderBy?: Maybe<Array<CameraMetasOrderBy>>;
};

/** All input for the create `CameraMetaQ` mutation. */
export type CreateCameraMetaQInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** The output of our create `CameraMetaQ` mutation. */
export type CreateCameraMetaQPayload = {
  __typename?: 'CreateCameraMetaQPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CameraMetaQ` that was created by this mutation. */
  cameraMetaQ?: Maybe<CameraMetaQ>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `CameraMetaQ`. May be used by Relay 1. */
  cameraMetaQEdge?: Maybe<CameraMetaQsEdge>;
};


/** The output of our create `CameraMetaQ` mutation. */
export type CreateCameraMetaQPayloadCameraMetaQEdgeArgs = {
  orderBy?: Maybe<Array<CameraMetaQsOrderBy>>;
};

/** All input for the create `CameraMetaR1` mutation. */
export type CreateCameraMetaR1Input = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** The output of our create `CameraMetaR1` mutation. */
export type CreateCameraMetaR1Payload = {
  __typename?: 'CreateCameraMetaR1Payload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CameraMetaR1` that was created by this mutation. */
  cameraMetaR1?: Maybe<CameraMetaR1>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `CameraMetaR1`. May be used by Relay 1. */
  cameraMetaR1Edge?: Maybe<CameraMetaR1sEdge>;
};


/** The output of our create `CameraMetaR1` mutation. */
export type CreateCameraMetaR1PayloadCameraMetaR1EdgeArgs = {
  orderBy?: Maybe<Array<CameraMetaR1sOrderBy>>;
};

/** All input for the create `CameraMetaR2` mutation. */
export type CreateCameraMetaR2Input = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** The output of our create `CameraMetaR2` mutation. */
export type CreateCameraMetaR2Payload = {
  __typename?: 'CreateCameraMetaR2Payload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CameraMetaR2` that was created by this mutation. */
  cameraMetaR2?: Maybe<CameraMetaR2>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `CameraMetaR2`. May be used by Relay 1. */
  cameraMetaR2Edge?: Maybe<CameraMetaR2sEdge>;
};


/** The output of our create `CameraMetaR2` mutation. */
export type CreateCameraMetaR2PayloadCameraMetaR2EdgeArgs = {
  orderBy?: Maybe<Array<CameraMetaR2sOrderBy>>;
};

/** All input for the create `CameraPair` mutation. */
export type CreateCameraPairInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** All input for the create `CameraPairMessage` mutation. */
export type CreateCameraPairMessageInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CameraPairMessage` to be created by this mutation. */
  cameraPairMessage: CameraPairMessageInput;
};

/** The output of our create `CameraPairMessage` mutation. */
export type CreateCameraPairMessagePayload = {
  __typename?: 'CreateCameraPairMessagePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CameraPairMessage` that was created by this mutation. */
  cameraPairMessage?: Maybe<CameraPairMessage>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `CameraMessageHeader` that is related to this `CameraPairMessage`. */
  header?: Maybe<CameraMessageHeader>;
  /** Reads a single `Image` that is related to this `CameraPairMessage`. */
  leftImage?: Maybe<Image>;
  /** Reads a single `Image` that is related to this `CameraPairMessage`. */
  rightImage?: Maybe<Image>;
  /** Reads a single `CameraMeta` that is related to this `CameraPairMessage`. */
  cameraMeta?: Maybe<CameraMeta>;
  /** An edge for our `CameraPairMessage`. May be used by Relay 1. */
  cameraPairMessageEdge?: Maybe<CameraPairMessagesEdge>;
};


/** The output of our create `CameraPairMessage` mutation. */
export type CreateCameraPairMessagePayloadCameraPairMessageEdgeArgs = {
  orderBy?: Maybe<Array<CameraPairMessagesOrderBy>>;
};

/** The output of our create `CameraPair` mutation. */
export type CreateCameraPairPayload = {
  __typename?: 'CreateCameraPairPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CameraPair` that was created by this mutation. */
  cameraPair?: Maybe<CameraPair>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Topic` that is related to this `CameraPair`. */
  topic?: Maybe<Topic>;
  /** Reads a single `CameraPairMessage` that is related to this `CameraPair`. */
  msg?: Maybe<CameraPairMessage>;
  /** Reads a single `TopicType` that is related to this `CameraPair`. */
  topicType?: Maybe<TopicType>;
  /** Reads a single `Vehicle` that is related to this `CameraPair`. */
  vehicle?: Maybe<Vehicle>;
  /** An edge for our `CameraPair`. May be used by Relay 1. */
  cameraPairEdge?: Maybe<CameraPairsEdge>;
};


/** The output of our create `CameraPair` mutation. */
export type CreateCameraPairPayloadCameraPairEdgeArgs = {
  orderBy?: Maybe<Array<CameraPairsOrderBy>>;
};

/** The output of our create `Camera` mutation. */
export type CreateCameraPayload = {
  __typename?: 'CreateCameraPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Camera` that was created by this mutation. */
  camera?: Maybe<Camera>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Topic` that is related to this `Camera`. */
  topic?: Maybe<Topic>;
  /** Reads a single `CameraMessage` that is related to this `Camera`. */
  msg?: Maybe<CameraMessage>;
  /** Reads a single `Vehicle` that is related to this `Camera`. */
  vehicle?: Maybe<Vehicle>;
  /** An edge for our `Camera`. May be used by Relay 1. */
  cameraEdge?: Maybe<CamerasEdge>;
};


/** The output of our create `Camera` mutation. */
export type CreateCameraPayloadCameraEdgeArgs = {
  orderBy?: Maybe<Array<CamerasOrderBy>>;
};

/** All input for the create `CameraRoi` mutation. */
export type CreateCameraRoiInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** The output of our create `CameraRoi` mutation. */
export type CreateCameraRoiPayload = {
  __typename?: 'CreateCameraRoiPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CameraRoi` that was created by this mutation. */
  cameraRoi?: Maybe<CameraRoi>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `CameraRoi`. May be used by Relay 1. */
  cameraRoiEdge?: Maybe<CameraRoisEdge>;
};


/** The output of our create `CameraRoi` mutation. */
export type CreateCameraRoiPayloadCameraRoiEdgeArgs = {
  orderBy?: Maybe<Array<CameraRoisOrderBy>>;
};

/** All input for the create `FullHistogram` mutation. */
export type CreateFullHistogramInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** The output of our create `FullHistogram` mutation. */
export type CreateFullHistogramPayload = {
  __typename?: 'CreateFullHistogramPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `FullHistogram` that was created by this mutation. */
  fullHistogram?: Maybe<FullHistogram>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `FullHistogram`. May be used by Relay 1. */
  fullHistogramEdge?: Maybe<FullHistogramsEdge>;
};


/** The output of our create `FullHistogram` mutation. */
export type CreateFullHistogramPayloadFullHistogramEdgeArgs = {
  orderBy?: Maybe<Array<FullHistogramsOrderBy>>;
};

/** All input for the create `ImageDatum` mutation. */
export type CreateImageDatumInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** The output of our create `ImageDatum` mutation. */
export type CreateImageDatumPayload = {
  __typename?: 'CreateImageDatumPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ImageDatum` that was created by this mutation. */
  imageDatum?: Maybe<ImageDatum>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `ImageDatum`. May be used by Relay 1. */
  imageDatumEdge?: Maybe<ImageDataEdge>;
};


/** The output of our create `ImageDatum` mutation. */
export type CreateImageDatumPayloadImageDatumEdgeArgs = {
  orderBy?: Maybe<Array<ImageDataOrderBy>>;
};

/** All input for the create `ImageHeader` mutation. */
export type CreateImageHeaderInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** The output of our create `ImageHeader` mutation. */
export type CreateImageHeaderPayload = {
  __typename?: 'CreateImageHeaderPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ImageHeader` that was created by this mutation. */
  imageHeader?: Maybe<ImageHeader>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `ImageHeaderStamp` that is related to this `ImageHeader`. */
  stamp?: Maybe<ImageHeaderStamp>;
  /** An edge for our `ImageHeader`. May be used by Relay 1. */
  imageHeaderEdge?: Maybe<ImageHeadersEdge>;
};


/** The output of our create `ImageHeader` mutation. */
export type CreateImageHeaderPayloadImageHeaderEdgeArgs = {
  orderBy?: Maybe<Array<ImageHeadersOrderBy>>;
};

/** All input for the create `ImageHeaderStamp` mutation. */
export type CreateImageHeaderStampInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** The output of our create `ImageHeaderStamp` mutation. */
export type CreateImageHeaderStampPayload = {
  __typename?: 'CreateImageHeaderStampPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ImageHeaderStamp` that was created by this mutation. */
  imageHeaderStamp?: Maybe<ImageHeaderStamp>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `ImageHeaderStamp`. May be used by Relay 1. */
  imageHeaderStampEdge?: Maybe<ImageHeaderStampsEdge>;
};


/** The output of our create `ImageHeaderStamp` mutation. */
export type CreateImageHeaderStampPayloadImageHeaderStampEdgeArgs = {
  orderBy?: Maybe<Array<ImageHeaderStampsOrderBy>>;
};

/** All input for the create `Image` mutation. */
export type CreateImageInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** The output of our create `Image` mutation. */
export type CreateImagePayload = {
  __typename?: 'CreateImagePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Image` that was created by this mutation. */
  image?: Maybe<Image>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `ImageHeader` that is related to this `Image`. */
  header?: Maybe<ImageHeader>;
  /** Reads a single `ImageDatum` that is related to this `Image`. */
  data?: Maybe<ImageDatum>;
  /** An edge for our `Image`. May be used by Relay 1. */
  imageEdge?: Maybe<ImagesEdge>;
};


/** The output of our create `Image` mutation. */
export type CreateImagePayloadImageEdgeArgs = {
  orderBy?: Maybe<Array<ImagesOrderBy>>;
};

/** All input for the create `Object` mutation. */
export type CreateObjectInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Object` to be created by this mutation. */
  object: ObjectInput;
};

/** All input for the create `ObjectMessageCentroidLocation` mutation. */
export type CreateObjectMessageCentroidLocationInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** The output of our create `ObjectMessageCentroidLocation` mutation. */
export type CreateObjectMessageCentroidLocationPayload = {
  __typename?: 'CreateObjectMessageCentroidLocationPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ObjectMessageCentroidLocation` that was created by this mutation. */
  objectMessageCentroidLocation?: Maybe<ObjectMessageCentroidLocation>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `ObjectMessageXyzCamera` that is related to this `ObjectMessageCentroidLocation`. */
  xyzCamera?: Maybe<ObjectMessageXyzCamera>;
  /** Reads a single `ObjectMessageXyzStarfire` that is related to this `ObjectMessageCentroidLocation`. */
  xyzStarfire?: Maybe<ObjectMessageXyzStarfire>;
  /** Reads a single `ObjectMessageLla` that is related to this `ObjectMessageCentroidLocation`. */
  lla?: Maybe<ObjectMessageLla>;
  /** Reads a single `ObjectMessageEnu` that is related to this `ObjectMessageCentroidLocation`. */
  enu?: Maybe<ObjectMessageEnu>;
  /** Reads a single `ObjectMessageFieldOrigin` that is related to this `ObjectMessageCentroidLocation`. */
  fieldOrigin?: Maybe<ObjectMessageFieldOrigin>;
  /** Reads a single `ObjectMessageEcef` that is related to this `ObjectMessageCentroidLocation`. */
  ecef?: Maybe<ObjectMessageEcef>;
  /** An edge for our `ObjectMessageCentroidLocation`. May be used by Relay 1. */
  objectMessageCentroidLocationEdge?: Maybe<ObjectMessageCentroidLocationsEdge>;
};


/** The output of our create `ObjectMessageCentroidLocation` mutation. */
export type CreateObjectMessageCentroidLocationPayloadObjectMessageCentroidLocationEdgeArgs = {
  orderBy?: Maybe<Array<ObjectMessageCentroidLocationsOrderBy>>;
};

/** All input for the create `ObjectMessageCentroidRpy` mutation. */
export type CreateObjectMessageCentroidRpyInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** The output of our create `ObjectMessageCentroidRpy` mutation. */
export type CreateObjectMessageCentroidRpyPayload = {
  __typename?: 'CreateObjectMessageCentroidRpyPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ObjectMessageCentroidRpy` that was created by this mutation. */
  objectMessageCentroidRpy?: Maybe<ObjectMessageCentroidRpy>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `ObjectMessageCentroidRpy`. May be used by Relay 1. */
  objectMessageCentroidRpyEdge?: Maybe<ObjectMessageCentroidRpiesEdge>;
};


/** The output of our create `ObjectMessageCentroidRpy` mutation. */
export type CreateObjectMessageCentroidRpyPayloadObjectMessageCentroidRpyEdgeArgs = {
  orderBy?: Maybe<Array<ObjectMessageCentroidRpiesOrderBy>>;
};

/** All input for the create `ObjectMessageCircleCenter` mutation. */
export type CreateObjectMessageCircleCenterInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** The output of our create `ObjectMessageCircleCenter` mutation. */
export type CreateObjectMessageCircleCenterPayload = {
  __typename?: 'CreateObjectMessageCircleCenterPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ObjectMessageCircleCenter` that was created by this mutation. */
  objectMessageCircleCenter?: Maybe<ObjectMessageCircleCenter>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `ObjectMessageXyzCamera` that is related to this `ObjectMessageCircleCenter`. */
  xyzCamera?: Maybe<ObjectMessageXyzCamera>;
  /** Reads a single `ObjectMessageXyzStarfire` that is related to this `ObjectMessageCircleCenter`. */
  xyzStarfire?: Maybe<ObjectMessageXyzStarfire>;
  /** Reads a single `ObjectMessageLla` that is related to this `ObjectMessageCircleCenter`. */
  lla?: Maybe<ObjectMessageLla>;
  /** Reads a single `ObjectMessageEnu` that is related to this `ObjectMessageCircleCenter`. */
  enu?: Maybe<ObjectMessageEnu>;
  /** Reads a single `ObjectMessageFieldOrigin` that is related to this `ObjectMessageCircleCenter`. */
  fieldOrigin?: Maybe<ObjectMessageFieldOrigin>;
  /** Reads a single `ObjectMessageEcef` that is related to this `ObjectMessageCircleCenter`. */
  ecef?: Maybe<ObjectMessageEcef>;
  /** An edge for our `ObjectMessageCircleCenter`. May be used by Relay 1. */
  objectMessageCircleCenterEdge?: Maybe<ObjectMessageCircleCentersEdge>;
};


/** The output of our create `ObjectMessageCircleCenter` mutation. */
export type CreateObjectMessageCircleCenterPayloadObjectMessageCircleCenterEdgeArgs = {
  orderBy?: Maybe<Array<ObjectMessageCircleCentersOrderBy>>;
};

/** All input for the create `ObjectMessageDetectionCuboidCentroid` mutation. */
export type CreateObjectMessageDetectionCuboidCentroidInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** The output of our create `ObjectMessageDetectionCuboidCentroid` mutation. */
export type CreateObjectMessageDetectionCuboidCentroidPayload = {
  __typename?: 'CreateObjectMessageDetectionCuboidCentroidPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ObjectMessageDetectionCuboidCentroid` that was created by this mutation. */
  objectMessageDetectionCuboidCentroid?: Maybe<ObjectMessageDetectionCuboidCentroid>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `ObjectMessageDetectionCuboidCentroid`. May be used by Relay 1. */
  objectMessageDetectionCuboidCentroidEdge?: Maybe<ObjectMessageDetectionCuboidCentroidsEdge>;
};


/** The output of our create `ObjectMessageDetectionCuboidCentroid` mutation. */
export type CreateObjectMessageDetectionCuboidCentroidPayloadObjectMessageDetectionCuboidCentroidEdgeArgs = {
  orderBy?: Maybe<Array<ObjectMessageDetectionCuboidCentroidsOrderBy>>;
};

/** All input for the create `ObjectMessageDetectionCuboidDimension` mutation. */
export type CreateObjectMessageDetectionCuboidDimensionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** The output of our create `ObjectMessageDetectionCuboidDimension` mutation. */
export type CreateObjectMessageDetectionCuboidDimensionPayload = {
  __typename?: 'CreateObjectMessageDetectionCuboidDimensionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ObjectMessageDetectionCuboidDimension` that was created by this mutation. */
  objectMessageDetectionCuboidDimension?: Maybe<ObjectMessageDetectionCuboidDimension>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `ObjectMessageDetectionCuboidDimension`. May be used by Relay 1. */
  objectMessageDetectionCuboidDimensionEdge?: Maybe<ObjectMessageDetectionCuboidDimensionsEdge>;
};


/** The output of our create `ObjectMessageDetectionCuboidDimension` mutation. */
export type CreateObjectMessageDetectionCuboidDimensionPayloadObjectMessageDetectionCuboidDimensionEdgeArgs = {
  orderBy?: Maybe<Array<ObjectMessageDetectionCuboidDimensionsOrderBy>>;
};

/** All input for the create `ObjectMessageDetectionCuboid` mutation. */
export type CreateObjectMessageDetectionCuboidInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** All input for the create `ObjectMessageDetectionCuboidOrientation` mutation. */
export type CreateObjectMessageDetectionCuboidOrientationInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** The output of our create `ObjectMessageDetectionCuboidOrientation` mutation. */
export type CreateObjectMessageDetectionCuboidOrientationPayload = {
  __typename?: 'CreateObjectMessageDetectionCuboidOrientationPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ObjectMessageDetectionCuboidOrientation` that was created by this mutation. */
  objectMessageDetectionCuboidOrientation?: Maybe<ObjectMessageDetectionCuboidOrientation>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `ObjectMessageDetectionCuboidOrientation`. May be used by Relay 1. */
  objectMessageDetectionCuboidOrientationEdge?: Maybe<ObjectMessageDetectionCuboidOrientationsEdge>;
};


/** The output of our create `ObjectMessageDetectionCuboidOrientation` mutation. */
export type CreateObjectMessageDetectionCuboidOrientationPayloadObjectMessageDetectionCuboidOrientationEdgeArgs = {
  orderBy?: Maybe<Array<ObjectMessageDetectionCuboidOrientationsOrderBy>>;
};

/** The output of our create `ObjectMessageDetectionCuboid` mutation. */
export type CreateObjectMessageDetectionCuboidPayload = {
  __typename?: 'CreateObjectMessageDetectionCuboidPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ObjectMessageDetectionCuboid` that was created by this mutation. */
  objectMessageDetectionCuboid?: Maybe<ObjectMessageDetectionCuboid>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `ObjectMessageDetectionCuboidCentroid` that is related to this `ObjectMessageDetectionCuboid`. */
  centroid?: Maybe<ObjectMessageDetectionCuboidCentroid>;
  /** Reads a single `ObjectMessageDetectionCuboidDimension` that is related to this `ObjectMessageDetectionCuboid`. */
  dimension?: Maybe<ObjectMessageDetectionCuboidDimension>;
  /** Reads a single `ObjectMessageDetectionCuboidOrientation` that is related to this `ObjectMessageDetectionCuboid`. */
  orientation?: Maybe<ObjectMessageDetectionCuboidOrientation>;
  /** An edge for our `ObjectMessageDetectionCuboid`. May be used by Relay 1. */
  objectMessageDetectionCuboidEdge?: Maybe<ObjectMessageDetectionCuboidsEdge>;
};


/** The output of our create `ObjectMessageDetectionCuboid` mutation. */
export type CreateObjectMessageDetectionCuboidPayloadObjectMessageDetectionCuboidEdgeArgs = {
  orderBy?: Maybe<Array<ObjectMessageDetectionCuboidsOrderBy>>;
};

/** All input for the create `ObjectMessageDetectionHeader` mutation. */
export type CreateObjectMessageDetectionHeaderInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** The output of our create `ObjectMessageDetectionHeader` mutation. */
export type CreateObjectMessageDetectionHeaderPayload = {
  __typename?: 'CreateObjectMessageDetectionHeaderPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ObjectMessageDetectionHeader` that was created by this mutation. */
  objectMessageDetectionHeader?: Maybe<ObjectMessageDetectionHeader>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `ObjectMessageDetectionHeader`. May be used by Relay 1. */
  objectMessageDetectionHeaderEdge?: Maybe<ObjectMessageDetectionHeadersEdge>;
};


/** The output of our create `ObjectMessageDetectionHeader` mutation. */
export type CreateObjectMessageDetectionHeaderPayloadObjectMessageDetectionHeaderEdgeArgs = {
  orderBy?: Maybe<Array<ObjectMessageDetectionHeadersOrderBy>>;
};

/** All input for the create `ObjectMessageDetection` mutation. */
export type CreateObjectMessageDetectionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** The output of our create `ObjectMessageDetection` mutation. */
export type CreateObjectMessageDetectionPayload = {
  __typename?: 'CreateObjectMessageDetectionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ObjectMessageDetection` that was created by this mutation. */
  objectMessageDetection?: Maybe<ObjectMessageDetection>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `ObjectMessageDetectionHeader` that is related to this `ObjectMessageDetection`. */
  header?: Maybe<ObjectMessageDetectionHeader>;
  /** Reads a single `ObjectMessageDetectionCuboid` that is related to this `ObjectMessageDetection`. */
  cuboid?: Maybe<ObjectMessageDetectionCuboid>;
  /** Reads a single `ObjectMessageDetectionRoi` that is related to this `ObjectMessageDetection`. */
  roi?: Maybe<ObjectMessageDetectionRoi>;
  /** An edge for our `ObjectMessageDetection`. May be used by Relay 1. */
  objectMessageDetectionEdge?: Maybe<ObjectMessageDetectionsEdge>;
};


/** The output of our create `ObjectMessageDetection` mutation. */
export type CreateObjectMessageDetectionPayloadObjectMessageDetectionEdgeArgs = {
  orderBy?: Maybe<Array<ObjectMessageDetectionsOrderBy>>;
};

/** All input for the create `ObjectMessageDetectionRoi` mutation. */
export type CreateObjectMessageDetectionRoiInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** The output of our create `ObjectMessageDetectionRoi` mutation. */
export type CreateObjectMessageDetectionRoiPayload = {
  __typename?: 'CreateObjectMessageDetectionRoiPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ObjectMessageDetectionRoi` that was created by this mutation. */
  objectMessageDetectionRoi?: Maybe<ObjectMessageDetectionRoi>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `ObjectMessageDetectionRoi`. May be used by Relay 1. */
  objectMessageDetectionRoiEdge?: Maybe<ObjectMessageDetectionRoisEdge>;
};


/** The output of our create `ObjectMessageDetectionRoi` mutation. */
export type CreateObjectMessageDetectionRoiPayloadObjectMessageDetectionRoiEdgeArgs = {
  orderBy?: Maybe<Array<ObjectMessageDetectionRoisOrderBy>>;
};

/** All input for the create `ObjectMessageEcef` mutation. */
export type CreateObjectMessageEcefInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** The output of our create `ObjectMessageEcef` mutation. */
export type CreateObjectMessageEcefPayload = {
  __typename?: 'CreateObjectMessageEcefPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ObjectMessageEcef` that was created by this mutation. */
  objectMessageEcef?: Maybe<ObjectMessageEcef>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `ObjectMessageEcef`. May be used by Relay 1. */
  objectMessageEcefEdge?: Maybe<ObjectMessageEcefsEdge>;
};


/** The output of our create `ObjectMessageEcef` mutation. */
export type CreateObjectMessageEcefPayloadObjectMessageEcefEdgeArgs = {
  orderBy?: Maybe<Array<ObjectMessageEcefsOrderBy>>;
};

/** All input for the create `ObjectMessageEnu` mutation. */
export type CreateObjectMessageEnuInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** The output of our create `ObjectMessageEnu` mutation. */
export type CreateObjectMessageEnuPayload = {
  __typename?: 'CreateObjectMessageEnuPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ObjectMessageEnu` that was created by this mutation. */
  objectMessageEnu?: Maybe<ObjectMessageEnu>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `ObjectMessageEnu`. May be used by Relay 1. */
  objectMessageEnuEdge?: Maybe<ObjectMessageEnusEdge>;
};


/** The output of our create `ObjectMessageEnu` mutation. */
export type CreateObjectMessageEnuPayloadObjectMessageEnuEdgeArgs = {
  orderBy?: Maybe<Array<ObjectMessageEnusOrderBy>>;
};

/** All input for the create `ObjectMessageFieldOrigin` mutation. */
export type CreateObjectMessageFieldOriginInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ObjectMessageFieldOrigin` to be created by this mutation. */
  objectMessageFieldOrigin: ObjectMessageFieldOriginInput;
};

/** The output of our create `ObjectMessageFieldOrigin` mutation. */
export type CreateObjectMessageFieldOriginPayload = {
  __typename?: 'CreateObjectMessageFieldOriginPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ObjectMessageFieldOrigin` that was created by this mutation. */
  objectMessageFieldOrigin?: Maybe<ObjectMessageFieldOrigin>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `ObjectMessageFieldOrigin`. May be used by Relay 1. */
  objectMessageFieldOriginEdge?: Maybe<ObjectMessageFieldOriginsEdge>;
};


/** The output of our create `ObjectMessageFieldOrigin` mutation. */
export type CreateObjectMessageFieldOriginPayloadObjectMessageFieldOriginEdgeArgs = {
  orderBy?: Maybe<Array<ObjectMessageFieldOriginsOrderBy>>;
};

/** All input for the create `ObjectMessageHeader` mutation. */
export type CreateObjectMessageHeaderInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ObjectMessageHeader` to be created by this mutation. */
  objectMessageHeader: ObjectMessageHeaderInput;
};

/** The output of our create `ObjectMessageHeader` mutation. */
export type CreateObjectMessageHeaderPayload = {
  __typename?: 'CreateObjectMessageHeaderPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ObjectMessageHeader` that was created by this mutation. */
  objectMessageHeader?: Maybe<ObjectMessageHeader>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `ObjectMessageHeader`. May be used by Relay 1. */
  objectMessageHeaderEdge?: Maybe<ObjectMessageHeadersEdge>;
};


/** The output of our create `ObjectMessageHeader` mutation. */
export type CreateObjectMessageHeaderPayloadObjectMessageHeaderEdgeArgs = {
  orderBy?: Maybe<Array<ObjectMessageHeadersOrderBy>>;
};

/** All input for the create `ObjectMessage` mutation. */
export type CreateObjectMessageInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** All input for the create `ObjectMessageLla` mutation. */
export type CreateObjectMessageLlaInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** The output of our create `ObjectMessageLla` mutation. */
export type CreateObjectMessageLlaPayload = {
  __typename?: 'CreateObjectMessageLlaPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ObjectMessageLla` that was created by this mutation. */
  objectMessageLla?: Maybe<ObjectMessageLla>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `ObjectMessageLla`. May be used by Relay 1. */
  objectMessageLlaEdge?: Maybe<ObjectMessageLlasEdge>;
};


/** The output of our create `ObjectMessageLla` mutation. */
export type CreateObjectMessageLlaPayloadObjectMessageLlaEdgeArgs = {
  orderBy?: Maybe<Array<ObjectMessageLlasOrderBy>>;
};

/** The output of our create `ObjectMessage` mutation. */
export type CreateObjectMessagePayload = {
  __typename?: 'CreateObjectMessagePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ObjectMessage` that was created by this mutation. */
  objectMessage?: Maybe<ObjectMessage>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `ObjectMessageHeader` that is related to this `ObjectMessage`. */
  header?: Maybe<ObjectMessageHeader>;
  /** Reads a single `ObjectMessageDetection` that is related to this `ObjectMessage`. */
  detection?: Maybe<ObjectMessageDetection>;
  /** Reads a single `ObjectMessageCentroidRpy` that is related to this `ObjectMessage`. */
  centroidRpy?: Maybe<ObjectMessageCentroidRpy>;
  /** Reads a single `ObjectMessageCentroidLocation` that is related to this `ObjectMessage`. */
  centroidLocation?: Maybe<ObjectMessageCentroidLocation>;
  /** Reads a single `ObjectMessageCircleCenter` that is related to this `ObjectMessage`. */
  circleCenter?: Maybe<ObjectMessageCircleCenter>;
  /** An edge for our `ObjectMessage`. May be used by Relay 1. */
  objectMessageEdge?: Maybe<ObjectMessagesEdge>;
};


/** The output of our create `ObjectMessage` mutation. */
export type CreateObjectMessagePayloadObjectMessageEdgeArgs = {
  orderBy?: Maybe<Array<ObjectMessagesOrderBy>>;
};

/** All input for the create `ObjectMessageVertex` mutation. */
export type CreateObjectMessageVertexInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** The output of our create `ObjectMessageVertex` mutation. */
export type CreateObjectMessageVertexPayload = {
  __typename?: 'CreateObjectMessageVertexPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ObjectMessageVertex` that was created by this mutation. */
  objectMessageVertex?: Maybe<ObjectMessageVertex>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `ObjectMessage` that is related to this `ObjectMessageVertex`. */
  objectMessage?: Maybe<ObjectMessage>;
  /** Reads a single `ObjectMessageXyzCamera` that is related to this `ObjectMessageVertex`. */
  xyzCamera?: Maybe<ObjectMessageXyzCamera>;
  /** Reads a single `ObjectMessageXyzStarfire` that is related to this `ObjectMessageVertex`. */
  xyzStarfire?: Maybe<ObjectMessageXyzStarfire>;
  /** Reads a single `ObjectMessageLla` that is related to this `ObjectMessageVertex`. */
  lla?: Maybe<ObjectMessageLla>;
  /** Reads a single `ObjectMessageEnu` that is related to this `ObjectMessageVertex`. */
  enu?: Maybe<ObjectMessageEnu>;
  /** Reads a single `ObjectMessageFieldOrigin` that is related to this `ObjectMessageVertex`. */
  fieldOrigin?: Maybe<ObjectMessageFieldOrigin>;
  /** Reads a single `ObjectMessageEcef` that is related to this `ObjectMessageVertex`. */
  ecef?: Maybe<ObjectMessageEcef>;
  /** An edge for our `ObjectMessageVertex`. May be used by Relay 1. */
  objectMessageVertexEdge?: Maybe<ObjectMessageVerticesEdge>;
};


/** The output of our create `ObjectMessageVertex` mutation. */
export type CreateObjectMessageVertexPayloadObjectMessageVertexEdgeArgs = {
  orderBy?: Maybe<Array<ObjectMessageVerticesOrderBy>>;
};

/** All input for the create `ObjectMessageXyzCamera` mutation. */
export type CreateObjectMessageXyzCameraInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** The output of our create `ObjectMessageXyzCamera` mutation. */
export type CreateObjectMessageXyzCameraPayload = {
  __typename?: 'CreateObjectMessageXyzCameraPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ObjectMessageXyzCamera` that was created by this mutation. */
  objectMessageXyzCamera?: Maybe<ObjectMessageXyzCamera>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `ObjectMessageXyzCamera`. May be used by Relay 1. */
  objectMessageXyzCameraEdge?: Maybe<ObjectMessageXyzCamerasEdge>;
};


/** The output of our create `ObjectMessageXyzCamera` mutation. */
export type CreateObjectMessageXyzCameraPayloadObjectMessageXyzCameraEdgeArgs = {
  orderBy?: Maybe<Array<ObjectMessageXyzCamerasOrderBy>>;
};

/** All input for the create `ObjectMessageXyzStarfire` mutation. */
export type CreateObjectMessageXyzStarfireInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** The output of our create `ObjectMessageXyzStarfire` mutation. */
export type CreateObjectMessageXyzStarfirePayload = {
  __typename?: 'CreateObjectMessageXyzStarfirePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ObjectMessageXyzStarfire` that was created by this mutation. */
  objectMessageXyzStarfire?: Maybe<ObjectMessageXyzStarfire>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `ObjectMessageXyzStarfire`. May be used by Relay 1. */
  objectMessageXyzStarfireEdge?: Maybe<ObjectMessageXyzStarfiresEdge>;
};


/** The output of our create `ObjectMessageXyzStarfire` mutation. */
export type CreateObjectMessageXyzStarfirePayloadObjectMessageXyzStarfireEdgeArgs = {
  orderBy?: Maybe<Array<ObjectMessageXyzStarfiresOrderBy>>;
};

/** The output of our create `Object` mutation. */
export type CreateObjectPayload = {
  __typename?: 'CreateObjectPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Object` that was created by this mutation. */
  object?: Maybe<Object>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Vehicle` that is related to this `Object`. */
  vehicle?: Maybe<Vehicle>;
  /** Reads a single `Topic` that is related to this `Object`. */
  topic?: Maybe<Topic>;
  /** Reads a single `ObjectMessage` that is related to this `Object`. */
  message?: Maybe<ObjectMessage>;
  /** An edge for our `Object`. May be used by Relay 1. */
  objectEdge?: Maybe<ObjectsEdge>;
};


/** The output of our create `Object` mutation. */
export type CreateObjectPayloadObjectEdgeArgs = {
  orderBy?: Maybe<Array<ObjectsOrderBy>>;
};

/** All input for the create `SegmentationMap` mutation. */
export type CreateSegmentationMapInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** The output of our create `SegmentationMap` mutation. */
export type CreateSegmentationMapPayload = {
  __typename?: 'CreateSegmentationMapPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `SegmentationMap` that was created by this mutation. */
  segmentationMap?: Maybe<SegmentationMap>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Topic` that is related to this `SegmentationMap`. */
  topic?: Maybe<Topic>;
  /** Reads a single `CameraMessage` that is related to this `SegmentationMap`. */
  msg?: Maybe<CameraMessage>;
  /** Reads a single `Vehicle` that is related to this `SegmentationMap`. */
  vehicle?: Maybe<Vehicle>;
  /** An edge for our `SegmentationMap`. May be used by Relay 1. */
  segmentationMapEdge?: Maybe<SegmentationMapsEdge>;
};


/** The output of our create `SegmentationMap` mutation. */
export type CreateSegmentationMapPayloadSegmentationMapEdgeArgs = {
  orderBy?: Maybe<Array<SegmentationMapsOrderBy>>;
};

/** All input for the create `SideIntrinsic` mutation. */
export type CreateSideIntrinsicInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** The output of our create `SideIntrinsic` mutation. */
export type CreateSideIntrinsicPayload = {
  __typename?: 'CreateSideIntrinsicPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `SideIntrinsic` that was created by this mutation. */
  sideIntrinsic?: Maybe<SideIntrinsic>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `SideIntrinsicsK` that is related to this `SideIntrinsic`. */
  k?: Maybe<SideIntrinsicsK>;
  /** Reads a single `SideIntrinsicsD` that is related to this `SideIntrinsic`. */
  d?: Maybe<SideIntrinsicsD>;
  /** An edge for our `SideIntrinsic`. May be used by Relay 1. */
  sideIntrinsicEdge?: Maybe<SideIntrinsicsEdge>;
};


/** The output of our create `SideIntrinsic` mutation. */
export type CreateSideIntrinsicPayloadSideIntrinsicEdgeArgs = {
  orderBy?: Maybe<Array<SideIntrinsicsOrderBy>>;
};

/** All input for the create `SideIntrinsicsD` mutation. */
export type CreateSideIntrinsicsDInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `SideIntrinsicsD` to be created by this mutation. */
  sideIntrinsicsD: SideIntrinsicsDInput;
};

/** The output of our create `SideIntrinsicsD` mutation. */
export type CreateSideIntrinsicsDPayload = {
  __typename?: 'CreateSideIntrinsicsDPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `SideIntrinsicsD` that was created by this mutation. */
  sideIntrinsicsD?: Maybe<SideIntrinsicsD>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `SideIntrinsicsD`. May be used by Relay 1. */
  sideIntrinsicsDEdge?: Maybe<SideIntrinsicsDsEdge>;
};


/** The output of our create `SideIntrinsicsD` mutation. */
export type CreateSideIntrinsicsDPayloadSideIntrinsicsDEdgeArgs = {
  orderBy?: Maybe<Array<SideIntrinsicsDsOrderBy>>;
};

/** All input for the create `SideIntrinsicsK` mutation. */
export type CreateSideIntrinsicsKInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `SideIntrinsicsK` to be created by this mutation. */
  sideIntrinsicsK: SideIntrinsicsKInput;
};

/** The output of our create `SideIntrinsicsK` mutation. */
export type CreateSideIntrinsicsKPayload = {
  __typename?: 'CreateSideIntrinsicsKPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `SideIntrinsicsK` that was created by this mutation. */
  sideIntrinsicsK?: Maybe<SideIntrinsicsK>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `SideIntrinsicsK`. May be used by Relay 1. */
  sideIntrinsicsKEdge?: Maybe<SideIntrinsicsKsEdge>;
};


/** The output of our create `SideIntrinsicsK` mutation. */
export type CreateSideIntrinsicsKPayloadSideIntrinsicsKEdgeArgs = {
  orderBy?: Maybe<Array<SideIntrinsicsKsOrderBy>>;
};

/** All input for the create `SmallHistogram` mutation. */
export type CreateSmallHistogramInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** The output of our create `SmallHistogram` mutation. */
export type CreateSmallHistogramPayload = {
  __typename?: 'CreateSmallHistogramPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `SmallHistogram` that was created by this mutation. */
  smallHistogram?: Maybe<SmallHistogram>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `SmallHistogram`. May be used by Relay 1. */
  smallHistogramEdge?: Maybe<SmallHistogramsEdge>;
};


/** The output of our create `SmallHistogram` mutation. */
export type CreateSmallHistogramPayloadSmallHistogramEdgeArgs = {
  orderBy?: Maybe<Array<SmallHistogramsOrderBy>>;
};

/** All input for the create `StarfireHeader` mutation. */
export type CreateStarfireHeaderInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `StarfireHeader` to be created by this mutation. */
  starfireHeader: StarfireHeaderInput;
};

/** The output of our create `StarfireHeader` mutation. */
export type CreateStarfireHeaderPayload = {
  __typename?: 'CreateStarfireHeaderPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `StarfireHeader` that was created by this mutation. */
  starfireHeader?: Maybe<StarfireHeader>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `StarfireHeader`. May be used by Relay 1. */
  starfireHeaderEdge?: Maybe<StarfireHeadersEdge>;
};


/** The output of our create `StarfireHeader` mutation. */
export type CreateStarfireHeaderPayloadStarfireHeaderEdgeArgs = {
  orderBy?: Maybe<Array<StarfireHeadersOrderBy>>;
};

/** All input for the create `Starfire` mutation. */
export type CreateStarfireInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Starfire` to be created by this mutation. */
  starfire: StarfireInput;
};

/** All input for the create `StarfireMessage` mutation. */
export type CreateStarfireMessageInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `StarfireMessage` to be created by this mutation. */
  starfireMessage: StarfireMessageInput;
};

/** The output of our create `StarfireMessage` mutation. */
export type CreateStarfireMessagePayload = {
  __typename?: 'CreateStarfireMessagePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `StarfireMessage` that was created by this mutation. */
  starfireMessage?: Maybe<StarfireMessage>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `StarfireHeader` that is related to this `StarfireMessage`. */
  header?: Maybe<StarfireHeader>;
  /** An edge for our `StarfireMessage`. May be used by Relay 1. */
  starfireMessageEdge?: Maybe<StarfireMessagesEdge>;
};


/** The output of our create `StarfireMessage` mutation. */
export type CreateStarfireMessagePayloadStarfireMessageEdgeArgs = {
  orderBy?: Maybe<Array<StarfireMessagesOrderBy>>;
};

/** The output of our create `Starfire` mutation. */
export type CreateStarfirePayload = {
  __typename?: 'CreateStarfirePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Starfire` that was created by this mutation. */
  starfire?: Maybe<Starfire>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Topic` that is related to this `Starfire`. */
  topic?: Maybe<Topic>;
  /** Reads a single `StarfireMessage` that is related to this `Starfire`. */
  msg?: Maybe<StarfireMessage>;
  /** Reads a single `Vehicle` that is related to this `Starfire`. */
  vehicle?: Maybe<Vehicle>;
  /** An edge for our `Starfire`. May be used by Relay 1. */
  starfireEdge?: Maybe<StarfiresEdge>;
};


/** The output of our create `Starfire` mutation. */
export type CreateStarfirePayloadStarfireEdgeArgs = {
  orderBy?: Maybe<Array<StarfiresOrderBy>>;
};

/** All input for the create `StatusMessageHeader` mutation. */
export type CreateStatusMessageHeaderInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** The output of our create `StatusMessageHeader` mutation. */
export type CreateStatusMessageHeaderPayload = {
  __typename?: 'CreateStatusMessageHeaderPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `StatusMessageHeader` that was created by this mutation. */
  statusMessageHeader?: Maybe<StatusMessageHeader>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `StatusMessageHeader`. May be used by Relay 1. */
  statusMessageHeaderEdge?: Maybe<StatusMessageHeadersEdge>;
};


/** The output of our create `StatusMessageHeader` mutation. */
export type CreateStatusMessageHeaderPayloadStatusMessageHeaderEdgeArgs = {
  orderBy?: Maybe<Array<StatusMessageHeadersOrderBy>>;
};

/** All input for the create `StatusMessage` mutation. */
export type CreateStatusMessageInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `StatusMessage` to be created by this mutation. */
  statusMessage: StatusMessageInput;
};

/** The output of our create `StatusMessage` mutation. */
export type CreateStatusMessagePayload = {
  __typename?: 'CreateStatusMessagePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `StatusMessage` that was created by this mutation. */
  statusMessage?: Maybe<StatusMessage>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `StatusMessageHeader` that is related to this `StatusMessage`. */
  header?: Maybe<StatusMessageHeader>;
  /** Reads a single `StatusMessageMissionStat` that is related to this `StatusMessage`. */
  missionStats?: Maybe<StatusMessageMissionStat>;
  /** An edge for our `StatusMessage`. May be used by Relay 1. */
  statusMessageEdge?: Maybe<StatusMessagesEdge>;
};


/** The output of our create `StatusMessage` mutation. */
export type CreateStatusMessagePayloadStatusMessageEdgeArgs = {
  orderBy?: Maybe<Array<StatusMessagesOrderBy>>;
};

/** All input for the create `StereoExtrinsic` mutation. */
export type CreateStereoExtrinsicInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** The output of our create `StereoExtrinsic` mutation. */
export type CreateStereoExtrinsicPayload = {
  __typename?: 'CreateStereoExtrinsicPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `StereoExtrinsic` that was created by this mutation. */
  stereoExtrinsic?: Maybe<StereoExtrinsic>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `StereoExtrinsicsT` that is related to this `StereoExtrinsic`. */
  t?: Maybe<StereoExtrinsicsT>;
  /** Reads a single `StereoExtrinsicsR` that is related to this `StereoExtrinsic`. */
  r?: Maybe<StereoExtrinsicsR>;
  /** Reads a single `StereoExtrinsicsRRodrigue` that is related to this `StereoExtrinsic`. */
  rRodrigues?: Maybe<StereoExtrinsicsRRodrigue>;
  /** An edge for our `StereoExtrinsic`. May be used by Relay 1. */
  stereoExtrinsicEdge?: Maybe<StereoExtrinsicsEdge>;
};


/** The output of our create `StereoExtrinsic` mutation. */
export type CreateStereoExtrinsicPayloadStereoExtrinsicEdgeArgs = {
  orderBy?: Maybe<Array<StereoExtrinsicsOrderBy>>;
};

/** All input for the create `StereoExtrinsicsR` mutation. */
export type CreateStereoExtrinsicsRInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `StereoExtrinsicsR` to be created by this mutation. */
  stereoExtrinsicsR: StereoExtrinsicsRInput;
};

/** The output of our create `StereoExtrinsicsR` mutation. */
export type CreateStereoExtrinsicsRPayload = {
  __typename?: 'CreateStereoExtrinsicsRPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `StereoExtrinsicsR` that was created by this mutation. */
  stereoExtrinsicsR?: Maybe<StereoExtrinsicsR>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `StereoExtrinsicsR`. May be used by Relay 1. */
  stereoExtrinsicsREdge?: Maybe<StereoExtrinsicsRsEdge>;
};


/** The output of our create `StereoExtrinsicsR` mutation. */
export type CreateStereoExtrinsicsRPayloadStereoExtrinsicsREdgeArgs = {
  orderBy?: Maybe<Array<StereoExtrinsicsRsOrderBy>>;
};

/** All input for the create `StereoExtrinsicsRRodrigue` mutation. */
export type CreateStereoExtrinsicsRRodrigueInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** The output of our create `StereoExtrinsicsRRodrigue` mutation. */
export type CreateStereoExtrinsicsRRodriguePayload = {
  __typename?: 'CreateStereoExtrinsicsRRodriguePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `StereoExtrinsicsRRodrigue` that was created by this mutation. */
  stereoExtrinsicsRRodrigue?: Maybe<StereoExtrinsicsRRodrigue>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `StereoExtrinsicsRRodrigue`. May be used by Relay 1. */
  stereoExtrinsicsRRodrigueEdge?: Maybe<StereoExtrinsicsRRodriguesEdge>;
};


/** The output of our create `StereoExtrinsicsRRodrigue` mutation. */
export type CreateStereoExtrinsicsRRodriguePayloadStereoExtrinsicsRRodrigueEdgeArgs = {
  orderBy?: Maybe<Array<StereoExtrinsicsRRodriguesOrderBy>>;
};

/** All input for the create `StereoExtrinsicsT` mutation. */
export type CreateStereoExtrinsicsTInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** The output of our create `StereoExtrinsicsT` mutation. */
export type CreateStereoExtrinsicsTPayload = {
  __typename?: 'CreateStereoExtrinsicsTPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `StereoExtrinsicsT` that was created by this mutation. */
  stereoExtrinsicsT?: Maybe<StereoExtrinsicsT>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `StereoExtrinsicsT`. May be used by Relay 1. */
  stereoExtrinsicsTEdge?: Maybe<StereoExtrinsicsTsEdge>;
};


/** The output of our create `StereoExtrinsicsT` mutation. */
export type CreateStereoExtrinsicsTPayloadStereoExtrinsicsTEdgeArgs = {
  orderBy?: Maybe<Array<StereoExtrinsicsTsOrderBy>>;
};

/** All input for the create `Test` mutation. */
export type CreateTestInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Test` to be created by this mutation. */
  test: TestInput;
};

/** The output of our create `Test` mutation. */
export type CreateTestPayload = {
  __typename?: 'CreateTestPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Test` that was created by this mutation. */
  test?: Maybe<Test>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Test`. May be used by Relay 1. */
  testEdge?: Maybe<TestsEdge>;
};


/** The output of our create `Test` mutation. */
export type CreateTestPayloadTestEdgeArgs = {
  orderBy?: Maybe<Array<TestsOrderBy>>;
};

/** All input for the create `TopicCategory` mutation. */
export type CreateTopicCategoryInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** The output of our create `TopicCategory` mutation. */
export type CreateTopicCategoryPayload = {
  __typename?: 'CreateTopicCategoryPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `TopicCategory` that was created by this mutation. */
  topicCategory?: Maybe<TopicCategory>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `TopicCategory`. May be used by Relay 1. */
  topicCategoryEdge?: Maybe<TopicCategoriesEdge>;
};


/** The output of our create `TopicCategory` mutation. */
export type CreateTopicCategoryPayloadTopicCategoryEdgeArgs = {
  orderBy?: Maybe<Array<TopicCategoriesOrderBy>>;
};

/** All input for the create `Topic` mutation. */
export type CreateTopicInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Topic` to be created by this mutation. */
  topic: TopicInput;
};

/** The output of our create `Topic` mutation. */
export type CreateTopicPayload = {
  __typename?: 'CreateTopicPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Topic` that was created by this mutation. */
  topic?: Maybe<Topic>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `TopicType` that is related to this `Topic`. */
  type?: Maybe<TopicType>;
  /** Reads a single `TopicCategory` that is related to this `Topic`. */
  topicCategory?: Maybe<TopicCategory>;
  /** An edge for our `Topic`. May be used by Relay 1. */
  topicEdge?: Maybe<TopicsEdge>;
};


/** The output of our create `Topic` mutation. */
export type CreateTopicPayloadTopicEdgeArgs = {
  orderBy?: Maybe<Array<TopicsOrderBy>>;
};

/** All input for the create `TopicType` mutation. */
export type CreateTopicTypeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `TopicType` to be created by this mutation. */
  topicType: TopicTypeInput;
};

/** The output of our create `TopicType` mutation. */
export type CreateTopicTypePayload = {
  __typename?: 'CreateTopicTypePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `TopicType` that was created by this mutation. */
  topicType?: Maybe<TopicType>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `TopicType`. May be used by Relay 1. */
  topicTypeEdge?: Maybe<TopicTypesEdge>;
};


/** The output of our create `TopicType` mutation. */
export type CreateTopicTypePayloadTopicTypeEdgeArgs = {
  orderBy?: Maybe<Array<TopicTypesOrderBy>>;
};

/** All input for the create `TractorExtrinsic` mutation. */
export type CreateTractorExtrinsicInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** The output of our create `TractorExtrinsic` mutation. */
export type CreateTractorExtrinsicPayload = {
  __typename?: 'CreateTractorExtrinsicPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `TractorExtrinsic` that was created by this mutation. */
  tractorExtrinsic?: Maybe<TractorExtrinsic>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `TractorExtrinsicsT` that is related to this `TractorExtrinsic`. */
  t?: Maybe<TractorExtrinsicsT>;
  /** Reads a single `TractorExtrinsicsR` that is related to this `TractorExtrinsic`. */
  r?: Maybe<TractorExtrinsicsR>;
  /** Reads a single `TractorExtrinsicsRRodrigue` that is related to this `TractorExtrinsic`. */
  rRodrigues?: Maybe<TractorExtrinsicsRRodrigue>;
  /** An edge for our `TractorExtrinsic`. May be used by Relay 1. */
  tractorExtrinsicEdge?: Maybe<TractorExtrinsicsEdge>;
};


/** The output of our create `TractorExtrinsic` mutation. */
export type CreateTractorExtrinsicPayloadTractorExtrinsicEdgeArgs = {
  orderBy?: Maybe<Array<TractorExtrinsicsOrderBy>>;
};

/** All input for the create `TractorExtrinsicsR` mutation. */
export type CreateTractorExtrinsicsRInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** The output of our create `TractorExtrinsicsR` mutation. */
export type CreateTractorExtrinsicsRPayload = {
  __typename?: 'CreateTractorExtrinsicsRPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `TractorExtrinsicsR` that was created by this mutation. */
  tractorExtrinsicsR?: Maybe<TractorExtrinsicsR>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `TractorExtrinsicsR`. May be used by Relay 1. */
  tractorExtrinsicsREdge?: Maybe<TractorExtrinsicsRsEdge>;
};


/** The output of our create `TractorExtrinsicsR` mutation. */
export type CreateTractorExtrinsicsRPayloadTractorExtrinsicsREdgeArgs = {
  orderBy?: Maybe<Array<TractorExtrinsicsRsOrderBy>>;
};

/** All input for the create `TractorExtrinsicsRRodrigue` mutation. */
export type CreateTractorExtrinsicsRRodrigueInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** The output of our create `TractorExtrinsicsRRodrigue` mutation. */
export type CreateTractorExtrinsicsRRodriguePayload = {
  __typename?: 'CreateTractorExtrinsicsRRodriguePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `TractorExtrinsicsRRodrigue` that was created by this mutation. */
  tractorExtrinsicsRRodrigue?: Maybe<TractorExtrinsicsRRodrigue>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `TractorExtrinsicsRRodrigue`. May be used by Relay 1. */
  tractorExtrinsicsRRodrigueEdge?: Maybe<TractorExtrinsicsRRodriguesEdge>;
};


/** The output of our create `TractorExtrinsicsRRodrigue` mutation. */
export type CreateTractorExtrinsicsRRodriguePayloadTractorExtrinsicsRRodrigueEdgeArgs = {
  orderBy?: Maybe<Array<TractorExtrinsicsRRodriguesOrderBy>>;
};

/** All input for the create `TractorExtrinsicsT` mutation. */
export type CreateTractorExtrinsicsTInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** The output of our create `TractorExtrinsicsT` mutation. */
export type CreateTractorExtrinsicsTPayload = {
  __typename?: 'CreateTractorExtrinsicsTPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `TractorExtrinsicsT` that was created by this mutation. */
  tractorExtrinsicsT?: Maybe<TractorExtrinsicsT>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `TractorExtrinsicsT`. May be used by Relay 1. */
  tractorExtrinsicsTEdge?: Maybe<TractorExtrinsicsTsEdge>;
};


/** The output of our create `TractorExtrinsicsT` mutation. */
export type CreateTractorExtrinsicsTPayloadTractorExtrinsicsTEdgeArgs = {
  orderBy?: Maybe<Array<TractorExtrinsicsTsOrderBy>>;
};

/** All input for the create `Vehicle` mutation. */
export type CreateVehicleInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Vehicle` to be created by this mutation. */
  vehicle: VehicleInput;
};

/** All input for the create `VehicleLog` mutation. */
export type CreateVehicleLogInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** All input for the create `VehicleLogMessage` mutation. */
export type CreateVehicleLogMessageInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** The output of our create `VehicleLogMessage` mutation. */
export type CreateVehicleLogMessagePayload = {
  __typename?: 'CreateVehicleLogMessagePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `VehicleLogMessage` that was created by this mutation. */
  vehicleLogMessage?: Maybe<VehicleLogMessage>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `VehicleLogMessageStamp` that is related to this `VehicleLogMessage`. */
  stamp?: Maybe<VehicleLogMessageStamp>;
  /** An edge for our `VehicleLogMessage`. May be used by Relay 1. */
  vehicleLogMessageEdge?: Maybe<VehicleLogMessagesEdge>;
};


/** The output of our create `VehicleLogMessage` mutation. */
export type CreateVehicleLogMessagePayloadVehicleLogMessageEdgeArgs = {
  orderBy?: Maybe<Array<VehicleLogMessagesOrderBy>>;
};

/** All input for the create `VehicleLogMessageStamp` mutation. */
export type CreateVehicleLogMessageStampInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** The output of our create `VehicleLogMessageStamp` mutation. */
export type CreateVehicleLogMessageStampPayload = {
  __typename?: 'CreateVehicleLogMessageStampPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `VehicleLogMessageStamp` that was created by this mutation. */
  vehicleLogMessageStamp?: Maybe<VehicleLogMessageStamp>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `VehicleLogMessageStamp`. May be used by Relay 1. */
  vehicleLogMessageStampEdge?: Maybe<VehicleLogMessageStampsEdge>;
};


/** The output of our create `VehicleLogMessageStamp` mutation. */
export type CreateVehicleLogMessageStampPayloadVehicleLogMessageStampEdgeArgs = {
  orderBy?: Maybe<Array<VehicleLogMessageStampsOrderBy>>;
};

/** The output of our create `VehicleLog` mutation. */
export type CreateVehicleLogPayload = {
  __typename?: 'CreateVehicleLogPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `VehicleLog` that was created by this mutation. */
  vehicleLog?: Maybe<VehicleLog>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `VehicleLogMessage` that is related to this `VehicleLog`. */
  message?: Maybe<VehicleLogMessage>;
  /** Reads a single `Vehicle` that is related to this `VehicleLog`. */
  vehicle?: Maybe<Vehicle>;
  /** Reads a single `Topic` that is related to this `VehicleLog`. */
  topic?: Maybe<Topic>;
  /** An edge for our `VehicleLog`. May be used by Relay 1. */
  vehicleLogEdge?: Maybe<VehicleLogsEdge>;
};


/** The output of our create `VehicleLog` mutation. */
export type CreateVehicleLogPayloadVehicleLogEdgeArgs = {
  orderBy?: Maybe<Array<VehicleLogsOrderBy>>;
};

/** The output of our create `Vehicle` mutation. */
export type CreateVehiclePayload = {
  __typename?: 'CreateVehiclePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Vehicle` that was created by this mutation. */
  vehicle?: Maybe<Vehicle>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `VehicleType` that is related to this `Vehicle`. */
  type?: Maybe<VehicleType>;
  /** An edge for our `Vehicle`. May be used by Relay 1. */
  vehicleEdge?: Maybe<VehiclesEdge>;
};


/** The output of our create `Vehicle` mutation. */
export type CreateVehiclePayloadVehicleEdgeArgs = {
  orderBy?: Maybe<Array<VehiclesOrderBy>>;
};

/** All input for the create `VehicleState` mutation. */
export type CreateVehicleStateInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `VehicleState` to be created by this mutation. */
  vehicleState: VehicleStateInput;
};

/** The output of our create `VehicleState` mutation. */
export type CreateVehicleStatePayload = {
  __typename?: 'CreateVehicleStatePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `VehicleState` that was created by this mutation. */
  vehicleState?: Maybe<VehicleState>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `VehicleState`. May be used by Relay 1. */
  vehicleStateEdge?: Maybe<VehicleStatesEdge>;
};


/** The output of our create `VehicleState` mutation. */
export type CreateVehicleStatePayloadVehicleStateEdgeArgs = {
  orderBy?: Maybe<Array<VehicleStatesOrderBy>>;
};

/** All input for the create `VehicleStateReason` mutation. */
export type CreateVehicleStateReasonInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `VehicleStateReason` to be created by this mutation. */
  vehicleStateReason: VehicleStateReasonInput;
};

/** The output of our create `VehicleStateReason` mutation. */
export type CreateVehicleStateReasonPayload = {
  __typename?: 'CreateVehicleStateReasonPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `VehicleStateReason` that was created by this mutation. */
  vehicleStateReason?: Maybe<VehicleStateReason>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `VehicleStateReason`. May be used by Relay 1. */
  vehicleStateReasonEdge?: Maybe<VehicleStateReasonsEdge>;
};


/** The output of our create `VehicleStateReason` mutation. */
export type CreateVehicleStateReasonPayloadVehicleStateReasonEdgeArgs = {
  orderBy?: Maybe<Array<VehicleStateReasonsOrderBy>>;
};

/** All input for the create `VehicleStatusDetail` mutation. */
export type CreateVehicleStatusDetailInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `VehicleStatusDetail` to be created by this mutation. */
  vehicleStatusDetail: VehicleStatusDetailInput;
};

/** The output of our create `VehicleStatusDetail` mutation. */
export type CreateVehicleStatusDetailPayload = {
  __typename?: 'CreateVehicleStatusDetailPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `VehicleStatusDetail` that was created by this mutation. */
  vehicleStatusDetail?: Maybe<VehicleStatusDetail>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `VehicleStatus` that is related to this `VehicleStatusDetail`. */
  vehicleStatus?: Maybe<VehicleStatus>;
  /** Reads a single `VehicleStateReason` that is related to this `VehicleStatusDetail`. */
  vehicleStatusReason?: Maybe<VehicleStateReason>;
  /** An edge for our `VehicleStatusDetail`. May be used by Relay 1. */
  vehicleStatusDetailEdge?: Maybe<VehicleStatusDetailsEdge>;
};


/** The output of our create `VehicleStatusDetail` mutation. */
export type CreateVehicleStatusDetailPayloadVehicleStatusDetailEdgeArgs = {
  orderBy?: Maybe<Array<VehicleStatusDetailsOrderBy>>;
};

/** All input for the create `VehicleStatus` mutation. */
export type CreateVehicleStatusInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `VehicleStatus` to be created by this mutation. */
  vehicleStatus: VehicleStatusInput;
};

/** The output of our create `VehicleStatus` mutation. */
export type CreateVehicleStatusPayload = {
  __typename?: 'CreateVehicleStatusPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `VehicleStatus` that was created by this mutation. */
  vehicleStatus?: Maybe<VehicleStatus>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Vehicle` that is related to this `VehicleStatus`. */
  vehicle?: Maybe<Vehicle>;
  /** Reads a single `VehicleState` that is related to this `VehicleStatus`. */
  state?: Maybe<VehicleState>;
  /** Reads a single `StatusMessage` that is related to this `VehicleStatus`. */
  statusMessage?: Maybe<StatusMessage>;
  /** Reads a single `Topic` that is related to this `VehicleStatus`. */
  topic?: Maybe<Topic>;
  /** An edge for our `VehicleStatus`. May be used by Relay 1. */
  vehicleStatusEdge?: Maybe<VehicleStatusesEdge>;
};


/** The output of our create `VehicleStatus` mutation. */
export type CreateVehicleStatusPayloadVehicleStatusEdgeArgs = {
  orderBy?: Maybe<Array<VehicleStatusesOrderBy>>;
};

/** All input for the create `VehicleTopic` mutation. */
export type CreateVehicleTopicInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** The output of our create `VehicleTopic` mutation. */
export type CreateVehicleTopicPayload = {
  __typename?: 'CreateVehicleTopicPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `VehicleTopic` that was created by this mutation. */
  vehicleTopic?: Maybe<VehicleTopic>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Vehicle` that is related to this `VehicleTopic`. */
  vehicle?: Maybe<Vehicle>;
  /** Reads a single `Topic` that is related to this `VehicleTopic`. */
  topic?: Maybe<Topic>;
  /** An edge for our `VehicleTopic`. May be used by Relay 1. */
  vehicleTopicEdge?: Maybe<VehicleTopicsEdge>;
};


/** The output of our create `VehicleTopic` mutation. */
export type CreateVehicleTopicPayloadVehicleTopicEdgeArgs = {
  orderBy?: Maybe<Array<VehicleTopicsOrderBy>>;
};

/** All input for the create `VehicleType` mutation. */
export type CreateVehicleTypeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `VehicleType` to be created by this mutation. */
  vehicleType: VehicleTypeInput;
};

/** The output of our create `VehicleType` mutation. */
export type CreateVehicleTypePayload = {
  __typename?: 'CreateVehicleTypePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `VehicleType` that was created by this mutation. */
  vehicleType?: Maybe<VehicleType>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `VehicleType`. May be used by Relay 1. */
  vehicleTypeEdge?: Maybe<VehicleTypesEdge>;
};


/** The output of our create `VehicleType` mutation. */
export type CreateVehicleTypePayloadVehicleTypeEdgeArgs = {
  orderBy?: Maybe<Array<VehicleTypesOrderBy>>;
};

/** All input for the create `VehiclesOffline` mutation. */
export type CreateVehiclesOfflineInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `VehiclesOffline` to be created by this mutation. */
  vehiclesOffline: VehiclesOfflineInput;
};

/** The output of our create `VehiclesOffline` mutation. */
export type CreateVehiclesOfflinePayload = {
  __typename?: 'CreateVehiclesOfflinePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `VehiclesOffline` that was created by this mutation. */
  vehiclesOffline?: Maybe<VehiclesOffline>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `VehiclesOffline`. May be used by Relay 1. */
  vehiclesOfflineEdge?: Maybe<VehiclesOfflinesEdge>;
};


/** The output of our create `VehiclesOffline` mutation. */
export type CreateVehiclesOfflinePayloadVehiclesOfflineEdgeArgs = {
  orderBy?: Maybe<Array<VehiclesOfflinesOrderBy>>;
};

/** All input for the create `VehiclesOnline` mutation. */
export type CreateVehiclesOnlineInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `VehiclesOnline` to be created by this mutation. */
  vehiclesOnline: VehiclesOnlineInput;
};

/** The output of our create `VehiclesOnline` mutation. */
export type CreateVehiclesOnlinePayload = {
  __typename?: 'CreateVehiclesOnlinePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `VehiclesOnline` that was created by this mutation. */
  vehiclesOnline?: Maybe<VehiclesOnline>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Vehicle` that is related to this `VehiclesOnline`. */
  vehicle?: Maybe<Vehicle>;
  /** An edge for our `VehiclesOnline`. May be used by Relay 1. */
  vehiclesOnlineEdge?: Maybe<VehiclesOnlinesEdge>;
};


/** The output of our create `VehiclesOnline` mutation. */
export type CreateVehiclesOnlinePayloadVehiclesOnlineEdgeArgs = {
  orderBy?: Maybe<Array<VehiclesOnlinesOrderBy>>;
};



/** A filter to be used against Datetime fields. All fields are combined with a logical ‘and.’ */
export type DatetimeFilter = {
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: Maybe<Scalars['Boolean']>;
  /** Equal to the specified value. */
  equalTo?: Maybe<Scalars['Datetime']>;
  /** Not equal to the specified value. */
  notEqualTo?: Maybe<Scalars['Datetime']>;
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: Maybe<Scalars['Datetime']>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: Maybe<Scalars['Datetime']>;
  /** Included in the specified list. */
  in?: Maybe<Array<Scalars['Datetime']>>;
  /** Not included in the specified list. */
  notIn?: Maybe<Array<Scalars['Datetime']>>;
  /** Less than the specified value. */
  lessThan?: Maybe<Scalars['Datetime']>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: Maybe<Scalars['Datetime']>;
  /** Greater than the specified value. */
  greaterThan?: Maybe<Scalars['Datetime']>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: Maybe<Scalars['Datetime']>;
};

/** All input for the `deleteAlertByNodeId` mutation. */
export type DeleteAlertByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Alert` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteAlert` mutation. */
export type DeleteAlertInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Id for the alert assigned by database */
  id: Scalars['BigInt'];
};

/** The output of our delete `Alert` mutation. */
export type DeleteAlertPayload = {
  __typename?: 'DeleteAlertPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Alert` that was deleted by this mutation. */
  alert?: Maybe<Alert>;
  deletedAlertNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `AlertType` that is related to this `Alert`. */
  alertType?: Maybe<AlertType>;
  /** Reads a single `VehicleStatus` that is related to this `Alert`. */
  vehicleStatus?: Maybe<VehicleStatus>;
  /** An edge for our `Alert`. May be used by Relay 1. */
  alertEdge?: Maybe<AlertsEdge>;
};


/** The output of our delete `Alert` mutation. */
export type DeleteAlertPayloadAlertEdgeArgs = {
  orderBy?: Maybe<Array<AlertsOrderBy>>;
};

/** All input for the `deleteAlertTypeByNodeId` mutation. */
export type DeleteAlertTypeByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `AlertType` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteAlertType` mutation. */
export type DeleteAlertTypeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Id for the alert type assigned by database */
  id: Scalars['BigInt'];
};

/** The output of our delete `AlertType` mutation. */
export type DeleteAlertTypePayload = {
  __typename?: 'DeleteAlertTypePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `AlertType` that was deleted by this mutation. */
  alertType?: Maybe<AlertType>;
  deletedAlertTypeNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `AlertType`. May be used by Relay 1. */
  alertTypeEdge?: Maybe<AlertTypesEdge>;
};


/** The output of our delete `AlertType` mutation. */
export type DeleteAlertTypePayloadAlertTypeEdgeArgs = {
  orderBy?: Maybe<Array<AlertTypesOrderBy>>;
};

/** All input for the `deleteCameraByNodeId` mutation. */
export type DeleteCameraByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Camera` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteCameraHistogramByNodeId` mutation. */
export type DeleteCameraHistogramByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `CameraHistogram` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteCameraHistogram` mutation. */
export type DeleteCameraHistogramInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Id generated by database, auto incremented */
  id: Scalars['BigInt'];
};

/** The output of our delete `CameraHistogram` mutation. */
export type DeleteCameraHistogramPayload = {
  __typename?: 'DeleteCameraHistogramPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CameraHistogram` that was deleted by this mutation. */
  cameraHistogram?: Maybe<CameraHistogram>;
  deletedCameraHistogramNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `FullHistogram` that is related to this `CameraHistogram`. */
  fullHistogram?: Maybe<FullHistogram>;
  /** Reads a single `SmallHistogram` that is related to this `CameraHistogram`. */
  smallHistogram?: Maybe<SmallHistogram>;
  /** An edge for our `CameraHistogram`. May be used by Relay 1. */
  cameraHistogramEdge?: Maybe<CameraHistogramsEdge>;
};


/** The output of our delete `CameraHistogram` mutation. */
export type DeleteCameraHistogramPayloadCameraHistogramEdgeArgs = {
  orderBy?: Maybe<Array<CameraHistogramsOrderBy>>;
};

/** All input for the `deleteCamera` mutation. */
export type DeleteCameraInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** id auto-incremented by database */
  id: Scalars['BigInt'];
};

/** All input for the `deleteCameraMessageByNodeId` mutation. */
export type DeleteCameraMessageByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `CameraMessage` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteCameraMessageHeaderByNodeId` mutation. */
export type DeleteCameraMessageHeaderByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `CameraMessageHeader` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteCameraMessageHeader` mutation. */
export type DeleteCameraMessageHeaderInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Id generated by database, auto incremented */
  id: Scalars['BigInt'];
};

/** The output of our delete `CameraMessageHeader` mutation. */
export type DeleteCameraMessageHeaderPayload = {
  __typename?: 'DeleteCameraMessageHeaderPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CameraMessageHeader` that was deleted by this mutation. */
  cameraMessageHeader?: Maybe<CameraMessageHeader>;
  deletedCameraMessageHeaderNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `CameraMessageHeader`. May be used by Relay 1. */
  cameraMessageHeaderEdge?: Maybe<CameraMessageHeadersEdge>;
};


/** The output of our delete `CameraMessageHeader` mutation. */
export type DeleteCameraMessageHeaderPayloadCameraMessageHeaderEdgeArgs = {
  orderBy?: Maybe<Array<CameraMessageHeadersOrderBy>>;
};

/** All input for the `deleteCameraMessage` mutation. */
export type DeleteCameraMessageInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** id auto-incremented by database */
  id: Scalars['BigInt'];
};

/** The output of our delete `CameraMessage` mutation. */
export type DeleteCameraMessagePayload = {
  __typename?: 'DeleteCameraMessagePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CameraMessage` that was deleted by this mutation. */
  cameraMessage?: Maybe<CameraMessage>;
  deletedCameraMessageNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `CameraMessageHeader` that is related to this `CameraMessage`. */
  header?: Maybe<CameraMessageHeader>;
  /** Reads a single `Image` that is related to this `CameraMessage`. */
  image?: Maybe<Image>;
  /** Reads a single `CameraMeta` that is related to this `CameraMessage`. */
  cameraMeta?: Maybe<CameraMeta>;
  /** An edge for our `CameraMessage`. May be used by Relay 1. */
  cameraMessageEdge?: Maybe<CameraMessagesEdge>;
};


/** The output of our delete `CameraMessage` mutation. */
export type DeleteCameraMessagePayloadCameraMessageEdgeArgs = {
  orderBy?: Maybe<Array<CameraMessagesOrderBy>>;
};

/** All input for the `deleteCameraMetaByNodeId` mutation. */
export type DeleteCameraMetaByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `CameraMeta` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteCameraMetaEByNodeId` mutation. */
export type DeleteCameraMetaEByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `CameraMetaE` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteCameraMetaE` mutation. */
export type DeleteCameraMetaEInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Id generated by database, auto incremented */
  id: Scalars['BigInt'];
};

/** The output of our delete `CameraMetaE` mutation. */
export type DeleteCameraMetaEPayload = {
  __typename?: 'DeleteCameraMetaEPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CameraMetaE` that was deleted by this mutation. */
  cameraMetaE?: Maybe<CameraMetaE>;
  deletedCameraMetaENodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `CameraMetaE`. May be used by Relay 1. */
  cameraMetaEEdge?: Maybe<CameraMetaEsEdge>;
};


/** The output of our delete `CameraMetaE` mutation. */
export type DeleteCameraMetaEPayloadCameraMetaEEdgeArgs = {
  orderBy?: Maybe<Array<CameraMetaEsOrderBy>>;
};

/** All input for the `deleteCameraMetaFByNodeId` mutation. */
export type DeleteCameraMetaFByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `CameraMetaF` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteCameraMetaF` mutation. */
export type DeleteCameraMetaFInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Id generated by database, auto incremented */
  id: Scalars['BigInt'];
};

/** The output of our delete `CameraMetaF` mutation. */
export type DeleteCameraMetaFPayload = {
  __typename?: 'DeleteCameraMetaFPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CameraMetaF` that was deleted by this mutation. */
  cameraMetaF?: Maybe<CameraMetaF>;
  deletedCameraMetaFNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `CameraMetaF`. May be used by Relay 1. */
  cameraMetaFEdge?: Maybe<CameraMetaFsEdge>;
};


/** The output of our delete `CameraMetaF` mutation. */
export type DeleteCameraMetaFPayloadCameraMetaFEdgeArgs = {
  orderBy?: Maybe<Array<CameraMetaFsOrderBy>>;
};

/** All input for the `deleteCameraMeta` mutation. */
export type DeleteCameraMetaInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** id auto-incremented by database */
  id: Scalars['BigInt'];
};

/** All input for the `deleteCameraMetaP1ByNodeId` mutation. */
export type DeleteCameraMetaP1ByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `CameraMetaP1` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteCameraMetaP1` mutation. */
export type DeleteCameraMetaP1Input = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Id generated by database, auto incremented */
  id: Scalars['BigInt'];
};

/** The output of our delete `CameraMetaP1` mutation. */
export type DeleteCameraMetaP1Payload = {
  __typename?: 'DeleteCameraMetaP1Payload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CameraMetaP1` that was deleted by this mutation. */
  cameraMetaP1?: Maybe<CameraMetaP1>;
  deletedCameraMetaP1NodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `CameraMetaP1`. May be used by Relay 1. */
  cameraMetaP1Edge?: Maybe<CameraMetaP1sEdge>;
};


/** The output of our delete `CameraMetaP1` mutation. */
export type DeleteCameraMetaP1PayloadCameraMetaP1EdgeArgs = {
  orderBy?: Maybe<Array<CameraMetaP1sOrderBy>>;
};

/** All input for the `deleteCameraMetaP2ByNodeId` mutation. */
export type DeleteCameraMetaP2ByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `CameraMetaP2` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteCameraMetaP2` mutation. */
export type DeleteCameraMetaP2Input = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Id generated by database, auto incremented */
  id: Scalars['BigInt'];
};

/** The output of our delete `CameraMetaP2` mutation. */
export type DeleteCameraMetaP2Payload = {
  __typename?: 'DeleteCameraMetaP2Payload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CameraMetaP2` that was deleted by this mutation. */
  cameraMetaP2?: Maybe<CameraMetaP2>;
  deletedCameraMetaP2NodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `CameraMetaP2`. May be used by Relay 1. */
  cameraMetaP2Edge?: Maybe<CameraMetaP2sEdge>;
};


/** The output of our delete `CameraMetaP2` mutation. */
export type DeleteCameraMetaP2PayloadCameraMetaP2EdgeArgs = {
  orderBy?: Maybe<Array<CameraMetaP2sOrderBy>>;
};

/** The output of our delete `CameraMeta` mutation. */
export type DeleteCameraMetaPayload = {
  __typename?: 'DeleteCameraMetaPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CameraMeta` that was deleted by this mutation. */
  cameraMeta?: Maybe<CameraMeta>;
  deletedCameraMetaNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `SideIntrinsic` that is related to this `CameraMeta`. */
  leftIntrinsics?: Maybe<SideIntrinsic>;
  /** Reads a single `SideIntrinsic` that is related to this `CameraMeta`. */
  rightIntrinsics?: Maybe<SideIntrinsic>;
  /** Reads a single `StereoExtrinsic` that is related to this `CameraMeta`. */
  stereoExtrinsics?: Maybe<StereoExtrinsic>;
  /** Reads a single `TractorExtrinsic` that is related to this `CameraMeta`. */
  tractorExtrinsics?: Maybe<TractorExtrinsic>;
  /** Reads a single `CameraMetaE` that is related to this `CameraMeta`. */
  e?: Maybe<CameraMetaE>;
  /** Reads a single `CameraMetaF` that is related to this `CameraMeta`. */
  f?: Maybe<CameraMetaF>;
  /** Reads a single `CameraMetaR1` that is related to this `CameraMeta`. */
  r1?: Maybe<CameraMetaR1>;
  /** Reads a single `CameraMetaR2` that is related to this `CameraMeta`. */
  r2?: Maybe<CameraMetaR2>;
  /** Reads a single `CameraMetaP1` that is related to this `CameraMeta`. */
  p1?: Maybe<CameraMetaP1>;
  /** Reads a single `CameraMetaP2` that is related to this `CameraMeta`. */
  p2?: Maybe<CameraMetaP2>;
  /** Reads a single `CameraMetaQ` that is related to this `CameraMeta`. */
  q?: Maybe<CameraMetaQ>;
  /** Reads a single `CameraRoi` that is related to this `CameraMeta`. */
  leftRoi?: Maybe<CameraRoi>;
  /** Reads a single `CameraRoi` that is related to this `CameraMeta`. */
  rightRoi?: Maybe<CameraRoi>;
  /** Reads a single `CameraHistogram` that is related to this `CameraMeta`. */
  leftHistogram?: Maybe<CameraHistogram>;
  /** Reads a single `CameraHistogram` that is related to this `CameraMeta`. */
  rightHistogram?: Maybe<CameraHistogram>;
  /** An edge for our `CameraMeta`. May be used by Relay 1. */
  cameraMetaEdge?: Maybe<CameraMetasEdge>;
};


/** The output of our delete `CameraMeta` mutation. */
export type DeleteCameraMetaPayloadCameraMetaEdgeArgs = {
  orderBy?: Maybe<Array<CameraMetasOrderBy>>;
};

/** All input for the `deleteCameraMetaQByNodeId` mutation. */
export type DeleteCameraMetaQByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `CameraMetaQ` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteCameraMetaQ` mutation. */
export type DeleteCameraMetaQInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Id generated by database, auto incremented */
  id: Scalars['BigInt'];
};

/** The output of our delete `CameraMetaQ` mutation. */
export type DeleteCameraMetaQPayload = {
  __typename?: 'DeleteCameraMetaQPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CameraMetaQ` that was deleted by this mutation. */
  cameraMetaQ?: Maybe<CameraMetaQ>;
  deletedCameraMetaQNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `CameraMetaQ`. May be used by Relay 1. */
  cameraMetaQEdge?: Maybe<CameraMetaQsEdge>;
};


/** The output of our delete `CameraMetaQ` mutation. */
export type DeleteCameraMetaQPayloadCameraMetaQEdgeArgs = {
  orderBy?: Maybe<Array<CameraMetaQsOrderBy>>;
};

/** All input for the `deleteCameraMetaR1ByNodeId` mutation. */
export type DeleteCameraMetaR1ByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `CameraMetaR1` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteCameraMetaR1` mutation. */
export type DeleteCameraMetaR1Input = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Id generated by database, auto incremented */
  id: Scalars['BigInt'];
};

/** The output of our delete `CameraMetaR1` mutation. */
export type DeleteCameraMetaR1Payload = {
  __typename?: 'DeleteCameraMetaR1Payload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CameraMetaR1` that was deleted by this mutation. */
  cameraMetaR1?: Maybe<CameraMetaR1>;
  deletedCameraMetaR1NodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `CameraMetaR1`. May be used by Relay 1. */
  cameraMetaR1Edge?: Maybe<CameraMetaR1sEdge>;
};


/** The output of our delete `CameraMetaR1` mutation. */
export type DeleteCameraMetaR1PayloadCameraMetaR1EdgeArgs = {
  orderBy?: Maybe<Array<CameraMetaR1sOrderBy>>;
};

/** All input for the `deleteCameraMetaR2ByNodeId` mutation. */
export type DeleteCameraMetaR2ByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `CameraMetaR2` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteCameraMetaR2` mutation. */
export type DeleteCameraMetaR2Input = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Id generated by database, auto incremented */
  id: Scalars['BigInt'];
};

/** The output of our delete `CameraMetaR2` mutation. */
export type DeleteCameraMetaR2Payload = {
  __typename?: 'DeleteCameraMetaR2Payload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CameraMetaR2` that was deleted by this mutation. */
  cameraMetaR2?: Maybe<CameraMetaR2>;
  deletedCameraMetaR2NodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `CameraMetaR2`. May be used by Relay 1. */
  cameraMetaR2Edge?: Maybe<CameraMetaR2sEdge>;
};


/** The output of our delete `CameraMetaR2` mutation. */
export type DeleteCameraMetaR2PayloadCameraMetaR2EdgeArgs = {
  orderBy?: Maybe<Array<CameraMetaR2sOrderBy>>;
};

/** All input for the `deleteCameraPairByNodeId` mutation. */
export type DeleteCameraPairByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `CameraPair` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteCameraPair` mutation. */
export type DeleteCameraPairInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** id auto-incremented by database */
  id: Scalars['BigInt'];
};

/** All input for the `deleteCameraPairMessageByNodeId` mutation. */
export type DeleteCameraPairMessageByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `CameraPairMessage` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteCameraPairMessage` mutation. */
export type DeleteCameraPairMessageInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** id auto-incremented by database */
  id: Scalars['BigInt'];
};

/** The output of our delete `CameraPairMessage` mutation. */
export type DeleteCameraPairMessagePayload = {
  __typename?: 'DeleteCameraPairMessagePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CameraPairMessage` that was deleted by this mutation. */
  cameraPairMessage?: Maybe<CameraPairMessage>;
  deletedCameraPairMessageNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `CameraMessageHeader` that is related to this `CameraPairMessage`. */
  header?: Maybe<CameraMessageHeader>;
  /** Reads a single `Image` that is related to this `CameraPairMessage`. */
  leftImage?: Maybe<Image>;
  /** Reads a single `Image` that is related to this `CameraPairMessage`. */
  rightImage?: Maybe<Image>;
  /** Reads a single `CameraMeta` that is related to this `CameraPairMessage`. */
  cameraMeta?: Maybe<CameraMeta>;
  /** An edge for our `CameraPairMessage`. May be used by Relay 1. */
  cameraPairMessageEdge?: Maybe<CameraPairMessagesEdge>;
};


/** The output of our delete `CameraPairMessage` mutation. */
export type DeleteCameraPairMessagePayloadCameraPairMessageEdgeArgs = {
  orderBy?: Maybe<Array<CameraPairMessagesOrderBy>>;
};

/** The output of our delete `CameraPair` mutation. */
export type DeleteCameraPairPayload = {
  __typename?: 'DeleteCameraPairPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CameraPair` that was deleted by this mutation. */
  cameraPair?: Maybe<CameraPair>;
  deletedCameraPairNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Topic` that is related to this `CameraPair`. */
  topic?: Maybe<Topic>;
  /** Reads a single `CameraPairMessage` that is related to this `CameraPair`. */
  msg?: Maybe<CameraPairMessage>;
  /** Reads a single `TopicType` that is related to this `CameraPair`. */
  topicType?: Maybe<TopicType>;
  /** Reads a single `Vehicle` that is related to this `CameraPair`. */
  vehicle?: Maybe<Vehicle>;
  /** An edge for our `CameraPair`. May be used by Relay 1. */
  cameraPairEdge?: Maybe<CameraPairsEdge>;
};


/** The output of our delete `CameraPair` mutation. */
export type DeleteCameraPairPayloadCameraPairEdgeArgs = {
  orderBy?: Maybe<Array<CameraPairsOrderBy>>;
};

/** The output of our delete `Camera` mutation. */
export type DeleteCameraPayload = {
  __typename?: 'DeleteCameraPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Camera` that was deleted by this mutation. */
  camera?: Maybe<Camera>;
  deletedCameraNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Topic` that is related to this `Camera`. */
  topic?: Maybe<Topic>;
  /** Reads a single `CameraMessage` that is related to this `Camera`. */
  msg?: Maybe<CameraMessage>;
  /** Reads a single `Vehicle` that is related to this `Camera`. */
  vehicle?: Maybe<Vehicle>;
  /** An edge for our `Camera`. May be used by Relay 1. */
  cameraEdge?: Maybe<CamerasEdge>;
};


/** The output of our delete `Camera` mutation. */
export type DeleteCameraPayloadCameraEdgeArgs = {
  orderBy?: Maybe<Array<CamerasOrderBy>>;
};

/** All input for the `deleteCameraRoiByNodeId` mutation. */
export type DeleteCameraRoiByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `CameraRoi` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteCameraRoi` mutation. */
export type DeleteCameraRoiInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Id generated by database, auto incremented */
  id: Scalars['BigInt'];
};

/** The output of our delete `CameraRoi` mutation. */
export type DeleteCameraRoiPayload = {
  __typename?: 'DeleteCameraRoiPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CameraRoi` that was deleted by this mutation. */
  cameraRoi?: Maybe<CameraRoi>;
  deletedCameraRoiNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `CameraRoi`. May be used by Relay 1. */
  cameraRoiEdge?: Maybe<CameraRoisEdge>;
};


/** The output of our delete `CameraRoi` mutation. */
export type DeleteCameraRoiPayloadCameraRoiEdgeArgs = {
  orderBy?: Maybe<Array<CameraRoisOrderBy>>;
};

/** All input for the `deleteFullHistogramByNodeId` mutation. */
export type DeleteFullHistogramByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `FullHistogram` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteFullHistogram` mutation. */
export type DeleteFullHistogramInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Id generated by database, auto incremented */
  id: Scalars['BigInt'];
};

/** The output of our delete `FullHistogram` mutation. */
export type DeleteFullHistogramPayload = {
  __typename?: 'DeleteFullHistogramPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `FullHistogram` that was deleted by this mutation. */
  fullHistogram?: Maybe<FullHistogram>;
  deletedFullHistogramNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `FullHistogram`. May be used by Relay 1. */
  fullHistogramEdge?: Maybe<FullHistogramsEdge>;
};


/** The output of our delete `FullHistogram` mutation. */
export type DeleteFullHistogramPayloadFullHistogramEdgeArgs = {
  orderBy?: Maybe<Array<FullHistogramsOrderBy>>;
};

/** All input for the `deleteImageByNodeId` mutation. */
export type DeleteImageByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Image` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteImageDatumByNodeId` mutation. */
export type DeleteImageDatumByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `ImageDatum` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteImageDatum` mutation. */
export type DeleteImageDatumInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Id generated by database, auto incremented */
  id: Scalars['BigInt'];
};

/** The output of our delete `ImageDatum` mutation. */
export type DeleteImageDatumPayload = {
  __typename?: 'DeleteImageDatumPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ImageDatum` that was deleted by this mutation. */
  imageDatum?: Maybe<ImageDatum>;
  deletedImageDatumNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `ImageDatum`. May be used by Relay 1. */
  imageDatumEdge?: Maybe<ImageDataEdge>;
};


/** The output of our delete `ImageDatum` mutation. */
export type DeleteImageDatumPayloadImageDatumEdgeArgs = {
  orderBy?: Maybe<Array<ImageDataOrderBy>>;
};

/** All input for the `deleteImageHeaderByNodeId` mutation. */
export type DeleteImageHeaderByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `ImageHeader` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteImageHeader` mutation. */
export type DeleteImageHeaderInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Id generated by database, auto incremented */
  id: Scalars['BigInt'];
};

/** The output of our delete `ImageHeader` mutation. */
export type DeleteImageHeaderPayload = {
  __typename?: 'DeleteImageHeaderPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ImageHeader` that was deleted by this mutation. */
  imageHeader?: Maybe<ImageHeader>;
  deletedImageHeaderNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `ImageHeaderStamp` that is related to this `ImageHeader`. */
  stamp?: Maybe<ImageHeaderStamp>;
  /** An edge for our `ImageHeader`. May be used by Relay 1. */
  imageHeaderEdge?: Maybe<ImageHeadersEdge>;
};


/** The output of our delete `ImageHeader` mutation. */
export type DeleteImageHeaderPayloadImageHeaderEdgeArgs = {
  orderBy?: Maybe<Array<ImageHeadersOrderBy>>;
};

/** All input for the `deleteImageHeaderStampByNodeId` mutation. */
export type DeleteImageHeaderStampByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `ImageHeaderStamp` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteImageHeaderStamp` mutation. */
export type DeleteImageHeaderStampInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Id generated by database, auto incremented */
  id: Scalars['BigInt'];
};

/** The output of our delete `ImageHeaderStamp` mutation. */
export type DeleteImageHeaderStampPayload = {
  __typename?: 'DeleteImageHeaderStampPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ImageHeaderStamp` that was deleted by this mutation. */
  imageHeaderStamp?: Maybe<ImageHeaderStamp>;
  deletedImageHeaderStampNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `ImageHeaderStamp`. May be used by Relay 1. */
  imageHeaderStampEdge?: Maybe<ImageHeaderStampsEdge>;
};


/** The output of our delete `ImageHeaderStamp` mutation. */
export type DeleteImageHeaderStampPayloadImageHeaderStampEdgeArgs = {
  orderBy?: Maybe<Array<ImageHeaderStampsOrderBy>>;
};

/** All input for the `deleteImage` mutation. */
export type DeleteImageInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Id generated by database, auto incremented */
  id: Scalars['BigInt'];
};

/** The output of our delete `Image` mutation. */
export type DeleteImagePayload = {
  __typename?: 'DeleteImagePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Image` that was deleted by this mutation. */
  image?: Maybe<Image>;
  deletedImageNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `ImageHeader` that is related to this `Image`. */
  header?: Maybe<ImageHeader>;
  /** Reads a single `ImageDatum` that is related to this `Image`. */
  data?: Maybe<ImageDatum>;
  /** An edge for our `Image`. May be used by Relay 1. */
  imageEdge?: Maybe<ImagesEdge>;
};


/** The output of our delete `Image` mutation. */
export type DeleteImagePayloadImageEdgeArgs = {
  orderBy?: Maybe<Array<ImagesOrderBy>>;
};

/** All input for the `deleteSegmentationMapByNodeId` mutation. */
export type DeleteSegmentationMapByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `SegmentationMap` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteSegmentationMap` mutation. */
export type DeleteSegmentationMapInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** id auto-incremented by database */
  id: Scalars['BigInt'];
};

/** The output of our delete `SegmentationMap` mutation. */
export type DeleteSegmentationMapPayload = {
  __typename?: 'DeleteSegmentationMapPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `SegmentationMap` that was deleted by this mutation. */
  segmentationMap?: Maybe<SegmentationMap>;
  deletedSegmentationMapNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Topic` that is related to this `SegmentationMap`. */
  topic?: Maybe<Topic>;
  /** Reads a single `CameraMessage` that is related to this `SegmentationMap`. */
  msg?: Maybe<CameraMessage>;
  /** Reads a single `Vehicle` that is related to this `SegmentationMap`. */
  vehicle?: Maybe<Vehicle>;
  /** An edge for our `SegmentationMap`. May be used by Relay 1. */
  segmentationMapEdge?: Maybe<SegmentationMapsEdge>;
};


/** The output of our delete `SegmentationMap` mutation. */
export type DeleteSegmentationMapPayloadSegmentationMapEdgeArgs = {
  orderBy?: Maybe<Array<SegmentationMapsOrderBy>>;
};

/** All input for the `deleteSideIntrinsicByNodeId` mutation. */
export type DeleteSideIntrinsicByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `SideIntrinsic` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteSideIntrinsic` mutation. */
export type DeleteSideIntrinsicInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Id generated by database, auto incremented */
  id: Scalars['BigInt'];
};

/** The output of our delete `SideIntrinsic` mutation. */
export type DeleteSideIntrinsicPayload = {
  __typename?: 'DeleteSideIntrinsicPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `SideIntrinsic` that was deleted by this mutation. */
  sideIntrinsic?: Maybe<SideIntrinsic>;
  deletedSideIntrinsicNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `SideIntrinsicsK` that is related to this `SideIntrinsic`. */
  k?: Maybe<SideIntrinsicsK>;
  /** Reads a single `SideIntrinsicsD` that is related to this `SideIntrinsic`. */
  d?: Maybe<SideIntrinsicsD>;
  /** An edge for our `SideIntrinsic`. May be used by Relay 1. */
  sideIntrinsicEdge?: Maybe<SideIntrinsicsEdge>;
};


/** The output of our delete `SideIntrinsic` mutation. */
export type DeleteSideIntrinsicPayloadSideIntrinsicEdgeArgs = {
  orderBy?: Maybe<Array<SideIntrinsicsOrderBy>>;
};

/** All input for the `deleteSideIntrinsicsDByNodeId` mutation. */
export type DeleteSideIntrinsicsDByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `SideIntrinsicsD` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteSideIntrinsicsD` mutation. */
export type DeleteSideIntrinsicsDInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Id generated by database, auto incremented */
  id: Scalars['BigInt'];
};

/** The output of our delete `SideIntrinsicsD` mutation. */
export type DeleteSideIntrinsicsDPayload = {
  __typename?: 'DeleteSideIntrinsicsDPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `SideIntrinsicsD` that was deleted by this mutation. */
  sideIntrinsicsD?: Maybe<SideIntrinsicsD>;
  deletedSideIntrinsicsDNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `SideIntrinsicsD`. May be used by Relay 1. */
  sideIntrinsicsDEdge?: Maybe<SideIntrinsicsDsEdge>;
};


/** The output of our delete `SideIntrinsicsD` mutation. */
export type DeleteSideIntrinsicsDPayloadSideIntrinsicsDEdgeArgs = {
  orderBy?: Maybe<Array<SideIntrinsicsDsOrderBy>>;
};

/** All input for the `deleteSideIntrinsicsKByNodeId` mutation. */
export type DeleteSideIntrinsicsKByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `SideIntrinsicsK` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteSideIntrinsicsK` mutation. */
export type DeleteSideIntrinsicsKInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Id generated by database, auto incremented */
  id: Scalars['BigInt'];
};

/** The output of our delete `SideIntrinsicsK` mutation. */
export type DeleteSideIntrinsicsKPayload = {
  __typename?: 'DeleteSideIntrinsicsKPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `SideIntrinsicsK` that was deleted by this mutation. */
  sideIntrinsicsK?: Maybe<SideIntrinsicsK>;
  deletedSideIntrinsicsKNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `SideIntrinsicsK`. May be used by Relay 1. */
  sideIntrinsicsKEdge?: Maybe<SideIntrinsicsKsEdge>;
};


/** The output of our delete `SideIntrinsicsK` mutation. */
export type DeleteSideIntrinsicsKPayloadSideIntrinsicsKEdgeArgs = {
  orderBy?: Maybe<Array<SideIntrinsicsKsOrderBy>>;
};

/** All input for the `deleteSmallHistogramByNodeId` mutation. */
export type DeleteSmallHistogramByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `SmallHistogram` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteSmallHistogram` mutation. */
export type DeleteSmallHistogramInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Id generated by database, auto incremented */
  id: Scalars['BigInt'];
};

/** The output of our delete `SmallHistogram` mutation. */
export type DeleteSmallHistogramPayload = {
  __typename?: 'DeleteSmallHistogramPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `SmallHistogram` that was deleted by this mutation. */
  smallHistogram?: Maybe<SmallHistogram>;
  deletedSmallHistogramNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `SmallHistogram`. May be used by Relay 1. */
  smallHistogramEdge?: Maybe<SmallHistogramsEdge>;
};


/** The output of our delete `SmallHistogram` mutation. */
export type DeleteSmallHistogramPayloadSmallHistogramEdgeArgs = {
  orderBy?: Maybe<Array<SmallHistogramsOrderBy>>;
};

/** All input for the `deleteStatusMessageByNodeId` mutation. */
export type DeleteStatusMessageByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `StatusMessage` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteStatusMessageHeaderByNodeId` mutation. */
export type DeleteStatusMessageHeaderByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `StatusMessageHeader` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteStatusMessageHeader` mutation. */
export type DeleteStatusMessageHeaderInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Column is auto incremented by databased */
  id: Scalars['BigInt'];
};

/** The output of our delete `StatusMessageHeader` mutation. */
export type DeleteStatusMessageHeaderPayload = {
  __typename?: 'DeleteStatusMessageHeaderPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `StatusMessageHeader` that was deleted by this mutation. */
  statusMessageHeader?: Maybe<StatusMessageHeader>;
  deletedStatusMessageHeaderNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `StatusMessageHeader`. May be used by Relay 1. */
  statusMessageHeaderEdge?: Maybe<StatusMessageHeadersEdge>;
};


/** The output of our delete `StatusMessageHeader` mutation. */
export type DeleteStatusMessageHeaderPayloadStatusMessageHeaderEdgeArgs = {
  orderBy?: Maybe<Array<StatusMessageHeadersOrderBy>>;
};

/** All input for the `deleteStatusMessage` mutation. */
export type DeleteStatusMessageInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Column is auto incremented by database */
  id: Scalars['BigInt'];
};

/** All input for the `deleteStatusMessageMissionStatByNodeId` mutation. */
export type DeleteStatusMessageMissionStatByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `StatusMessageMissionStat` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteStatusMessageMissionStat` mutation. */
export type DeleteStatusMessageMissionStatInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Column is auto incremented by databased */
  id: Scalars['BigInt'];
};

/** The output of our delete `StatusMessageMissionStat` mutation. */
export type DeleteStatusMessageMissionStatPayload = {
  __typename?: 'DeleteStatusMessageMissionStatPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `StatusMessageMissionStat` that was deleted by this mutation. */
  statusMessageMissionStat?: Maybe<StatusMessageMissionStat>;
  deletedStatusMessageMissionStatNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `StatusMessageMissionStat`. May be used by Relay 1. */
  statusMessageMissionStatEdge?: Maybe<StatusMessageMissionStatsEdge>;
};


/** The output of our delete `StatusMessageMissionStat` mutation. */
export type DeleteStatusMessageMissionStatPayloadStatusMessageMissionStatEdgeArgs = {
  orderBy?: Maybe<Array<StatusMessageMissionStatsOrderBy>>;
};

/** The output of our delete `StatusMessage` mutation. */
export type DeleteStatusMessagePayload = {
  __typename?: 'DeleteStatusMessagePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `StatusMessage` that was deleted by this mutation. */
  statusMessage?: Maybe<StatusMessage>;
  deletedStatusMessageNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `StatusMessageHeader` that is related to this `StatusMessage`. */
  header?: Maybe<StatusMessageHeader>;
  /** Reads a single `StatusMessageMissionStat` that is related to this `StatusMessage`. */
  missionStats?: Maybe<StatusMessageMissionStat>;
  /** An edge for our `StatusMessage`. May be used by Relay 1. */
  statusMessageEdge?: Maybe<StatusMessagesEdge>;
};


/** The output of our delete `StatusMessage` mutation. */
export type DeleteStatusMessagePayloadStatusMessageEdgeArgs = {
  orderBy?: Maybe<Array<StatusMessagesOrderBy>>;
};

/** All input for the `deleteStereoExtrinsicByNodeId` mutation. */
export type DeleteStereoExtrinsicByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `StereoExtrinsic` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteStereoExtrinsic` mutation. */
export type DeleteStereoExtrinsicInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Id generated by database, auto incremented */
  id: Scalars['BigInt'];
};

/** The output of our delete `StereoExtrinsic` mutation. */
export type DeleteStereoExtrinsicPayload = {
  __typename?: 'DeleteStereoExtrinsicPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `StereoExtrinsic` that was deleted by this mutation. */
  stereoExtrinsic?: Maybe<StereoExtrinsic>;
  deletedStereoExtrinsicNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `StereoExtrinsicsT` that is related to this `StereoExtrinsic`. */
  t?: Maybe<StereoExtrinsicsT>;
  /** Reads a single `StereoExtrinsicsR` that is related to this `StereoExtrinsic`. */
  r?: Maybe<StereoExtrinsicsR>;
  /** Reads a single `StereoExtrinsicsRRodrigue` that is related to this `StereoExtrinsic`. */
  rRodrigues?: Maybe<StereoExtrinsicsRRodrigue>;
  /** An edge for our `StereoExtrinsic`. May be used by Relay 1. */
  stereoExtrinsicEdge?: Maybe<StereoExtrinsicsEdge>;
};


/** The output of our delete `StereoExtrinsic` mutation. */
export type DeleteStereoExtrinsicPayloadStereoExtrinsicEdgeArgs = {
  orderBy?: Maybe<Array<StereoExtrinsicsOrderBy>>;
};

/** All input for the `deleteStereoExtrinsicsRByNodeId` mutation. */
export type DeleteStereoExtrinsicsRByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `StereoExtrinsicsR` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteStereoExtrinsicsR` mutation. */
export type DeleteStereoExtrinsicsRInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Id generated by database, auto incremented */
  id: Scalars['BigInt'];
};

/** The output of our delete `StereoExtrinsicsR` mutation. */
export type DeleteStereoExtrinsicsRPayload = {
  __typename?: 'DeleteStereoExtrinsicsRPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `StereoExtrinsicsR` that was deleted by this mutation. */
  stereoExtrinsicsR?: Maybe<StereoExtrinsicsR>;
  deletedStereoExtrinsicsRNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `StereoExtrinsicsR`. May be used by Relay 1. */
  stereoExtrinsicsREdge?: Maybe<StereoExtrinsicsRsEdge>;
};


/** The output of our delete `StereoExtrinsicsR` mutation. */
export type DeleteStereoExtrinsicsRPayloadStereoExtrinsicsREdgeArgs = {
  orderBy?: Maybe<Array<StereoExtrinsicsRsOrderBy>>;
};

/** All input for the `deleteStereoExtrinsicsRRodrigueByNodeId` mutation. */
export type DeleteStereoExtrinsicsRRodrigueByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `StereoExtrinsicsRRodrigue` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteStereoExtrinsicsRRodrigue` mutation. */
export type DeleteStereoExtrinsicsRRodrigueInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Id generated by database, auto incremented */
  id: Scalars['BigInt'];
};

/** The output of our delete `StereoExtrinsicsRRodrigue` mutation. */
export type DeleteStereoExtrinsicsRRodriguePayload = {
  __typename?: 'DeleteStereoExtrinsicsRRodriguePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `StereoExtrinsicsRRodrigue` that was deleted by this mutation. */
  stereoExtrinsicsRRodrigue?: Maybe<StereoExtrinsicsRRodrigue>;
  deletedStereoExtrinsicsRRodrigueNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `StereoExtrinsicsRRodrigue`. May be used by Relay 1. */
  stereoExtrinsicsRRodrigueEdge?: Maybe<StereoExtrinsicsRRodriguesEdge>;
};


/** The output of our delete `StereoExtrinsicsRRodrigue` mutation. */
export type DeleteStereoExtrinsicsRRodriguePayloadStereoExtrinsicsRRodrigueEdgeArgs = {
  orderBy?: Maybe<Array<StereoExtrinsicsRRodriguesOrderBy>>;
};

/** All input for the `deleteStereoExtrinsicsTByNodeId` mutation. */
export type DeleteStereoExtrinsicsTByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `StereoExtrinsicsT` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteStereoExtrinsicsT` mutation. */
export type DeleteStereoExtrinsicsTInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Id generated by database, auto incremented */
  id: Scalars['BigInt'];
};

/** The output of our delete `StereoExtrinsicsT` mutation. */
export type DeleteStereoExtrinsicsTPayload = {
  __typename?: 'DeleteStereoExtrinsicsTPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `StereoExtrinsicsT` that was deleted by this mutation. */
  stereoExtrinsicsT?: Maybe<StereoExtrinsicsT>;
  deletedStereoExtrinsicsTNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `StereoExtrinsicsT`. May be used by Relay 1. */
  stereoExtrinsicsTEdge?: Maybe<StereoExtrinsicsTsEdge>;
};


/** The output of our delete `StereoExtrinsicsT` mutation. */
export type DeleteStereoExtrinsicsTPayloadStereoExtrinsicsTEdgeArgs = {
  orderBy?: Maybe<Array<StereoExtrinsicsTsOrderBy>>;
};

/** All input for the `deleteTestByNodeId` mutation. */
export type DeleteTestByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Test` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteTest` mutation. */
export type DeleteTestInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `Test` mutation. */
export type DeleteTestPayload = {
  __typename?: 'DeleteTestPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Test` that was deleted by this mutation. */
  test?: Maybe<Test>;
  deletedTestNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Test`. May be used by Relay 1. */
  testEdge?: Maybe<TestsEdge>;
};


/** The output of our delete `Test` mutation. */
export type DeleteTestPayloadTestEdgeArgs = {
  orderBy?: Maybe<Array<TestsOrderBy>>;
};

/** All input for the `deleteTopicCategoryByNodeId` mutation. */
export type DeleteTopicCategoryByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `TopicCategory` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteTopicCategory` mutation. */
export type DeleteTopicCategoryInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Autoincremented id of the category */
  id: Scalars['BigInt'];
};

/** The output of our delete `TopicCategory` mutation. */
export type DeleteTopicCategoryPayload = {
  __typename?: 'DeleteTopicCategoryPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `TopicCategory` that was deleted by this mutation. */
  topicCategory?: Maybe<TopicCategory>;
  deletedTopicCategoryNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `TopicCategory`. May be used by Relay 1. */
  topicCategoryEdge?: Maybe<TopicCategoriesEdge>;
};


/** The output of our delete `TopicCategory` mutation. */
export type DeleteTopicCategoryPayloadTopicCategoryEdgeArgs = {
  orderBy?: Maybe<Array<TopicCategoriesOrderBy>>;
};

/** All input for the `deleteTractorExtrinsicByNodeId` mutation. */
export type DeleteTractorExtrinsicByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `TractorExtrinsic` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteTractorExtrinsic` mutation. */
export type DeleteTractorExtrinsicInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Id generated by database, auto incremented */
  id: Scalars['BigInt'];
};

/** The output of our delete `TractorExtrinsic` mutation. */
export type DeleteTractorExtrinsicPayload = {
  __typename?: 'DeleteTractorExtrinsicPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `TractorExtrinsic` that was deleted by this mutation. */
  tractorExtrinsic?: Maybe<TractorExtrinsic>;
  deletedTractorExtrinsicNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `TractorExtrinsicsT` that is related to this `TractorExtrinsic`. */
  t?: Maybe<TractorExtrinsicsT>;
  /** Reads a single `TractorExtrinsicsR` that is related to this `TractorExtrinsic`. */
  r?: Maybe<TractorExtrinsicsR>;
  /** Reads a single `TractorExtrinsicsRRodrigue` that is related to this `TractorExtrinsic`. */
  rRodrigues?: Maybe<TractorExtrinsicsRRodrigue>;
  /** An edge for our `TractorExtrinsic`. May be used by Relay 1. */
  tractorExtrinsicEdge?: Maybe<TractorExtrinsicsEdge>;
};


/** The output of our delete `TractorExtrinsic` mutation. */
export type DeleteTractorExtrinsicPayloadTractorExtrinsicEdgeArgs = {
  orderBy?: Maybe<Array<TractorExtrinsicsOrderBy>>;
};

/** All input for the `deleteTractorExtrinsicsRByNodeId` mutation. */
export type DeleteTractorExtrinsicsRByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `TractorExtrinsicsR` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteTractorExtrinsicsR` mutation. */
export type DeleteTractorExtrinsicsRInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Id generated by database, auto incremented */
  id: Scalars['BigInt'];
};

/** The output of our delete `TractorExtrinsicsR` mutation. */
export type DeleteTractorExtrinsicsRPayload = {
  __typename?: 'DeleteTractorExtrinsicsRPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `TractorExtrinsicsR` that was deleted by this mutation. */
  tractorExtrinsicsR?: Maybe<TractorExtrinsicsR>;
  deletedTractorExtrinsicsRNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `TractorExtrinsicsR`. May be used by Relay 1. */
  tractorExtrinsicsREdge?: Maybe<TractorExtrinsicsRsEdge>;
};


/** The output of our delete `TractorExtrinsicsR` mutation. */
export type DeleteTractorExtrinsicsRPayloadTractorExtrinsicsREdgeArgs = {
  orderBy?: Maybe<Array<TractorExtrinsicsRsOrderBy>>;
};

/** All input for the `deleteTractorExtrinsicsRRodrigueByNodeId` mutation. */
export type DeleteTractorExtrinsicsRRodrigueByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `TractorExtrinsicsRRodrigue` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteTractorExtrinsicsRRodrigue` mutation. */
export type DeleteTractorExtrinsicsRRodrigueInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Id generated by database, auto incremented */
  id: Scalars['BigInt'];
};

/** The output of our delete `TractorExtrinsicsRRodrigue` mutation. */
export type DeleteTractorExtrinsicsRRodriguePayload = {
  __typename?: 'DeleteTractorExtrinsicsRRodriguePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `TractorExtrinsicsRRodrigue` that was deleted by this mutation. */
  tractorExtrinsicsRRodrigue?: Maybe<TractorExtrinsicsRRodrigue>;
  deletedTractorExtrinsicsRRodrigueNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `TractorExtrinsicsRRodrigue`. May be used by Relay 1. */
  tractorExtrinsicsRRodrigueEdge?: Maybe<TractorExtrinsicsRRodriguesEdge>;
};


/** The output of our delete `TractorExtrinsicsRRodrigue` mutation. */
export type DeleteTractorExtrinsicsRRodriguePayloadTractorExtrinsicsRRodrigueEdgeArgs = {
  orderBy?: Maybe<Array<TractorExtrinsicsRRodriguesOrderBy>>;
};

/** All input for the `deleteTractorExtrinsicsTByNodeId` mutation. */
export type DeleteTractorExtrinsicsTByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `TractorExtrinsicsT` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteTractorExtrinsicsT` mutation. */
export type DeleteTractorExtrinsicsTInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Id generated by database, auto incremented */
  id: Scalars['BigInt'];
};

/** The output of our delete `TractorExtrinsicsT` mutation. */
export type DeleteTractorExtrinsicsTPayload = {
  __typename?: 'DeleteTractorExtrinsicsTPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `TractorExtrinsicsT` that was deleted by this mutation. */
  tractorExtrinsicsT?: Maybe<TractorExtrinsicsT>;
  deletedTractorExtrinsicsTNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `TractorExtrinsicsT`. May be used by Relay 1. */
  tractorExtrinsicsTEdge?: Maybe<TractorExtrinsicsTsEdge>;
};


/** The output of our delete `TractorExtrinsicsT` mutation. */
export type DeleteTractorExtrinsicsTPayloadTractorExtrinsicsTEdgeArgs = {
  orderBy?: Maybe<Array<TractorExtrinsicsTsOrderBy>>;
};

/** All input for the `deleteVehicleLogByNodeId` mutation. */
export type DeleteVehicleLogByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `VehicleLog` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteVehicleLog` mutation. */
export type DeleteVehicleLogInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** This is the id of the log and its autoincremented */
  id: Scalars['BigInt'];
};

/** All input for the `deleteVehicleLogMessageByNodeId` mutation. */
export type DeleteVehicleLogMessageByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `VehicleLogMessage` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteVehicleLogMessage` mutation. */
export type DeleteVehicleLogMessageInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** This is the id of the log and its autoincremented */
  id: Scalars['BigInt'];
};

/** The output of our delete `VehicleLogMessage` mutation. */
export type DeleteVehicleLogMessagePayload = {
  __typename?: 'DeleteVehicleLogMessagePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `VehicleLogMessage` that was deleted by this mutation. */
  vehicleLogMessage?: Maybe<VehicleLogMessage>;
  deletedVehicleLogMessageNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `VehicleLogMessageStamp` that is related to this `VehicleLogMessage`. */
  stamp?: Maybe<VehicleLogMessageStamp>;
  /** An edge for our `VehicleLogMessage`. May be used by Relay 1. */
  vehicleLogMessageEdge?: Maybe<VehicleLogMessagesEdge>;
};


/** The output of our delete `VehicleLogMessage` mutation. */
export type DeleteVehicleLogMessagePayloadVehicleLogMessageEdgeArgs = {
  orderBy?: Maybe<Array<VehicleLogMessagesOrderBy>>;
};

/** All input for the `deleteVehicleLogMessageStampByNodeId` mutation. */
export type DeleteVehicleLogMessageStampByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `VehicleLogMessageStamp` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteVehicleLogMessageStamp` mutation. */
export type DeleteVehicleLogMessageStampInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** This is the id of the log and its autoincremented */
  id: Scalars['BigInt'];
};

/** The output of our delete `VehicleLogMessageStamp` mutation. */
export type DeleteVehicleLogMessageStampPayload = {
  __typename?: 'DeleteVehicleLogMessageStampPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `VehicleLogMessageStamp` that was deleted by this mutation. */
  vehicleLogMessageStamp?: Maybe<VehicleLogMessageStamp>;
  deletedVehicleLogMessageStampNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `VehicleLogMessageStamp`. May be used by Relay 1. */
  vehicleLogMessageStampEdge?: Maybe<VehicleLogMessageStampsEdge>;
};


/** The output of our delete `VehicleLogMessageStamp` mutation. */
export type DeleteVehicleLogMessageStampPayloadVehicleLogMessageStampEdgeArgs = {
  orderBy?: Maybe<Array<VehicleLogMessageStampsOrderBy>>;
};

/** The output of our delete `VehicleLog` mutation. */
export type DeleteVehicleLogPayload = {
  __typename?: 'DeleteVehicleLogPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `VehicleLog` that was deleted by this mutation. */
  vehicleLog?: Maybe<VehicleLog>;
  deletedVehicleLogNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `VehicleLogMessage` that is related to this `VehicleLog`. */
  message?: Maybe<VehicleLogMessage>;
  /** Reads a single `Vehicle` that is related to this `VehicleLog`. */
  vehicle?: Maybe<Vehicle>;
  /** Reads a single `Topic` that is related to this `VehicleLog`. */
  topic?: Maybe<Topic>;
  /** An edge for our `VehicleLog`. May be used by Relay 1. */
  vehicleLogEdge?: Maybe<VehicleLogsEdge>;
};


/** The output of our delete `VehicleLog` mutation. */
export type DeleteVehicleLogPayloadVehicleLogEdgeArgs = {
  orderBy?: Maybe<Array<VehicleLogsOrderBy>>;
};

/** All input for the `deleteVehicleStateByCode` mutation. */
export type DeleteVehicleStateByCodeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  code: Scalars['Int'];
};

/** All input for the `deleteVehicleStateByName` mutation. */
export type DeleteVehicleStateByNameInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The name of vehicle state type */
  name: Scalars['String'];
};

/** All input for the `deleteVehicleStateByNodeId` mutation. */
export type DeleteVehicleStateByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `VehicleState` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteVehicleState` mutation. */
export type DeleteVehicleStateInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The ID of vehicle state type assigned by the database */
  id: Scalars['BigInt'];
};

/** The output of our delete `VehicleState` mutation. */
export type DeleteVehicleStatePayload = {
  __typename?: 'DeleteVehicleStatePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `VehicleState` that was deleted by this mutation. */
  vehicleState?: Maybe<VehicleState>;
  deletedVehicleStateNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `VehicleState`. May be used by Relay 1. */
  vehicleStateEdge?: Maybe<VehicleStatesEdge>;
};


/** The output of our delete `VehicleState` mutation. */
export type DeleteVehicleStatePayloadVehicleStateEdgeArgs = {
  orderBy?: Maybe<Array<VehicleStatesOrderBy>>;
};

/** All input for the `deleteVehicleStateReasonByNodeId` mutation. */
export type DeleteVehicleStateReasonByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `VehicleStateReason` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteVehicleStateReason` mutation. */
export type DeleteVehicleStateReasonInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The ID of the state reasone assigned by the database */
  id: Scalars['BigInt'];
};

/** The output of our delete `VehicleStateReason` mutation. */
export type DeleteVehicleStateReasonPayload = {
  __typename?: 'DeleteVehicleStateReasonPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `VehicleStateReason` that was deleted by this mutation. */
  vehicleStateReason?: Maybe<VehicleStateReason>;
  deletedVehicleStateReasonNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `VehicleStateReason`. May be used by Relay 1. */
  vehicleStateReasonEdge?: Maybe<VehicleStateReasonsEdge>;
};


/** The output of our delete `VehicleStateReason` mutation. */
export type DeleteVehicleStateReasonPayloadVehicleStateReasonEdgeArgs = {
  orderBy?: Maybe<Array<VehicleStateReasonsOrderBy>>;
};

/** All input for the `deleteVehicleStatusByNodeId` mutation. */
export type DeleteVehicleStatusByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `VehicleStatus` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteVehicleStatusDetailByNodeId` mutation. */
export type DeleteVehicleStatusDetailByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `VehicleStatusDetail` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteVehicleStatusDetail` mutation. */
export type DeleteVehicleStatusDetailInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `VehicleStatusDetail` mutation. */
export type DeleteVehicleStatusDetailPayload = {
  __typename?: 'DeleteVehicleStatusDetailPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `VehicleStatusDetail` that was deleted by this mutation. */
  vehicleStatusDetail?: Maybe<VehicleStatusDetail>;
  deletedVehicleStatusDetailNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `VehicleStatus` that is related to this `VehicleStatusDetail`. */
  vehicleStatus?: Maybe<VehicleStatus>;
  /** Reads a single `VehicleStateReason` that is related to this `VehicleStatusDetail`. */
  vehicleStatusReason?: Maybe<VehicleStateReason>;
  /** An edge for our `VehicleStatusDetail`. May be used by Relay 1. */
  vehicleStatusDetailEdge?: Maybe<VehicleStatusDetailsEdge>;
};


/** The output of our delete `VehicleStatusDetail` mutation. */
export type DeleteVehicleStatusDetailPayloadVehicleStatusDetailEdgeArgs = {
  orderBy?: Maybe<Array<VehicleStatusDetailsOrderBy>>;
};

/** All input for the `deleteVehicleStatus` mutation. */
export type DeleteVehicleStatusInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The ID of vehicles status assigned by the database */
  id: Scalars['BigInt'];
};

/** The output of our delete `VehicleStatus` mutation. */
export type DeleteVehicleStatusPayload = {
  __typename?: 'DeleteVehicleStatusPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `VehicleStatus` that was deleted by this mutation. */
  vehicleStatus?: Maybe<VehicleStatus>;
  deletedVehicleStatusNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Vehicle` that is related to this `VehicleStatus`. */
  vehicle?: Maybe<Vehicle>;
  /** Reads a single `VehicleState` that is related to this `VehicleStatus`. */
  state?: Maybe<VehicleState>;
  /** Reads a single `StatusMessage` that is related to this `VehicleStatus`. */
  statusMessage?: Maybe<StatusMessage>;
  /** Reads a single `Topic` that is related to this `VehicleStatus`. */
  topic?: Maybe<Topic>;
  /** An edge for our `VehicleStatus`. May be used by Relay 1. */
  vehicleStatusEdge?: Maybe<VehicleStatusesEdge>;
};


/** The output of our delete `VehicleStatus` mutation. */
export type DeleteVehicleStatusPayloadVehicleStatusEdgeArgs = {
  orderBy?: Maybe<Array<VehicleStatusesOrderBy>>;
};

/** All input for the `deleteVehiclesOnlineByNodeId` mutation. */
export type DeleteVehiclesOnlineByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `VehiclesOnline` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteVehiclesOnlineByVehicleId` mutation. */
export type DeleteVehiclesOnlineByVehicleIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The vehicle id of vehicle online */
  vehicleId: Scalars['BigInt'];
};

/** All input for the `deleteVehiclesOnline` mutation. */
export type DeleteVehiclesOnlineInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The ID of vehicles online assigned by the database */
  id: Scalars['BigInt'];
};

/** The output of our delete `VehiclesOnline` mutation. */
export type DeleteVehiclesOnlinePayload = {
  __typename?: 'DeleteVehiclesOnlinePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `VehiclesOnline` that was deleted by this mutation. */
  vehiclesOnline?: Maybe<VehiclesOnline>;
  deletedVehiclesOnlineNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Vehicle` that is related to this `VehiclesOnline`. */
  vehicle?: Maybe<Vehicle>;
  /** An edge for our `VehiclesOnline`. May be used by Relay 1. */
  vehiclesOnlineEdge?: Maybe<VehiclesOnlinesEdge>;
};


/** The output of our delete `VehiclesOnline` mutation. */
export type DeleteVehiclesOnlinePayloadVehiclesOnlineEdgeArgs = {
  orderBy?: Maybe<Array<VehiclesOnlinesOrderBy>>;
};

/** Table full histogram from camera */
export type FullHistogram = Node & {
  __typename?: 'FullHistogram';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  /** Id generated by database, auto incremented */
  id: Scalars['BigInt'];
  /** data for full histogram */
  data: Scalars['String'];
  /** Reads and enables pagination through a set of `CameraHistogram`. */
  cameraHistograms: CameraHistogramsConnection;
};


/** Table full histogram from camera */
export type FullHistogramCameraHistogramsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CameraHistogramsOrderBy>>;
  condition?: Maybe<CameraHistogramCondition>;
  filter?: Maybe<CameraHistogramFilter>;
};

/**
 * A condition to be used against `FullHistogram` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type FullHistogramCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `data` field. */
  data?: Maybe<Scalars['String']>;
};

/** A filter to be used against `FullHistogram` object types. All fields are combined with a logical ‘and.’ */
export type FullHistogramFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `data` field. */
  data?: Maybe<StringFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<FullHistogramFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<FullHistogramFilter>>;
  /** Negates the expression. */
  not?: Maybe<FullHistogramFilter>;
};

/** A connection to a list of `FullHistogram` values. */
export type FullHistogramsConnection = {
  __typename?: 'FullHistogramsConnection';
  /** A list of `FullHistogram` objects. */
  nodes: Array<Maybe<FullHistogram>>;
  /** A list of edges which contains the `FullHistogram` and cursor to aid in pagination. */
  edges: Array<FullHistogramsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `FullHistogram` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `FullHistogram` edge in the connection. */
export type FullHistogramsEdge = {
  __typename?: 'FullHistogramsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `FullHistogram` at the end of the edge. */
  node?: Maybe<FullHistogram>;
};

/** Methods to use when ordering `FullHistogram`. */
export enum FullHistogramsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  DataAsc = 'DATA_ASC',
  DataDesc = 'DATA_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/** Table image from camera */
export type Image = Node & {
  __typename?: 'Image';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  /** Id generated by database, auto incremented */
  id: Scalars['BigInt'];
  /** header_id of image */
  headerId: Scalars['BigInt'];
  /** height of image */
  height: Scalars['Int'];
  /** width of image */
  width: Scalars['Int'];
  /** encoding of image */
  encoding: Scalars['String'];
  /** is_bigendian image */
  isBigendian: Scalars['Int'];
  /** number of steps in image */
  step: Scalars['BigInt'];
  /** data of image */
  dataId: Scalars['BigInt'];
  /** Reads a single `ImageHeader` that is related to this `Image`. */
  header?: Maybe<ImageHeader>;
  /** Reads a single `ImageDatum` that is related to this `Image`. */
  data?: Maybe<ImageDatum>;
  /** Reads and enables pagination through a set of `CameraPairMessage`. */
  cameraPairMessagesByLeftImageId: CameraPairMessagesConnection;
  /** Reads and enables pagination through a set of `CameraPairMessage`. */
  cameraPairMessagesByRightImageId: CameraPairMessagesConnection;
  /** Reads and enables pagination through a set of `CameraMessage`. */
  cameraMessages: CameraMessagesConnection;
};


/** Table image from camera */
export type ImageCameraPairMessagesByLeftImageIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CameraPairMessagesOrderBy>>;
  condition?: Maybe<CameraPairMessageCondition>;
  filter?: Maybe<CameraPairMessageFilter>;
};


/** Table image from camera */
export type ImageCameraPairMessagesByRightImageIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CameraPairMessagesOrderBy>>;
  condition?: Maybe<CameraPairMessageCondition>;
  filter?: Maybe<CameraPairMessageFilter>;
};


/** Table image from camera */
export type ImageCameraMessagesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CameraMessagesOrderBy>>;
  condition?: Maybe<CameraMessageCondition>;
  filter?: Maybe<CameraMessageFilter>;
};

/** A condition to be used against `Image` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type ImageCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `headerId` field. */
  headerId?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `height` field. */
  height?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `width` field. */
  width?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `encoding` field. */
  encoding?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `isBigendian` field. */
  isBigendian?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `step` field. */
  step?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `dataId` field. */
  dataId?: Maybe<Scalars['BigInt']>;
};

/** A connection to a list of `ImageDatum` values. */
export type ImageDataConnection = {
  __typename?: 'ImageDataConnection';
  /** A list of `ImageDatum` objects. */
  nodes: Array<Maybe<ImageDatum>>;
  /** A list of edges which contains the `ImageDatum` and cursor to aid in pagination. */
  edges: Array<ImageDataEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ImageDatum` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `ImageDatum` edge in the connection. */
export type ImageDataEdge = {
  __typename?: 'ImageDataEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `ImageDatum` at the end of the edge. */
  node?: Maybe<ImageDatum>;
};

/** Methods to use when ordering `ImageDatum`. */
export enum ImageDataOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  DataAsc = 'DATA_ASC',
  DataDesc = 'DATA_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/** Table image data from camera */
export type ImageDatum = Node & {
  __typename?: 'ImageDatum';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  /** Id generated by database, auto incremented */
  id: Scalars['BigInt'];
  /** image data */
  data: Scalars['String'];
  /** Reads and enables pagination through a set of `Image`. */
  imagesByDataId: ImagesConnection;
};


/** Table image data from camera */
export type ImageDatumImagesByDataIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ImagesOrderBy>>;
  condition?: Maybe<ImageCondition>;
  filter?: Maybe<ImageFilter>;
};

/**
 * A condition to be used against `ImageDatum` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type ImageDatumCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `data` field. */
  data?: Maybe<Scalars['String']>;
};

/** A filter to be used against `ImageDatum` object types. All fields are combined with a logical ‘and.’ */
export type ImageDatumFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `data` field. */
  data?: Maybe<StringFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<ImageDatumFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<ImageDatumFilter>>;
  /** Negates the expression. */
  not?: Maybe<ImageDatumFilter>;
};

/** A filter to be used against `Image` object types. All fields are combined with a logical ‘and.’ */
export type ImageFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `headerId` field. */
  headerId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `height` field. */
  height?: Maybe<IntFilter>;
  /** Filter by the object’s `width` field. */
  width?: Maybe<IntFilter>;
  /** Filter by the object’s `encoding` field. */
  encoding?: Maybe<StringFilter>;
  /** Filter by the object’s `isBigendian` field. */
  isBigendian?: Maybe<IntFilter>;
  /** Filter by the object’s `step` field. */
  step?: Maybe<BigIntFilter>;
  /** Filter by the object’s `dataId` field. */
  dataId?: Maybe<BigIntFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<ImageFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<ImageFilter>>;
  /** Negates the expression. */
  not?: Maybe<ImageFilter>;
};

/** Table image descriptor from camera */
export type ImageHeader = Node & {
  __typename?: 'ImageHeader';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  /** Id generated by database, auto incremented */
  id: Scalars['BigInt'];
  /** stamp_id of image */
  stampId: Scalars['BigInt'];
  /** frame_id of image */
  frameId: Scalars['String'];
  /** Reads a single `ImageHeaderStamp` that is related to this `ImageHeader`. */
  stamp?: Maybe<ImageHeaderStamp>;
  /** Reads and enables pagination through a set of `Image`. */
  imagesByHeaderId: ImagesConnection;
};


/** Table image descriptor from camera */
export type ImageHeaderImagesByHeaderIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ImagesOrderBy>>;
  condition?: Maybe<ImageCondition>;
  filter?: Maybe<ImageFilter>;
};

/**
 * A condition to be used against `ImageHeader` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type ImageHeaderCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `stampId` field. */
  stampId?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `frameId` field. */
  frameId?: Maybe<Scalars['String']>;
};

/** A filter to be used against `ImageHeader` object types. All fields are combined with a logical ‘and.’ */
export type ImageHeaderFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `stampId` field. */
  stampId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `frameId` field. */
  frameId?: Maybe<StringFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<ImageHeaderFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<ImageHeaderFilter>>;
  /** Negates the expression. */
  not?: Maybe<ImageHeaderFilter>;
};

/** Table image header stamp from camera */
export type ImageHeaderStamp = Node & {
  __typename?: 'ImageHeaderStamp';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  /** Id generated by database, auto incremented */
  id: Scalars['BigInt'];
  /** image time in sec */
  sec: Scalars['Int'];
  /** image time in nanosec */
  nanosec: Scalars['Int'];
  /** Reads and enables pagination through a set of `ImageHeader`. */
  imageHeadersByStampId: ImageHeadersConnection;
};


/** Table image header stamp from camera */
export type ImageHeaderStampImageHeadersByStampIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ImageHeadersOrderBy>>;
  condition?: Maybe<ImageHeaderCondition>;
  filter?: Maybe<ImageHeaderFilter>;
};

/**
 * A condition to be used against `ImageHeaderStamp` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type ImageHeaderStampCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `sec` field. */
  sec?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `nanosec` field. */
  nanosec?: Maybe<Scalars['Int']>;
};

/** A filter to be used against `ImageHeaderStamp` object types. All fields are combined with a logical ‘and.’ */
export type ImageHeaderStampFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `sec` field. */
  sec?: Maybe<IntFilter>;
  /** Filter by the object’s `nanosec` field. */
  nanosec?: Maybe<IntFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<ImageHeaderStampFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<ImageHeaderStampFilter>>;
  /** Negates the expression. */
  not?: Maybe<ImageHeaderStampFilter>;
};

/** A connection to a list of `ImageHeaderStamp` values. */
export type ImageHeaderStampsConnection = {
  __typename?: 'ImageHeaderStampsConnection';
  /** A list of `ImageHeaderStamp` objects. */
  nodes: Array<Maybe<ImageHeaderStamp>>;
  /** A list of edges which contains the `ImageHeaderStamp` and cursor to aid in pagination. */
  edges: Array<ImageHeaderStampsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ImageHeaderStamp` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `ImageHeaderStamp` edge in the connection. */
export type ImageHeaderStampsEdge = {
  __typename?: 'ImageHeaderStampsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `ImageHeaderStamp` at the end of the edge. */
  node?: Maybe<ImageHeaderStamp>;
};

/** Methods to use when ordering `ImageHeaderStamp`. */
export enum ImageHeaderStampsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  SecAsc = 'SEC_ASC',
  SecDesc = 'SEC_DESC',
  NanosecAsc = 'NANOSEC_ASC',
  NanosecDesc = 'NANOSEC_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/** A connection to a list of `ImageHeader` values. */
export type ImageHeadersConnection = {
  __typename?: 'ImageHeadersConnection';
  /** A list of `ImageHeader` objects. */
  nodes: Array<Maybe<ImageHeader>>;
  /** A list of edges which contains the `ImageHeader` and cursor to aid in pagination. */
  edges: Array<ImageHeadersEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ImageHeader` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `ImageHeader` edge in the connection. */
export type ImageHeadersEdge = {
  __typename?: 'ImageHeadersEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `ImageHeader` at the end of the edge. */
  node?: Maybe<ImageHeader>;
};

/** Methods to use when ordering `ImageHeader`. */
export enum ImageHeadersOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  StampIdAsc = 'STAMP_ID_ASC',
  StampIdDesc = 'STAMP_ID_DESC',
  FrameIdAsc = 'FRAME_ID_ASC',
  FrameIdDesc = 'FRAME_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/** A connection to a list of `Image` values. */
export type ImagesConnection = {
  __typename?: 'ImagesConnection';
  /** A list of `Image` objects. */
  nodes: Array<Maybe<Image>>;
  /** A list of edges which contains the `Image` and cursor to aid in pagination. */
  edges: Array<ImagesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Image` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `Image` edge in the connection. */
export type ImagesEdge = {
  __typename?: 'ImagesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Image` at the end of the edge. */
  node?: Maybe<Image>;
};

/** Methods to use when ordering `Image`. */
export enum ImagesOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  HeaderIdAsc = 'HEADER_ID_ASC',
  HeaderIdDesc = 'HEADER_ID_DESC',
  HeightAsc = 'HEIGHT_ASC',
  HeightDesc = 'HEIGHT_DESC',
  WidthAsc = 'WIDTH_ASC',
  WidthDesc = 'WIDTH_DESC',
  EncodingAsc = 'ENCODING_ASC',
  EncodingDesc = 'ENCODING_DESC',
  IsBigendianAsc = 'IS_BIGENDIAN_ASC',
  IsBigendianDesc = 'IS_BIGENDIAN_DESC',
  StepAsc = 'STEP_ASC',
  StepDesc = 'STEP_DESC',
  DataIdAsc = 'DATA_ID_ASC',
  DataIdDesc = 'DATA_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/** A filter to be used against Int fields. All fields are combined with a logical ‘and.’ */
export type IntFilter = {
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: Maybe<Scalars['Boolean']>;
  /** Equal to the specified value. */
  equalTo?: Maybe<Scalars['Int']>;
  /** Not equal to the specified value. */
  notEqualTo?: Maybe<Scalars['Int']>;
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: Maybe<Scalars['Int']>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: Maybe<Scalars['Int']>;
  /** Included in the specified list. */
  in?: Maybe<Array<Scalars['Int']>>;
  /** Not included in the specified list. */
  notIn?: Maybe<Array<Scalars['Int']>>;
  /** Less than the specified value. */
  lessThan?: Maybe<Scalars['Int']>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: Maybe<Scalars['Int']>;
  /** Greater than the specified value. */
  greaterThan?: Maybe<Scalars['Int']>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: Maybe<Scalars['Int']>;
};

export type ListenPayload = {
  __typename?: 'ListenPayload';
  /** Our root query field type. Allows us to run any query from our subscription payload. */
  query?: Maybe<Query>;
  relatedNode?: Maybe<Node>;
  relatedNodeId?: Maybe<Scalars['ID']>;
};

/** The root mutation type which contains root level fields which mutate data. */
export type Mutation = {
  __typename?: 'Mutation';
  /** Creates a single `VehicleTopic`. */
  createVehicleTopic?: Maybe<CreateVehicleTopicPayload>;
  /** Creates a single `VehicleType`. */
  createVehicleType?: Maybe<CreateVehicleTypePayload>;
  /** Creates a single `Vehicle`. */
  createVehicle?: Maybe<CreateVehiclePayload>;
  /** Creates a single `VehiclesOffline`. */
  createVehiclesOffline?: Maybe<CreateVehiclesOfflinePayload>;
  /** Creates a single `VehiclesOnline`. */
  createVehiclesOnline?: Maybe<CreateVehiclesOnlinePayload>;
  /** Creates a single `TopicCategory`. */
  createTopicCategory?: Maybe<CreateTopicCategoryPayload>;
  /** Creates a single `TopicType`. */
  createTopicType?: Maybe<CreateTopicTypePayload>;
  /** Creates a single `Topic`. */
  createTopic?: Maybe<CreateTopicPayload>;
  /** Creates a single `Test`. */
  createTest?: Maybe<CreateTestPayload>;
  /** Creates a single `VehicleLogMessageStamp`. */
  createVehicleLogMessageStamp?: Maybe<CreateVehicleLogMessageStampPayload>;
  /** Creates a single `VehicleLogMessage`. */
  createVehicleLogMessage?: Maybe<CreateVehicleLogMessagePayload>;
  /** Creates a single `VehicleLog`. */
  createVehicleLog?: Maybe<CreateVehicleLogPayload>;
  /** Creates a single `Starfire`. */
  createStarfire?: Maybe<CreateStarfirePayload>;
  /** Creates a single `StarfireHeader`. */
  createStarfireHeader?: Maybe<CreateStarfireHeaderPayload>;
  /** Creates a single `StarfireMessage`. */
  createStarfireMessage?: Maybe<CreateStarfireMessagePayload>;
  /** Creates a single `Camera`. */
  createCamera?: Maybe<CreateCameraPayload>;
  /** Creates a single `CameraHistogram`. */
  createCameraHistogram?: Maybe<CreateCameraHistogramPayload>;
  /** Creates a single `CameraMessage`. */
  createCameraMessage?: Maybe<CreateCameraMessagePayload>;
  /** Creates a single `CameraMessageHeader`. */
  createCameraMessageHeader?: Maybe<CreateCameraMessageHeaderPayload>;
  /** Creates a single `CameraMeta`. */
  createCameraMeta?: Maybe<CreateCameraMetaPayload>;
  /** Creates a single `CameraMetaE`. */
  createCameraMetaE?: Maybe<CreateCameraMetaEPayload>;
  /** Creates a single `CameraMetaF`. */
  createCameraMetaF?: Maybe<CreateCameraMetaFPayload>;
  /** Creates a single `CameraMetaP1`. */
  createCameraMetaP1?: Maybe<CreateCameraMetaP1Payload>;
  /** Creates a single `CameraMetaP2`. */
  createCameraMetaP2?: Maybe<CreateCameraMetaP2Payload>;
  /** Creates a single `CameraMetaQ`. */
  createCameraMetaQ?: Maybe<CreateCameraMetaQPayload>;
  /** Creates a single `CameraMetaR1`. */
  createCameraMetaR1?: Maybe<CreateCameraMetaR1Payload>;
  /** Creates a single `CameraMetaR2`. */
  createCameraMetaR2?: Maybe<CreateCameraMetaR2Payload>;
  /** Creates a single `CameraPair`. */
  createCameraPair?: Maybe<CreateCameraPairPayload>;
  /** Creates a single `CameraPairMessage`. */
  createCameraPairMessage?: Maybe<CreateCameraPairMessagePayload>;
  /** Creates a single `CameraRoi`. */
  createCameraRoi?: Maybe<CreateCameraRoiPayload>;
  /** Creates a single `FullHistogram`. */
  createFullHistogram?: Maybe<CreateFullHistogramPayload>;
  /** Creates a single `ImageDatum`. */
  createImageDatum?: Maybe<CreateImageDatumPayload>;
  /** Creates a single `ImageHeader`. */
  createImageHeader?: Maybe<CreateImageHeaderPayload>;
  /** Creates a single `ImageHeaderStamp`. */
  createImageHeaderStamp?: Maybe<CreateImageHeaderStampPayload>;
  /** Creates a single `Image`. */
  createImage?: Maybe<CreateImagePayload>;
  /** Creates a single `SegmentationMap`. */
  createSegmentationMap?: Maybe<CreateSegmentationMapPayload>;
  /** Creates a single `SideIntrinsic`. */
  createSideIntrinsic?: Maybe<CreateSideIntrinsicPayload>;
  /** Creates a single `SideIntrinsicsD`. */
  createSideIntrinsicsD?: Maybe<CreateSideIntrinsicsDPayload>;
  /** Creates a single `SideIntrinsicsK`. */
  createSideIntrinsicsK?: Maybe<CreateSideIntrinsicsKPayload>;
  /** Creates a single `SmallHistogram`. */
  createSmallHistogram?: Maybe<CreateSmallHistogramPayload>;
  /** Creates a single `StereoExtrinsic`. */
  createStereoExtrinsic?: Maybe<CreateStereoExtrinsicPayload>;
  /** Creates a single `StereoExtrinsicsR`. */
  createStereoExtrinsicsR?: Maybe<CreateStereoExtrinsicsRPayload>;
  /** Creates a single `StereoExtrinsicsRRodrigue`. */
  createStereoExtrinsicsRRodrigue?: Maybe<CreateStereoExtrinsicsRRodriguePayload>;
  /** Creates a single `StereoExtrinsicsT`. */
  createStereoExtrinsicsT?: Maybe<CreateStereoExtrinsicsTPayload>;
  /** Creates a single `TractorExtrinsic`. */
  createTractorExtrinsic?: Maybe<CreateTractorExtrinsicPayload>;
  /** Creates a single `TractorExtrinsicsR`. */
  createTractorExtrinsicsR?: Maybe<CreateTractorExtrinsicsRPayload>;
  /** Creates a single `TractorExtrinsicsRRodrigue`. */
  createTractorExtrinsicsRRodrigue?: Maybe<CreateTractorExtrinsicsRRodriguePayload>;
  /** Creates a single `TractorExtrinsicsT`. */
  createTractorExtrinsicsT?: Maybe<CreateTractorExtrinsicsTPayload>;
  /** Creates a single `AlertType`. */
  createAlertType?: Maybe<CreateAlertTypePayload>;
  /** Creates a single `Alert`. */
  createAlert?: Maybe<CreateAlertPayload>;
  /** Creates a single `StatusMessage`. */
  createStatusMessage?: Maybe<CreateStatusMessagePayload>;
  /** Creates a single `StatusMessageHeader`. */
  createStatusMessageHeader?: Maybe<CreateStatusMessageHeaderPayload>;
  /** Creates a single `VehicleStateReason`. */
  createVehicleStateReason?: Maybe<CreateVehicleStateReasonPayload>;
  /** Creates a single `VehicleState`. */
  createVehicleState?: Maybe<CreateVehicleStatePayload>;
  /** Creates a single `VehicleStatus`. */
  createVehicleStatus?: Maybe<CreateVehicleStatusPayload>;
  /** Creates a single `VehicleStatusDetail`. */
  createVehicleStatusDetail?: Maybe<CreateVehicleStatusDetailPayload>;
  /** Creates a single `ObjectMessage`. */
  createObjectMessage?: Maybe<CreateObjectMessagePayload>;
  /** Creates a single `ObjectMessageCentroidLocation`. */
  createObjectMessageCentroidLocation?: Maybe<CreateObjectMessageCentroidLocationPayload>;
  /** Creates a single `ObjectMessageCentroidRpy`. */
  createObjectMessageCentroidRpy?: Maybe<CreateObjectMessageCentroidRpyPayload>;
  /** Creates a single `ObjectMessageCircleCenter`. */
  createObjectMessageCircleCenter?: Maybe<CreateObjectMessageCircleCenterPayload>;
  /** Creates a single `ObjectMessageDetection`. */
  createObjectMessageDetection?: Maybe<CreateObjectMessageDetectionPayload>;
  /** Creates a single `ObjectMessageDetectionCuboid`. */
  createObjectMessageDetectionCuboid?: Maybe<CreateObjectMessageDetectionCuboidPayload>;
  /** Creates a single `ObjectMessageDetectionCuboidCentroid`. */
  createObjectMessageDetectionCuboidCentroid?: Maybe<CreateObjectMessageDetectionCuboidCentroidPayload>;
  /** Creates a single `ObjectMessageDetectionCuboidDimension`. */
  createObjectMessageDetectionCuboidDimension?: Maybe<CreateObjectMessageDetectionCuboidDimensionPayload>;
  /** Creates a single `ObjectMessageDetectionCuboidOrientation`. */
  createObjectMessageDetectionCuboidOrientation?: Maybe<CreateObjectMessageDetectionCuboidOrientationPayload>;
  /** Creates a single `ObjectMessageDetectionHeader`. */
  createObjectMessageDetectionHeader?: Maybe<CreateObjectMessageDetectionHeaderPayload>;
  /** Creates a single `ObjectMessageDetectionRoi`. */
  createObjectMessageDetectionRoi?: Maybe<CreateObjectMessageDetectionRoiPayload>;
  /** Creates a single `ObjectMessageEcef`. */
  createObjectMessageEcef?: Maybe<CreateObjectMessageEcefPayload>;
  /** Creates a single `ObjectMessageEnu`. */
  createObjectMessageEnu?: Maybe<CreateObjectMessageEnuPayload>;
  /** Creates a single `ObjectMessageFieldOrigin`. */
  createObjectMessageFieldOrigin?: Maybe<CreateObjectMessageFieldOriginPayload>;
  /** Creates a single `ObjectMessageHeader`. */
  createObjectMessageHeader?: Maybe<CreateObjectMessageHeaderPayload>;
  /** Creates a single `ObjectMessageLla`. */
  createObjectMessageLla?: Maybe<CreateObjectMessageLlaPayload>;
  /** Creates a single `ObjectMessageVertex`. */
  createObjectMessageVertex?: Maybe<CreateObjectMessageVertexPayload>;
  /** Creates a single `ObjectMessageXyzCamera`. */
  createObjectMessageXyzCamera?: Maybe<CreateObjectMessageXyzCameraPayload>;
  /** Creates a single `ObjectMessageXyzStarfire`. */
  createObjectMessageXyzStarfire?: Maybe<CreateObjectMessageXyzStarfirePayload>;
  /** Creates a single `Object`. */
  createObject?: Maybe<CreateObjectPayload>;
  /** Updates a single `VehicleType` using its globally unique id and a patch. */
  updateVehicleTypeByNodeId?: Maybe<UpdateVehicleTypePayload>;
  /** Updates a single `VehicleType` using a unique key and a patch. */
  updateVehicleType?: Maybe<UpdateVehicleTypePayload>;
  /** Updates a single `VehicleType` using a unique key and a patch. */
  updateVehicleTypeByType?: Maybe<UpdateVehicleTypePayload>;
  /** Updates a single `Vehicle` using its globally unique id and a patch. */
  updateVehicleByNodeId?: Maybe<UpdateVehiclePayload>;
  /** Updates a single `Vehicle` using a unique key and a patch. */
  updateVehicle?: Maybe<UpdateVehiclePayload>;
  /** Updates a single `Vehicle` using a unique key and a patch. */
  updateVehicleByDeviceId?: Maybe<UpdateVehiclePayload>;
  /** Updates a single `VehiclesOnline` using its globally unique id and a patch. */
  updateVehiclesOnlineByNodeId?: Maybe<UpdateVehiclesOnlinePayload>;
  /** Updates a single `VehiclesOnline` using a unique key and a patch. */
  updateVehiclesOnline?: Maybe<UpdateVehiclesOnlinePayload>;
  /** Updates a single `VehiclesOnline` using a unique key and a patch. */
  updateVehiclesOnlineByVehicleId?: Maybe<UpdateVehiclesOnlinePayload>;
  /** Updates a single `TopicType` using its globally unique id and a patch. */
  updateTopicTypeByNodeId?: Maybe<UpdateTopicTypePayload>;
  /** Updates a single `TopicType` using a unique key and a patch. */
  updateTopicType?: Maybe<UpdateTopicTypePayload>;
  /** Updates a single `TopicType` using a unique key and a patch. */
  updateTopicTypeByModule?: Maybe<UpdateTopicTypePayload>;
  /** Updates a single `Topic` using its globally unique id and a patch. */
  updateTopicByNodeId?: Maybe<UpdateTopicPayload>;
  /** Updates a single `Topic` using a unique key and a patch. */
  updateTopic?: Maybe<UpdateTopicPayload>;
  /** Updates a single `Topic` using a unique key and a patch. */
  updateTopicByName?: Maybe<UpdateTopicPayload>;
  /** Updates a single `Test` using its globally unique id and a patch. */
  updateTestByNodeId?: Maybe<UpdateTestPayload>;
  /** Updates a single `Test` using a unique key and a patch. */
  updateTest?: Maybe<UpdateTestPayload>;
  /** Updates a single `Starfire` using its globally unique id and a patch. */
  updateStarfireByNodeId?: Maybe<UpdateStarfirePayload>;
  /** Updates a single `Starfire` using a unique key and a patch. */
  updateStarfire?: Maybe<UpdateStarfirePayload>;
  /** Updates a single `StarfireHeader` using its globally unique id and a patch. */
  updateStarfireHeaderByNodeId?: Maybe<UpdateStarfireHeaderPayload>;
  /** Updates a single `StarfireHeader` using a unique key and a patch. */
  updateStarfireHeader?: Maybe<UpdateStarfireHeaderPayload>;
  /** Updates a single `StarfireMessage` using its globally unique id and a patch. */
  updateStarfireMessageByNodeId?: Maybe<UpdateStarfireMessagePayload>;
  /** Updates a single `StarfireMessage` using a unique key and a patch. */
  updateStarfireMessage?: Maybe<UpdateStarfireMessagePayload>;
  /** Updates a single `Camera` using its globally unique id and a patch. */
  updateCameraByNodeId?: Maybe<UpdateCameraPayload>;
  /** Updates a single `Camera` using a unique key and a patch. */
  updateCamera?: Maybe<UpdateCameraPayload>;
  /** Updates a single `CameraMessage` using its globally unique id and a patch. */
  updateCameraMessageByNodeId?: Maybe<UpdateCameraMessagePayload>;
  /** Updates a single `CameraMessage` using a unique key and a patch. */
  updateCameraMessage?: Maybe<UpdateCameraMessagePayload>;
  /** Updates a single `CameraMeta` using its globally unique id and a patch. */
  updateCameraMetaByNodeId?: Maybe<UpdateCameraMetaPayload>;
  /** Updates a single `CameraMeta` using a unique key and a patch. */
  updateCameraMeta?: Maybe<UpdateCameraMetaPayload>;
  /** Updates a single `CameraPair` using its globally unique id and a patch. */
  updateCameraPairByNodeId?: Maybe<UpdateCameraPairPayload>;
  /** Updates a single `CameraPair` using a unique key and a patch. */
  updateCameraPair?: Maybe<UpdateCameraPairPayload>;
  /** Updates a single `CameraPairMessage` using its globally unique id and a patch. */
  updateCameraPairMessageByNodeId?: Maybe<UpdateCameraPairMessagePayload>;
  /** Updates a single `CameraPairMessage` using a unique key and a patch. */
  updateCameraPairMessage?: Maybe<UpdateCameraPairMessagePayload>;
  /** Updates a single `SegmentationMap` using its globally unique id and a patch. */
  updateSegmentationMapByNodeId?: Maybe<UpdateSegmentationMapPayload>;
  /** Updates a single `SegmentationMap` using a unique key and a patch. */
  updateSegmentationMap?: Maybe<UpdateSegmentationMapPayload>;
  /** Updates a single `SideIntrinsicsD` using its globally unique id and a patch. */
  updateSideIntrinsicsDByNodeId?: Maybe<UpdateSideIntrinsicsDPayload>;
  /** Updates a single `SideIntrinsicsD` using a unique key and a patch. */
  updateSideIntrinsicsD?: Maybe<UpdateSideIntrinsicsDPayload>;
  /** Updates a single `SideIntrinsicsK` using its globally unique id and a patch. */
  updateSideIntrinsicsKByNodeId?: Maybe<UpdateSideIntrinsicsKPayload>;
  /** Updates a single `SideIntrinsicsK` using a unique key and a patch. */
  updateSideIntrinsicsK?: Maybe<UpdateSideIntrinsicsKPayload>;
  /** Updates a single `StereoExtrinsicsR` using its globally unique id and a patch. */
  updateStereoExtrinsicsRByNodeId?: Maybe<UpdateStereoExtrinsicsRPayload>;
  /** Updates a single `StereoExtrinsicsR` using a unique key and a patch. */
  updateStereoExtrinsicsR?: Maybe<UpdateStereoExtrinsicsRPayload>;
  /** Updates a single `AlertType` using its globally unique id and a patch. */
  updateAlertTypeByNodeId?: Maybe<UpdateAlertTypePayload>;
  /** Updates a single `AlertType` using a unique key and a patch. */
  updateAlertType?: Maybe<UpdateAlertTypePayload>;
  /** Updates a single `Alert` using its globally unique id and a patch. */
  updateAlertByNodeId?: Maybe<UpdateAlertPayload>;
  /** Updates a single `Alert` using a unique key and a patch. */
  updateAlert?: Maybe<UpdateAlertPayload>;
  /** Updates a single `StatusMessage` using its globally unique id and a patch. */
  updateStatusMessageByNodeId?: Maybe<UpdateStatusMessagePayload>;
  /** Updates a single `StatusMessage` using a unique key and a patch. */
  updateStatusMessage?: Maybe<UpdateStatusMessagePayload>;
  /** Updates a single `VehicleStateReason` using its globally unique id and a patch. */
  updateVehicleStateReasonByNodeId?: Maybe<UpdateVehicleStateReasonPayload>;
  /** Updates a single `VehicleStateReason` using a unique key and a patch. */
  updateVehicleStateReason?: Maybe<UpdateVehicleStateReasonPayload>;
  /** Updates a single `VehicleState` using its globally unique id and a patch. */
  updateVehicleStateByNodeId?: Maybe<UpdateVehicleStatePayload>;
  /** Updates a single `VehicleState` using a unique key and a patch. */
  updateVehicleState?: Maybe<UpdateVehicleStatePayload>;
  /** Updates a single `VehicleState` using a unique key and a patch. */
  updateVehicleStateByName?: Maybe<UpdateVehicleStatePayload>;
  /** Updates a single `VehicleState` using a unique key and a patch. */
  updateVehicleStateByCode?: Maybe<UpdateVehicleStatePayload>;
  /** Updates a single `VehicleStatus` using its globally unique id and a patch. */
  updateVehicleStatusByNodeId?: Maybe<UpdateVehicleStatusPayload>;
  /** Updates a single `VehicleStatus` using a unique key and a patch. */
  updateVehicleStatus?: Maybe<UpdateVehicleStatusPayload>;
  /** Updates a single `VehicleStatusDetail` using its globally unique id and a patch. */
  updateVehicleStatusDetailByNodeId?: Maybe<UpdateVehicleStatusDetailPayload>;
  /** Updates a single `VehicleStatusDetail` using a unique key and a patch. */
  updateVehicleStatusDetail?: Maybe<UpdateVehicleStatusDetailPayload>;
  /** Updates a single `ObjectMessageFieldOrigin` using its globally unique id and a patch. */
  updateObjectMessageFieldOriginByNodeId?: Maybe<UpdateObjectMessageFieldOriginPayload>;
  /** Updates a single `ObjectMessageFieldOrigin` using a unique key and a patch. */
  updateObjectMessageFieldOrigin?: Maybe<UpdateObjectMessageFieldOriginPayload>;
  /** Updates a single `ObjectMessageHeader` using its globally unique id and a patch. */
  updateObjectMessageHeaderByNodeId?: Maybe<UpdateObjectMessageHeaderPayload>;
  /** Updates a single `ObjectMessageHeader` using a unique key and a patch. */
  updateObjectMessageHeader?: Maybe<UpdateObjectMessageHeaderPayload>;
  /** Updates a single `Object` using its globally unique id and a patch. */
  updateObjectByNodeId?: Maybe<UpdateObjectPayload>;
  /** Updates a single `Object` using a unique key and a patch. */
  updateObject?: Maybe<UpdateObjectPayload>;
  /** Deletes a single `VehiclesOnline` using its globally unique id. */
  deleteVehiclesOnlineByNodeId?: Maybe<DeleteVehiclesOnlinePayload>;
  /** Deletes a single `VehiclesOnline` using a unique key. */
  deleteVehiclesOnline?: Maybe<DeleteVehiclesOnlinePayload>;
  /** Deletes a single `VehiclesOnline` using a unique key. */
  deleteVehiclesOnlineByVehicleId?: Maybe<DeleteVehiclesOnlinePayload>;
  /** Deletes a single `TopicCategory` using its globally unique id. */
  deleteTopicCategoryByNodeId?: Maybe<DeleteTopicCategoryPayload>;
  /** Deletes a single `TopicCategory` using a unique key. */
  deleteTopicCategory?: Maybe<DeleteTopicCategoryPayload>;
  /** Deletes a single `Test` using its globally unique id. */
  deleteTestByNodeId?: Maybe<DeleteTestPayload>;
  /** Deletes a single `Test` using a unique key. */
  deleteTest?: Maybe<DeleteTestPayload>;
  /** Deletes a single `VehicleLogMessageStamp` using its globally unique id. */
  deleteVehicleLogMessageStampByNodeId?: Maybe<DeleteVehicleLogMessageStampPayload>;
  /** Deletes a single `VehicleLogMessageStamp` using a unique key. */
  deleteVehicleLogMessageStamp?: Maybe<DeleteVehicleLogMessageStampPayload>;
  /** Deletes a single `VehicleLogMessage` using its globally unique id. */
  deleteVehicleLogMessageByNodeId?: Maybe<DeleteVehicleLogMessagePayload>;
  /** Deletes a single `VehicleLogMessage` using a unique key. */
  deleteVehicleLogMessage?: Maybe<DeleteVehicleLogMessagePayload>;
  /** Deletes a single `VehicleLog` using its globally unique id. */
  deleteVehicleLogByNodeId?: Maybe<DeleteVehicleLogPayload>;
  /** Deletes a single `VehicleLog` using a unique key. */
  deleteVehicleLog?: Maybe<DeleteVehicleLogPayload>;
  /** Deletes a single `Camera` using its globally unique id. */
  deleteCameraByNodeId?: Maybe<DeleteCameraPayload>;
  /** Deletes a single `Camera` using a unique key. */
  deleteCamera?: Maybe<DeleteCameraPayload>;
  /** Deletes a single `CameraHistogram` using its globally unique id. */
  deleteCameraHistogramByNodeId?: Maybe<DeleteCameraHistogramPayload>;
  /** Deletes a single `CameraHistogram` using a unique key. */
  deleteCameraHistogram?: Maybe<DeleteCameraHistogramPayload>;
  /** Deletes a single `CameraMessage` using its globally unique id. */
  deleteCameraMessageByNodeId?: Maybe<DeleteCameraMessagePayload>;
  /** Deletes a single `CameraMessage` using a unique key. */
  deleteCameraMessage?: Maybe<DeleteCameraMessagePayload>;
  /** Deletes a single `CameraMessageHeader` using its globally unique id. */
  deleteCameraMessageHeaderByNodeId?: Maybe<DeleteCameraMessageHeaderPayload>;
  /** Deletes a single `CameraMessageHeader` using a unique key. */
  deleteCameraMessageHeader?: Maybe<DeleteCameraMessageHeaderPayload>;
  /** Deletes a single `CameraMeta` using its globally unique id. */
  deleteCameraMetaByNodeId?: Maybe<DeleteCameraMetaPayload>;
  /** Deletes a single `CameraMeta` using a unique key. */
  deleteCameraMeta?: Maybe<DeleteCameraMetaPayload>;
  /** Deletes a single `CameraMetaE` using its globally unique id. */
  deleteCameraMetaEByNodeId?: Maybe<DeleteCameraMetaEPayload>;
  /** Deletes a single `CameraMetaE` using a unique key. */
  deleteCameraMetaE?: Maybe<DeleteCameraMetaEPayload>;
  /** Deletes a single `CameraMetaF` using its globally unique id. */
  deleteCameraMetaFByNodeId?: Maybe<DeleteCameraMetaFPayload>;
  /** Deletes a single `CameraMetaF` using a unique key. */
  deleteCameraMetaF?: Maybe<DeleteCameraMetaFPayload>;
  /** Deletes a single `CameraMetaP1` using its globally unique id. */
  deleteCameraMetaP1ByNodeId?: Maybe<DeleteCameraMetaP1Payload>;
  /** Deletes a single `CameraMetaP1` using a unique key. */
  deleteCameraMetaP1?: Maybe<DeleteCameraMetaP1Payload>;
  /** Deletes a single `CameraMetaP2` using its globally unique id. */
  deleteCameraMetaP2ByNodeId?: Maybe<DeleteCameraMetaP2Payload>;
  /** Deletes a single `CameraMetaP2` using a unique key. */
  deleteCameraMetaP2?: Maybe<DeleteCameraMetaP2Payload>;
  /** Deletes a single `CameraMetaQ` using its globally unique id. */
  deleteCameraMetaQByNodeId?: Maybe<DeleteCameraMetaQPayload>;
  /** Deletes a single `CameraMetaQ` using a unique key. */
  deleteCameraMetaQ?: Maybe<DeleteCameraMetaQPayload>;
  /** Deletes a single `CameraMetaR1` using its globally unique id. */
  deleteCameraMetaR1ByNodeId?: Maybe<DeleteCameraMetaR1Payload>;
  /** Deletes a single `CameraMetaR1` using a unique key. */
  deleteCameraMetaR1?: Maybe<DeleteCameraMetaR1Payload>;
  /** Deletes a single `CameraMetaR2` using its globally unique id. */
  deleteCameraMetaR2ByNodeId?: Maybe<DeleteCameraMetaR2Payload>;
  /** Deletes a single `CameraMetaR2` using a unique key. */
  deleteCameraMetaR2?: Maybe<DeleteCameraMetaR2Payload>;
  /** Deletes a single `CameraPair` using its globally unique id. */
  deleteCameraPairByNodeId?: Maybe<DeleteCameraPairPayload>;
  /** Deletes a single `CameraPair` using a unique key. */
  deleteCameraPair?: Maybe<DeleteCameraPairPayload>;
  /** Deletes a single `CameraPairMessage` using its globally unique id. */
  deleteCameraPairMessageByNodeId?: Maybe<DeleteCameraPairMessagePayload>;
  /** Deletes a single `CameraPairMessage` using a unique key. */
  deleteCameraPairMessage?: Maybe<DeleteCameraPairMessagePayload>;
  /** Deletes a single `CameraRoi` using its globally unique id. */
  deleteCameraRoiByNodeId?: Maybe<DeleteCameraRoiPayload>;
  /** Deletes a single `CameraRoi` using a unique key. */
  deleteCameraRoi?: Maybe<DeleteCameraRoiPayload>;
  /** Deletes a single `FullHistogram` using its globally unique id. */
  deleteFullHistogramByNodeId?: Maybe<DeleteFullHistogramPayload>;
  /** Deletes a single `FullHistogram` using a unique key. */
  deleteFullHistogram?: Maybe<DeleteFullHistogramPayload>;
  /** Deletes a single `ImageDatum` using its globally unique id. */
  deleteImageDatumByNodeId?: Maybe<DeleteImageDatumPayload>;
  /** Deletes a single `ImageDatum` using a unique key. */
  deleteImageDatum?: Maybe<DeleteImageDatumPayload>;
  /** Deletes a single `ImageHeader` using its globally unique id. */
  deleteImageHeaderByNodeId?: Maybe<DeleteImageHeaderPayload>;
  /** Deletes a single `ImageHeader` using a unique key. */
  deleteImageHeader?: Maybe<DeleteImageHeaderPayload>;
  /** Deletes a single `ImageHeaderStamp` using its globally unique id. */
  deleteImageHeaderStampByNodeId?: Maybe<DeleteImageHeaderStampPayload>;
  /** Deletes a single `ImageHeaderStamp` using a unique key. */
  deleteImageHeaderStamp?: Maybe<DeleteImageHeaderStampPayload>;
  /** Deletes a single `Image` using its globally unique id. */
  deleteImageByNodeId?: Maybe<DeleteImagePayload>;
  /** Deletes a single `Image` using a unique key. */
  deleteImage?: Maybe<DeleteImagePayload>;
  /** Deletes a single `SegmentationMap` using its globally unique id. */
  deleteSegmentationMapByNodeId?: Maybe<DeleteSegmentationMapPayload>;
  /** Deletes a single `SegmentationMap` using a unique key. */
  deleteSegmentationMap?: Maybe<DeleteSegmentationMapPayload>;
  /** Deletes a single `SideIntrinsic` using its globally unique id. */
  deleteSideIntrinsicByNodeId?: Maybe<DeleteSideIntrinsicPayload>;
  /** Deletes a single `SideIntrinsic` using a unique key. */
  deleteSideIntrinsic?: Maybe<DeleteSideIntrinsicPayload>;
  /** Deletes a single `SideIntrinsicsD` using its globally unique id. */
  deleteSideIntrinsicsDByNodeId?: Maybe<DeleteSideIntrinsicsDPayload>;
  /** Deletes a single `SideIntrinsicsD` using a unique key. */
  deleteSideIntrinsicsD?: Maybe<DeleteSideIntrinsicsDPayload>;
  /** Deletes a single `SideIntrinsicsK` using its globally unique id. */
  deleteSideIntrinsicsKByNodeId?: Maybe<DeleteSideIntrinsicsKPayload>;
  /** Deletes a single `SideIntrinsicsK` using a unique key. */
  deleteSideIntrinsicsK?: Maybe<DeleteSideIntrinsicsKPayload>;
  /** Deletes a single `SmallHistogram` using its globally unique id. */
  deleteSmallHistogramByNodeId?: Maybe<DeleteSmallHistogramPayload>;
  /** Deletes a single `SmallHistogram` using a unique key. */
  deleteSmallHistogram?: Maybe<DeleteSmallHistogramPayload>;
  /** Deletes a single `StereoExtrinsic` using its globally unique id. */
  deleteStereoExtrinsicByNodeId?: Maybe<DeleteStereoExtrinsicPayload>;
  /** Deletes a single `StereoExtrinsic` using a unique key. */
  deleteStereoExtrinsic?: Maybe<DeleteStereoExtrinsicPayload>;
  /** Deletes a single `StereoExtrinsicsR` using its globally unique id. */
  deleteStereoExtrinsicsRByNodeId?: Maybe<DeleteStereoExtrinsicsRPayload>;
  /** Deletes a single `StereoExtrinsicsR` using a unique key. */
  deleteStereoExtrinsicsR?: Maybe<DeleteStereoExtrinsicsRPayload>;
  /** Deletes a single `StereoExtrinsicsRRodrigue` using its globally unique id. */
  deleteStereoExtrinsicsRRodrigueByNodeId?: Maybe<DeleteStereoExtrinsicsRRodriguePayload>;
  /** Deletes a single `StereoExtrinsicsRRodrigue` using a unique key. */
  deleteStereoExtrinsicsRRodrigue?: Maybe<DeleteStereoExtrinsicsRRodriguePayload>;
  /** Deletes a single `StereoExtrinsicsT` using its globally unique id. */
  deleteStereoExtrinsicsTByNodeId?: Maybe<DeleteStereoExtrinsicsTPayload>;
  /** Deletes a single `StereoExtrinsicsT` using a unique key. */
  deleteStereoExtrinsicsT?: Maybe<DeleteStereoExtrinsicsTPayload>;
  /** Deletes a single `TractorExtrinsic` using its globally unique id. */
  deleteTractorExtrinsicByNodeId?: Maybe<DeleteTractorExtrinsicPayload>;
  /** Deletes a single `TractorExtrinsic` using a unique key. */
  deleteTractorExtrinsic?: Maybe<DeleteTractorExtrinsicPayload>;
  /** Deletes a single `TractorExtrinsicsR` using its globally unique id. */
  deleteTractorExtrinsicsRByNodeId?: Maybe<DeleteTractorExtrinsicsRPayload>;
  /** Deletes a single `TractorExtrinsicsR` using a unique key. */
  deleteTractorExtrinsicsR?: Maybe<DeleteTractorExtrinsicsRPayload>;
  /** Deletes a single `TractorExtrinsicsRRodrigue` using its globally unique id. */
  deleteTractorExtrinsicsRRodrigueByNodeId?: Maybe<DeleteTractorExtrinsicsRRodriguePayload>;
  /** Deletes a single `TractorExtrinsicsRRodrigue` using a unique key. */
  deleteTractorExtrinsicsRRodrigue?: Maybe<DeleteTractorExtrinsicsRRodriguePayload>;
  /** Deletes a single `TractorExtrinsicsT` using its globally unique id. */
  deleteTractorExtrinsicsTByNodeId?: Maybe<DeleteTractorExtrinsicsTPayload>;
  /** Deletes a single `TractorExtrinsicsT` using a unique key. */
  deleteTractorExtrinsicsT?: Maybe<DeleteTractorExtrinsicsTPayload>;
  /** Deletes a single `AlertType` using its globally unique id. */
  deleteAlertTypeByNodeId?: Maybe<DeleteAlertTypePayload>;
  /** Deletes a single `AlertType` using a unique key. */
  deleteAlertType?: Maybe<DeleteAlertTypePayload>;
  /** Deletes a single `Alert` using its globally unique id. */
  deleteAlertByNodeId?: Maybe<DeleteAlertPayload>;
  /** Deletes a single `Alert` using a unique key. */
  deleteAlert?: Maybe<DeleteAlertPayload>;
  /** Deletes a single `StatusMessage` using its globally unique id. */
  deleteStatusMessageByNodeId?: Maybe<DeleteStatusMessagePayload>;
  /** Deletes a single `StatusMessage` using a unique key. */
  deleteStatusMessage?: Maybe<DeleteStatusMessagePayload>;
  /** Deletes a single `StatusMessageHeader` using its globally unique id. */
  deleteStatusMessageHeaderByNodeId?: Maybe<DeleteStatusMessageHeaderPayload>;
  /** Deletes a single `StatusMessageHeader` using a unique key. */
  deleteStatusMessageHeader?: Maybe<DeleteStatusMessageHeaderPayload>;
  /** Deletes a single `StatusMessageMissionStat` using its globally unique id. */
  deleteStatusMessageMissionStatByNodeId?: Maybe<DeleteStatusMessageMissionStatPayload>;
  /** Deletes a single `StatusMessageMissionStat` using a unique key. */
  deleteStatusMessageMissionStat?: Maybe<DeleteStatusMessageMissionStatPayload>;
  /** Deletes a single `VehicleStateReason` using its globally unique id. */
  deleteVehicleStateReasonByNodeId?: Maybe<DeleteVehicleStateReasonPayload>;
  /** Deletes a single `VehicleStateReason` using a unique key. */
  deleteVehicleStateReason?: Maybe<DeleteVehicleStateReasonPayload>;
  /** Deletes a single `VehicleState` using its globally unique id. */
  deleteVehicleStateByNodeId?: Maybe<DeleteVehicleStatePayload>;
  /** Deletes a single `VehicleState` using a unique key. */
  deleteVehicleState?: Maybe<DeleteVehicleStatePayload>;
  /** Deletes a single `VehicleState` using a unique key. */
  deleteVehicleStateByName?: Maybe<DeleteVehicleStatePayload>;
  /** Deletes a single `VehicleState` using a unique key. */
  deleteVehicleStateByCode?: Maybe<DeleteVehicleStatePayload>;
  /** Deletes a single `VehicleStatus` using its globally unique id. */
  deleteVehicleStatusByNodeId?: Maybe<DeleteVehicleStatusPayload>;
  /** Deletes a single `VehicleStatus` using a unique key. */
  deleteVehicleStatus?: Maybe<DeleteVehicleStatusPayload>;
  /** Deletes a single `VehicleStatusDetail` using its globally unique id. */
  deleteVehicleStatusDetailByNodeId?: Maybe<DeleteVehicleStatusDetailPayload>;
  /** Deletes a single `VehicleStatusDetail` using a unique key. */
  deleteVehicleStatusDetail?: Maybe<DeleteVehicleStatusDetailPayload>;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateVehicleTopicArgs = {
  input: CreateVehicleTopicInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateVehicleTypeArgs = {
  input: CreateVehicleTypeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateVehicleArgs = {
  input: CreateVehicleInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateVehiclesOfflineArgs = {
  input: CreateVehiclesOfflineInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateVehiclesOnlineArgs = {
  input: CreateVehiclesOnlineInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateTopicCategoryArgs = {
  input: CreateTopicCategoryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateTopicTypeArgs = {
  input: CreateTopicTypeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateTopicArgs = {
  input: CreateTopicInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateTestArgs = {
  input: CreateTestInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateVehicleLogMessageStampArgs = {
  input: CreateVehicleLogMessageStampInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateVehicleLogMessageArgs = {
  input: CreateVehicleLogMessageInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateVehicleLogArgs = {
  input: CreateVehicleLogInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateStarfireArgs = {
  input: CreateStarfireInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateStarfireHeaderArgs = {
  input: CreateStarfireHeaderInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateStarfireMessageArgs = {
  input: CreateStarfireMessageInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateCameraArgs = {
  input: CreateCameraInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateCameraHistogramArgs = {
  input: CreateCameraHistogramInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateCameraMessageArgs = {
  input: CreateCameraMessageInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateCameraMessageHeaderArgs = {
  input: CreateCameraMessageHeaderInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateCameraMetaArgs = {
  input: CreateCameraMetaInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateCameraMetaEArgs = {
  input: CreateCameraMetaEInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateCameraMetaFArgs = {
  input: CreateCameraMetaFInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateCameraMetaP1Args = {
  input: CreateCameraMetaP1Input;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateCameraMetaP2Args = {
  input: CreateCameraMetaP2Input;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateCameraMetaQArgs = {
  input: CreateCameraMetaQInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateCameraMetaR1Args = {
  input: CreateCameraMetaR1Input;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateCameraMetaR2Args = {
  input: CreateCameraMetaR2Input;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateCameraPairArgs = {
  input: CreateCameraPairInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateCameraPairMessageArgs = {
  input: CreateCameraPairMessageInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateCameraRoiArgs = {
  input: CreateCameraRoiInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateFullHistogramArgs = {
  input: CreateFullHistogramInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateImageDatumArgs = {
  input: CreateImageDatumInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateImageHeaderArgs = {
  input: CreateImageHeaderInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateImageHeaderStampArgs = {
  input: CreateImageHeaderStampInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateImageArgs = {
  input: CreateImageInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateSegmentationMapArgs = {
  input: CreateSegmentationMapInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateSideIntrinsicArgs = {
  input: CreateSideIntrinsicInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateSideIntrinsicsDArgs = {
  input: CreateSideIntrinsicsDInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateSideIntrinsicsKArgs = {
  input: CreateSideIntrinsicsKInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateSmallHistogramArgs = {
  input: CreateSmallHistogramInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateStereoExtrinsicArgs = {
  input: CreateStereoExtrinsicInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateStereoExtrinsicsRArgs = {
  input: CreateStereoExtrinsicsRInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateStereoExtrinsicsRRodrigueArgs = {
  input: CreateStereoExtrinsicsRRodrigueInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateStereoExtrinsicsTArgs = {
  input: CreateStereoExtrinsicsTInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateTractorExtrinsicArgs = {
  input: CreateTractorExtrinsicInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateTractorExtrinsicsRArgs = {
  input: CreateTractorExtrinsicsRInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateTractorExtrinsicsRRodrigueArgs = {
  input: CreateTractorExtrinsicsRRodrigueInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateTractorExtrinsicsTArgs = {
  input: CreateTractorExtrinsicsTInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateAlertTypeArgs = {
  input: CreateAlertTypeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateAlertArgs = {
  input: CreateAlertInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateStatusMessageArgs = {
  input: CreateStatusMessageInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateStatusMessageHeaderArgs = {
  input: CreateStatusMessageHeaderInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateVehicleStateReasonArgs = {
  input: CreateVehicleStateReasonInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateVehicleStateArgs = {
  input: CreateVehicleStateInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateVehicleStatusArgs = {
  input: CreateVehicleStatusInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateVehicleStatusDetailArgs = {
  input: CreateVehicleStatusDetailInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateObjectMessageArgs = {
  input: CreateObjectMessageInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateObjectMessageCentroidLocationArgs = {
  input: CreateObjectMessageCentroidLocationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateObjectMessageCentroidRpyArgs = {
  input: CreateObjectMessageCentroidRpyInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateObjectMessageCircleCenterArgs = {
  input: CreateObjectMessageCircleCenterInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateObjectMessageDetectionArgs = {
  input: CreateObjectMessageDetectionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateObjectMessageDetectionCuboidArgs = {
  input: CreateObjectMessageDetectionCuboidInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateObjectMessageDetectionCuboidCentroidArgs = {
  input: CreateObjectMessageDetectionCuboidCentroidInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateObjectMessageDetectionCuboidDimensionArgs = {
  input: CreateObjectMessageDetectionCuboidDimensionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateObjectMessageDetectionCuboidOrientationArgs = {
  input: CreateObjectMessageDetectionCuboidOrientationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateObjectMessageDetectionHeaderArgs = {
  input: CreateObjectMessageDetectionHeaderInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateObjectMessageDetectionRoiArgs = {
  input: CreateObjectMessageDetectionRoiInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateObjectMessageEcefArgs = {
  input: CreateObjectMessageEcefInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateObjectMessageEnuArgs = {
  input: CreateObjectMessageEnuInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateObjectMessageFieldOriginArgs = {
  input: CreateObjectMessageFieldOriginInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateObjectMessageHeaderArgs = {
  input: CreateObjectMessageHeaderInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateObjectMessageLlaArgs = {
  input: CreateObjectMessageLlaInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateObjectMessageVertexArgs = {
  input: CreateObjectMessageVertexInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateObjectMessageXyzCameraArgs = {
  input: CreateObjectMessageXyzCameraInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateObjectMessageXyzStarfireArgs = {
  input: CreateObjectMessageXyzStarfireInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateObjectArgs = {
  input: CreateObjectInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateVehicleTypeByNodeIdArgs = {
  input: UpdateVehicleTypeByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateVehicleTypeArgs = {
  input: UpdateVehicleTypeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateVehicleTypeByTypeArgs = {
  input: UpdateVehicleTypeByTypeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateVehicleByNodeIdArgs = {
  input: UpdateVehicleByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateVehicleArgs = {
  input: UpdateVehicleInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateVehicleByDeviceIdArgs = {
  input: UpdateVehicleByDeviceIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateVehiclesOnlineByNodeIdArgs = {
  input: UpdateVehiclesOnlineByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateVehiclesOnlineArgs = {
  input: UpdateVehiclesOnlineInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateVehiclesOnlineByVehicleIdArgs = {
  input: UpdateVehiclesOnlineByVehicleIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateTopicTypeByNodeIdArgs = {
  input: UpdateTopicTypeByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateTopicTypeArgs = {
  input: UpdateTopicTypeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateTopicTypeByModuleArgs = {
  input: UpdateTopicTypeByModuleInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateTopicByNodeIdArgs = {
  input: UpdateTopicByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateTopicArgs = {
  input: UpdateTopicInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateTopicByNameArgs = {
  input: UpdateTopicByNameInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateTestByNodeIdArgs = {
  input: UpdateTestByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateTestArgs = {
  input: UpdateTestInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateStarfireByNodeIdArgs = {
  input: UpdateStarfireByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateStarfireArgs = {
  input: UpdateStarfireInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateStarfireHeaderByNodeIdArgs = {
  input: UpdateStarfireHeaderByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateStarfireHeaderArgs = {
  input: UpdateStarfireHeaderInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateStarfireMessageByNodeIdArgs = {
  input: UpdateStarfireMessageByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateStarfireMessageArgs = {
  input: UpdateStarfireMessageInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateCameraByNodeIdArgs = {
  input: UpdateCameraByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateCameraArgs = {
  input: UpdateCameraInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateCameraMessageByNodeIdArgs = {
  input: UpdateCameraMessageByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateCameraMessageArgs = {
  input: UpdateCameraMessageInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateCameraMetaByNodeIdArgs = {
  input: UpdateCameraMetaByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateCameraMetaArgs = {
  input: UpdateCameraMetaInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateCameraPairByNodeIdArgs = {
  input: UpdateCameraPairByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateCameraPairArgs = {
  input: UpdateCameraPairInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateCameraPairMessageByNodeIdArgs = {
  input: UpdateCameraPairMessageByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateCameraPairMessageArgs = {
  input: UpdateCameraPairMessageInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateSegmentationMapByNodeIdArgs = {
  input: UpdateSegmentationMapByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateSegmentationMapArgs = {
  input: UpdateSegmentationMapInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateSideIntrinsicsDByNodeIdArgs = {
  input: UpdateSideIntrinsicsDByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateSideIntrinsicsDArgs = {
  input: UpdateSideIntrinsicsDInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateSideIntrinsicsKByNodeIdArgs = {
  input: UpdateSideIntrinsicsKByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateSideIntrinsicsKArgs = {
  input: UpdateSideIntrinsicsKInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateStereoExtrinsicsRByNodeIdArgs = {
  input: UpdateStereoExtrinsicsRByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateStereoExtrinsicsRArgs = {
  input: UpdateStereoExtrinsicsRInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateAlertTypeByNodeIdArgs = {
  input: UpdateAlertTypeByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateAlertTypeArgs = {
  input: UpdateAlertTypeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateAlertByNodeIdArgs = {
  input: UpdateAlertByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateAlertArgs = {
  input: UpdateAlertInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateStatusMessageByNodeIdArgs = {
  input: UpdateStatusMessageByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateStatusMessageArgs = {
  input: UpdateStatusMessageInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateVehicleStateReasonByNodeIdArgs = {
  input: UpdateVehicleStateReasonByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateVehicleStateReasonArgs = {
  input: UpdateVehicleStateReasonInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateVehicleStateByNodeIdArgs = {
  input: UpdateVehicleStateByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateVehicleStateArgs = {
  input: UpdateVehicleStateInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateVehicleStateByNameArgs = {
  input: UpdateVehicleStateByNameInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateVehicleStateByCodeArgs = {
  input: UpdateVehicleStateByCodeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateVehicleStatusByNodeIdArgs = {
  input: UpdateVehicleStatusByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateVehicleStatusArgs = {
  input: UpdateVehicleStatusInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateVehicleStatusDetailByNodeIdArgs = {
  input: UpdateVehicleStatusDetailByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateVehicleStatusDetailArgs = {
  input: UpdateVehicleStatusDetailInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateObjectMessageFieldOriginByNodeIdArgs = {
  input: UpdateObjectMessageFieldOriginByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateObjectMessageFieldOriginArgs = {
  input: UpdateObjectMessageFieldOriginInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateObjectMessageHeaderByNodeIdArgs = {
  input: UpdateObjectMessageHeaderByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateObjectMessageHeaderArgs = {
  input: UpdateObjectMessageHeaderInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateObjectByNodeIdArgs = {
  input: UpdateObjectByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateObjectArgs = {
  input: UpdateObjectInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteVehiclesOnlineByNodeIdArgs = {
  input: DeleteVehiclesOnlineByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteVehiclesOnlineArgs = {
  input: DeleteVehiclesOnlineInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteVehiclesOnlineByVehicleIdArgs = {
  input: DeleteVehiclesOnlineByVehicleIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteTopicCategoryByNodeIdArgs = {
  input: DeleteTopicCategoryByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteTopicCategoryArgs = {
  input: DeleteTopicCategoryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteTestByNodeIdArgs = {
  input: DeleteTestByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteTestArgs = {
  input: DeleteTestInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteVehicleLogMessageStampByNodeIdArgs = {
  input: DeleteVehicleLogMessageStampByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteVehicleLogMessageStampArgs = {
  input: DeleteVehicleLogMessageStampInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteVehicleLogMessageByNodeIdArgs = {
  input: DeleteVehicleLogMessageByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteVehicleLogMessageArgs = {
  input: DeleteVehicleLogMessageInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteVehicleLogByNodeIdArgs = {
  input: DeleteVehicleLogByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteVehicleLogArgs = {
  input: DeleteVehicleLogInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteCameraByNodeIdArgs = {
  input: DeleteCameraByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteCameraArgs = {
  input: DeleteCameraInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteCameraHistogramByNodeIdArgs = {
  input: DeleteCameraHistogramByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteCameraHistogramArgs = {
  input: DeleteCameraHistogramInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteCameraMessageByNodeIdArgs = {
  input: DeleteCameraMessageByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteCameraMessageArgs = {
  input: DeleteCameraMessageInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteCameraMessageHeaderByNodeIdArgs = {
  input: DeleteCameraMessageHeaderByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteCameraMessageHeaderArgs = {
  input: DeleteCameraMessageHeaderInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteCameraMetaByNodeIdArgs = {
  input: DeleteCameraMetaByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteCameraMetaArgs = {
  input: DeleteCameraMetaInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteCameraMetaEByNodeIdArgs = {
  input: DeleteCameraMetaEByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteCameraMetaEArgs = {
  input: DeleteCameraMetaEInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteCameraMetaFByNodeIdArgs = {
  input: DeleteCameraMetaFByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteCameraMetaFArgs = {
  input: DeleteCameraMetaFInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteCameraMetaP1ByNodeIdArgs = {
  input: DeleteCameraMetaP1ByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteCameraMetaP1Args = {
  input: DeleteCameraMetaP1Input;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteCameraMetaP2ByNodeIdArgs = {
  input: DeleteCameraMetaP2ByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteCameraMetaP2Args = {
  input: DeleteCameraMetaP2Input;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteCameraMetaQByNodeIdArgs = {
  input: DeleteCameraMetaQByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteCameraMetaQArgs = {
  input: DeleteCameraMetaQInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteCameraMetaR1ByNodeIdArgs = {
  input: DeleteCameraMetaR1ByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteCameraMetaR1Args = {
  input: DeleteCameraMetaR1Input;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteCameraMetaR2ByNodeIdArgs = {
  input: DeleteCameraMetaR2ByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteCameraMetaR2Args = {
  input: DeleteCameraMetaR2Input;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteCameraPairByNodeIdArgs = {
  input: DeleteCameraPairByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteCameraPairArgs = {
  input: DeleteCameraPairInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteCameraPairMessageByNodeIdArgs = {
  input: DeleteCameraPairMessageByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteCameraPairMessageArgs = {
  input: DeleteCameraPairMessageInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteCameraRoiByNodeIdArgs = {
  input: DeleteCameraRoiByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteCameraRoiArgs = {
  input: DeleteCameraRoiInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteFullHistogramByNodeIdArgs = {
  input: DeleteFullHistogramByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteFullHistogramArgs = {
  input: DeleteFullHistogramInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteImageDatumByNodeIdArgs = {
  input: DeleteImageDatumByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteImageDatumArgs = {
  input: DeleteImageDatumInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteImageHeaderByNodeIdArgs = {
  input: DeleteImageHeaderByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteImageHeaderArgs = {
  input: DeleteImageHeaderInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteImageHeaderStampByNodeIdArgs = {
  input: DeleteImageHeaderStampByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteImageHeaderStampArgs = {
  input: DeleteImageHeaderStampInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteImageByNodeIdArgs = {
  input: DeleteImageByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteImageArgs = {
  input: DeleteImageInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteSegmentationMapByNodeIdArgs = {
  input: DeleteSegmentationMapByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteSegmentationMapArgs = {
  input: DeleteSegmentationMapInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteSideIntrinsicByNodeIdArgs = {
  input: DeleteSideIntrinsicByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteSideIntrinsicArgs = {
  input: DeleteSideIntrinsicInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteSideIntrinsicsDByNodeIdArgs = {
  input: DeleteSideIntrinsicsDByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteSideIntrinsicsDArgs = {
  input: DeleteSideIntrinsicsDInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteSideIntrinsicsKByNodeIdArgs = {
  input: DeleteSideIntrinsicsKByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteSideIntrinsicsKArgs = {
  input: DeleteSideIntrinsicsKInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteSmallHistogramByNodeIdArgs = {
  input: DeleteSmallHistogramByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteSmallHistogramArgs = {
  input: DeleteSmallHistogramInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteStereoExtrinsicByNodeIdArgs = {
  input: DeleteStereoExtrinsicByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteStereoExtrinsicArgs = {
  input: DeleteStereoExtrinsicInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteStereoExtrinsicsRByNodeIdArgs = {
  input: DeleteStereoExtrinsicsRByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteStereoExtrinsicsRArgs = {
  input: DeleteStereoExtrinsicsRInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteStereoExtrinsicsRRodrigueByNodeIdArgs = {
  input: DeleteStereoExtrinsicsRRodrigueByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteStereoExtrinsicsRRodrigueArgs = {
  input: DeleteStereoExtrinsicsRRodrigueInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteStereoExtrinsicsTByNodeIdArgs = {
  input: DeleteStereoExtrinsicsTByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteStereoExtrinsicsTArgs = {
  input: DeleteStereoExtrinsicsTInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteTractorExtrinsicByNodeIdArgs = {
  input: DeleteTractorExtrinsicByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteTractorExtrinsicArgs = {
  input: DeleteTractorExtrinsicInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteTractorExtrinsicsRByNodeIdArgs = {
  input: DeleteTractorExtrinsicsRByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteTractorExtrinsicsRArgs = {
  input: DeleteTractorExtrinsicsRInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteTractorExtrinsicsRRodrigueByNodeIdArgs = {
  input: DeleteTractorExtrinsicsRRodrigueByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteTractorExtrinsicsRRodrigueArgs = {
  input: DeleteTractorExtrinsicsRRodrigueInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteTractorExtrinsicsTByNodeIdArgs = {
  input: DeleteTractorExtrinsicsTByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteTractorExtrinsicsTArgs = {
  input: DeleteTractorExtrinsicsTInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteAlertTypeByNodeIdArgs = {
  input: DeleteAlertTypeByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteAlertTypeArgs = {
  input: DeleteAlertTypeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteAlertByNodeIdArgs = {
  input: DeleteAlertByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteAlertArgs = {
  input: DeleteAlertInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteStatusMessageByNodeIdArgs = {
  input: DeleteStatusMessageByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteStatusMessageArgs = {
  input: DeleteStatusMessageInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteStatusMessageHeaderByNodeIdArgs = {
  input: DeleteStatusMessageHeaderByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteStatusMessageHeaderArgs = {
  input: DeleteStatusMessageHeaderInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteStatusMessageMissionStatByNodeIdArgs = {
  input: DeleteStatusMessageMissionStatByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteStatusMessageMissionStatArgs = {
  input: DeleteStatusMessageMissionStatInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteVehicleStateReasonByNodeIdArgs = {
  input: DeleteVehicleStateReasonByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteVehicleStateReasonArgs = {
  input: DeleteVehicleStateReasonInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteVehicleStateByNodeIdArgs = {
  input: DeleteVehicleStateByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteVehicleStateArgs = {
  input: DeleteVehicleStateInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteVehicleStateByNameArgs = {
  input: DeleteVehicleStateByNameInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteVehicleStateByCodeArgs = {
  input: DeleteVehicleStateByCodeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteVehicleStatusByNodeIdArgs = {
  input: DeleteVehicleStatusByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteVehicleStatusArgs = {
  input: DeleteVehicleStatusInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteVehicleStatusDetailByNodeIdArgs = {
  input: DeleteVehicleStatusDetailByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteVehicleStatusDetailArgs = {
  input: DeleteVehicleStatusDetailInput;
};

/** An object with a globally unique `ID`. */
export type Node = {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
};

/** The object message enu table for the object message section */
export type Object = Node & {
  __typename?: 'Object';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  /** The id of the row that is autoincremented */
  id: Scalars['BigInt'];
  readingat: Scalars['Datetime'];
  /** The vehicle id pointing to vehicle on vehicles table */
  vehicleId: Scalars['BigInt'];
  /** The topic id pointing to topic on topics table */
  topicId: Scalars['BigInt'];
  /** The message id pointing to message on object message table */
  messageId: Scalars['BigInt'];
  /** The timestamp record was created */
  createdAt: Scalars['Datetime'];
  /** The timestamp record was updated */
  updatedAt: Scalars['Datetime'];
  /** Reads a single `Vehicle` that is related to this `Object`. */
  vehicle?: Maybe<Vehicle>;
  /** Reads a single `Topic` that is related to this `Object`. */
  topic?: Maybe<Topic>;
  /** Reads a single `ObjectMessage` that is related to this `Object`. */
  message?: Maybe<ObjectMessage>;
};

/** A condition to be used against `Object` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type ObjectCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `readingat` field. */
  readingat?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `vehicleId` field. */
  vehicleId?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `topicId` field. */
  topicId?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `messageId` field. */
  messageId?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: Maybe<Scalars['Datetime']>;
};

export type ObjectDetectionImage = {
  __typename?: 'ObjectDetectionImage';
  objectId?: Maybe<Scalars['BigInt']>;
  objHeaderId?: Maybe<Scalars['BigInt']>;
  headerId?: Maybe<Scalars['BigInt']>;
  vehicleId?: Maybe<Scalars['BigInt']>;
  imageId?: Maybe<Scalars['BigInt']>;
  width?: Maybe<Scalars['Int']>;
  height?: Maybe<Scalars['Int']>;
  encoding?: Maybe<Scalars['String']>;
  vehicleName?: Maybe<Scalars['String']>;
  readingat?: Maybe<Scalars['Datetime']>;
  cameraName?: Maybe<Scalars['String']>;
  leftExposure?: Maybe<Scalars['BigFloat']>;
  rightExposure?: Maybe<Scalars['BigFloat']>;
  leftGain?: Maybe<Scalars['BigFloat']>;
  rightGain?: Maybe<Scalars['BigFloat']>;
};

/**
 * A condition to be used against `ObjectDetectionImage` object types. All fields
 * are tested for equality and combined with a logical ‘and.’
 */
export type ObjectDetectionImageCondition = {
  /** Checks for equality with the object’s `objectId` field. */
  objectId?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `objHeaderId` field. */
  objHeaderId?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `headerId` field. */
  headerId?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `vehicleId` field. */
  vehicleId?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `imageId` field. */
  imageId?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `width` field. */
  width?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `height` field. */
  height?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `encoding` field. */
  encoding?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `vehicleName` field. */
  vehicleName?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `readingat` field. */
  readingat?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `cameraName` field. */
  cameraName?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `leftExposure` field. */
  leftExposure?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `rightExposure` field. */
  rightExposure?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `leftGain` field. */
  leftGain?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `rightGain` field. */
  rightGain?: Maybe<Scalars['BigFloat']>;
};

/** A filter to be used against `ObjectDetectionImage` object types. All fields are combined with a logical ‘and.’ */
export type ObjectDetectionImageFilter = {
  /** Filter by the object’s `objectId` field. */
  objectId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `objHeaderId` field. */
  objHeaderId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `headerId` field. */
  headerId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `vehicleId` field. */
  vehicleId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `imageId` field. */
  imageId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `width` field. */
  width?: Maybe<IntFilter>;
  /** Filter by the object’s `height` field. */
  height?: Maybe<IntFilter>;
  /** Filter by the object’s `encoding` field. */
  encoding?: Maybe<StringFilter>;
  /** Filter by the object’s `vehicleName` field. */
  vehicleName?: Maybe<StringFilter>;
  /** Filter by the object’s `readingat` field. */
  readingat?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `cameraName` field. */
  cameraName?: Maybe<StringFilter>;
  /** Filter by the object’s `leftExposure` field. */
  leftExposure?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `rightExposure` field. */
  rightExposure?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `leftGain` field. */
  leftGain?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `rightGain` field. */
  rightGain?: Maybe<BigFloatFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<ObjectDetectionImageFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<ObjectDetectionImageFilter>>;
  /** Negates the expression. */
  not?: Maybe<ObjectDetectionImageFilter>;
};

/** A connection to a list of `ObjectDetectionImage` values. */
export type ObjectDetectionImagesConnection = {
  __typename?: 'ObjectDetectionImagesConnection';
  /** A list of `ObjectDetectionImage` objects. */
  nodes: Array<Maybe<ObjectDetectionImage>>;
  /** A list of edges which contains the `ObjectDetectionImage` and cursor to aid in pagination. */
  edges: Array<ObjectDetectionImagesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ObjectDetectionImage` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `ObjectDetectionImage` edge in the connection. */
export type ObjectDetectionImagesEdge = {
  __typename?: 'ObjectDetectionImagesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `ObjectDetectionImage` at the end of the edge. */
  node?: Maybe<ObjectDetectionImage>;
};

/** Methods to use when ordering `ObjectDetectionImage`. */
export enum ObjectDetectionImagesOrderBy {
  Natural = 'NATURAL',
  ObjectIdAsc = 'OBJECT_ID_ASC',
  ObjectIdDesc = 'OBJECT_ID_DESC',
  ObjHeaderIdAsc = 'OBJ_HEADER_ID_ASC',
  ObjHeaderIdDesc = 'OBJ_HEADER_ID_DESC',
  HeaderIdAsc = 'HEADER_ID_ASC',
  HeaderIdDesc = 'HEADER_ID_DESC',
  VehicleIdAsc = 'VEHICLE_ID_ASC',
  VehicleIdDesc = 'VEHICLE_ID_DESC',
  ImageIdAsc = 'IMAGE_ID_ASC',
  ImageIdDesc = 'IMAGE_ID_DESC',
  WidthAsc = 'WIDTH_ASC',
  WidthDesc = 'WIDTH_DESC',
  HeightAsc = 'HEIGHT_ASC',
  HeightDesc = 'HEIGHT_DESC',
  EncodingAsc = 'ENCODING_ASC',
  EncodingDesc = 'ENCODING_DESC',
  VehicleNameAsc = 'VEHICLE_NAME_ASC',
  VehicleNameDesc = 'VEHICLE_NAME_DESC',
  ReadingatAsc = 'READINGAT_ASC',
  ReadingatDesc = 'READINGAT_DESC',
  CameraNameAsc = 'CAMERA_NAME_ASC',
  CameraNameDesc = 'CAMERA_NAME_DESC',
  LeftExposureAsc = 'LEFT_EXPOSURE_ASC',
  LeftExposureDesc = 'LEFT_EXPOSURE_DESC',
  RightExposureAsc = 'RIGHT_EXPOSURE_ASC',
  RightExposureDesc = 'RIGHT_EXPOSURE_DESC',
  LeftGainAsc = 'LEFT_GAIN_ASC',
  LeftGainDesc = 'LEFT_GAIN_DESC',
  RightGainAsc = 'RIGHT_GAIN_ASC',
  RightGainDesc = 'RIGHT_GAIN_DESC'
}

/** A filter to be used against `Object` object types. All fields are combined with a logical ‘and.’ */
export type ObjectFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `readingat` field. */
  readingat?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `vehicleId` field. */
  vehicleId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `topicId` field. */
  topicId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `messageId` field. */
  messageId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: Maybe<DatetimeFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<ObjectFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<ObjectFilter>>;
  /** Negates the expression. */
  not?: Maybe<ObjectFilter>;
};

/** An input for mutations affecting `Object` */
export type ObjectInput = {
  readingat: Scalars['Datetime'];
};

/** The object message enu table for the object message section */
export type ObjectMessage = Node & {
  __typename?: 'ObjectMessage';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  /** The id of the row that is autoincremented */
  id: Scalars['BigInt'];
  /** The id provided by vehicle */
  referenceid: Scalars['BigInt'];
  /** The header id referencing the object message header row */
  headerId: Scalars['BigInt'];
  /** The detection id referencing the object message header row */
  detectionId: Scalars['BigInt'];
  /** The centroid rpy id referencing the object message header row */
  centroidRpyId: Scalars['BigInt'];
  /** The centroid location id referencing the object message header row */
  centroidLocationId: Scalars['BigInt'];
  /** The circle center id referencing the object message header row */
  circleCenterId: Scalars['BigInt'];
  /** The circle radius referencing the object message header row */
  circleRadiusM?: Maybe<Scalars['BigFloat']>;
  /** The on path boolean */
  onPath: Scalars['Boolean'];
  /** The is active path boolean */
  isActivePathSet: Scalars['Boolean'];
  /** The name of the camera */
  cameraName: Scalars['String'];
  /** The timestamp record added to database */
  createdAt: Scalars['Datetime'];
  /** The timestamp record updated to database */
  updatedAt: Scalars['Datetime'];
  /** Reads a single `ObjectMessageHeader` that is related to this `ObjectMessage`. */
  header?: Maybe<ObjectMessageHeader>;
  /** Reads a single `ObjectMessageDetection` that is related to this `ObjectMessage`. */
  detection?: Maybe<ObjectMessageDetection>;
  /** Reads a single `ObjectMessageCentroidRpy` that is related to this `ObjectMessage`. */
  centroidRpy?: Maybe<ObjectMessageCentroidRpy>;
  /** Reads a single `ObjectMessageCentroidLocation` that is related to this `ObjectMessage`. */
  centroidLocation?: Maybe<ObjectMessageCentroidLocation>;
  /** Reads a single `ObjectMessageCircleCenter` that is related to this `ObjectMessage`. */
  circleCenter?: Maybe<ObjectMessageCircleCenter>;
  /** Reads and enables pagination through a set of `ObjectMessageVertex`. */
  objectMessageVertices: ObjectMessageVerticesConnection;
  /** Reads and enables pagination through a set of `Object`. */
  objectsByMessageId: ObjectsConnection;
};


/** The object message enu table for the object message section */
export type ObjectMessageObjectMessageVerticesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ObjectMessageVerticesOrderBy>>;
  condition?: Maybe<ObjectMessageVertexCondition>;
  filter?: Maybe<ObjectMessageVertexFilter>;
};


/** The object message enu table for the object message section */
export type ObjectMessageObjectsByMessageIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ObjectsOrderBy>>;
  condition?: Maybe<ObjectCondition>;
  filter?: Maybe<ObjectFilter>;
};

/** The object message enu table for the object message section */
export type ObjectMessageCentroidLocation = Node & {
  __typename?: 'ObjectMessageCentroidLocation';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  /** The id of the row that is autoincremented */
  id: Scalars['BigInt'];
  /** The xyz camera id foreign key */
  xyzCameraId: Scalars['BigInt'];
  /** The xyz starfire id foreign key */
  xyzStarfireId: Scalars['BigInt'];
  /** The lla id foreign key */
  llaId: Scalars['BigInt'];
  /** The enu id foreign key */
  enuId: Scalars['BigInt'];
  /** The field origin id foreign key */
  fieldOriginId: Scalars['BigInt'];
  /** The ecef id of the row that is autoincremented */
  ecefId: Scalars['BigInt'];
  /** Reads a single `ObjectMessageXyzCamera` that is related to this `ObjectMessageCentroidLocation`. */
  xyzCamera?: Maybe<ObjectMessageXyzCamera>;
  /** Reads a single `ObjectMessageXyzStarfire` that is related to this `ObjectMessageCentroidLocation`. */
  xyzStarfire?: Maybe<ObjectMessageXyzStarfire>;
  /** Reads a single `ObjectMessageLla` that is related to this `ObjectMessageCentroidLocation`. */
  lla?: Maybe<ObjectMessageLla>;
  /** Reads a single `ObjectMessageEnu` that is related to this `ObjectMessageCentroidLocation`. */
  enu?: Maybe<ObjectMessageEnu>;
  /** Reads a single `ObjectMessageFieldOrigin` that is related to this `ObjectMessageCentroidLocation`. */
  fieldOrigin?: Maybe<ObjectMessageFieldOrigin>;
  /** Reads a single `ObjectMessageEcef` that is related to this `ObjectMessageCentroidLocation`. */
  ecef?: Maybe<ObjectMessageEcef>;
  /** Reads and enables pagination through a set of `ObjectMessage`. */
  objectMessagesByCentroidLocationId: ObjectMessagesConnection;
};


/** The object message enu table for the object message section */
export type ObjectMessageCentroidLocationObjectMessagesByCentroidLocationIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ObjectMessagesOrderBy>>;
  condition?: Maybe<ObjectMessageCondition>;
  filter?: Maybe<ObjectMessageFilter>;
};

/**
 * A condition to be used against `ObjectMessageCentroidLocation` object types. All
 * fields are tested for equality and combined with a logical ‘and.’
 */
export type ObjectMessageCentroidLocationCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `xyzCameraId` field. */
  xyzCameraId?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `xyzStarfireId` field. */
  xyzStarfireId?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `llaId` field. */
  llaId?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `enuId` field. */
  enuId?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `fieldOriginId` field. */
  fieldOriginId?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `ecefId` field. */
  ecefId?: Maybe<Scalars['BigInt']>;
};

/** A filter to be used against `ObjectMessageCentroidLocation` object types. All fields are combined with a logical ‘and.’ */
export type ObjectMessageCentroidLocationFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `xyzCameraId` field. */
  xyzCameraId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `xyzStarfireId` field. */
  xyzStarfireId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `llaId` field. */
  llaId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `enuId` field. */
  enuId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `fieldOriginId` field. */
  fieldOriginId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `ecefId` field. */
  ecefId?: Maybe<BigIntFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<ObjectMessageCentroidLocationFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<ObjectMessageCentroidLocationFilter>>;
  /** Negates the expression. */
  not?: Maybe<ObjectMessageCentroidLocationFilter>;
};

/** A connection to a list of `ObjectMessageCentroidLocation` values. */
export type ObjectMessageCentroidLocationsConnection = {
  __typename?: 'ObjectMessageCentroidLocationsConnection';
  /** A list of `ObjectMessageCentroidLocation` objects. */
  nodes: Array<Maybe<ObjectMessageCentroidLocation>>;
  /** A list of edges which contains the `ObjectMessageCentroidLocation` and cursor to aid in pagination. */
  edges: Array<ObjectMessageCentroidLocationsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ObjectMessageCentroidLocation` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `ObjectMessageCentroidLocation` edge in the connection. */
export type ObjectMessageCentroidLocationsEdge = {
  __typename?: 'ObjectMessageCentroidLocationsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `ObjectMessageCentroidLocation` at the end of the edge. */
  node?: Maybe<ObjectMessageCentroidLocation>;
};

/** Methods to use when ordering `ObjectMessageCentroidLocation`. */
export enum ObjectMessageCentroidLocationsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  XyzCameraIdAsc = 'XYZ_CAMERA_ID_ASC',
  XyzCameraIdDesc = 'XYZ_CAMERA_ID_DESC',
  XyzStarfireIdAsc = 'XYZ_STARFIRE_ID_ASC',
  XyzStarfireIdDesc = 'XYZ_STARFIRE_ID_DESC',
  LlaIdAsc = 'LLA_ID_ASC',
  LlaIdDesc = 'LLA_ID_DESC',
  EnuIdAsc = 'ENU_ID_ASC',
  EnuIdDesc = 'ENU_ID_DESC',
  FieldOriginIdAsc = 'FIELD_ORIGIN_ID_ASC',
  FieldOriginIdDesc = 'FIELD_ORIGIN_ID_DESC',
  EcefIdAsc = 'ECEF_ID_ASC',
  EcefIdDesc = 'ECEF_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/** A connection to a list of `ObjectMessageCentroidRpy` values. */
export type ObjectMessageCentroidRpiesConnection = {
  __typename?: 'ObjectMessageCentroidRpiesConnection';
  /** A list of `ObjectMessageCentroidRpy` objects. */
  nodes: Array<Maybe<ObjectMessageCentroidRpy>>;
  /** A list of edges which contains the `ObjectMessageCentroidRpy` and cursor to aid in pagination. */
  edges: Array<ObjectMessageCentroidRpiesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ObjectMessageCentroidRpy` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `ObjectMessageCentroidRpy` edge in the connection. */
export type ObjectMessageCentroidRpiesEdge = {
  __typename?: 'ObjectMessageCentroidRpiesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `ObjectMessageCentroidRpy` at the end of the edge. */
  node?: Maybe<ObjectMessageCentroidRpy>;
};

/** Methods to use when ordering `ObjectMessageCentroidRpy`. */
export enum ObjectMessageCentroidRpiesOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  RollDegAsc = 'ROLL_DEG_ASC',
  RollDegDesc = 'ROLL_DEG_DESC',
  PitchDegAsc = 'PITCH_DEG_ASC',
  PitchDegDesc = 'PITCH_DEG_DESC',
  YawDegAsc = 'YAW_DEG_ASC',
  YawDegDesc = 'YAW_DEG_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/** The object message detection centroid rpy table for the object message section */
export type ObjectMessageCentroidRpy = Node & {
  __typename?: 'ObjectMessageCentroidRpy';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  /** The id of the row that is autoincremented */
  id: Scalars['BigInt'];
  /** The degrees of the centroid rpy */
  rollDeg?: Maybe<Scalars['BigFloat']>;
  /** The pitch degrees of the centroid rpy */
  pitchDeg?: Maybe<Scalars['BigFloat']>;
  /** The yaw degrees of the centroid rpy */
  yawDeg?: Maybe<Scalars['BigFloat']>;
  /** Reads and enables pagination through a set of `ObjectMessage`. */
  objectMessagesByCentroidRpyId: ObjectMessagesConnection;
};


/** The object message detection centroid rpy table for the object message section */
export type ObjectMessageCentroidRpyObjectMessagesByCentroidRpyIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ObjectMessagesOrderBy>>;
  condition?: Maybe<ObjectMessageCondition>;
  filter?: Maybe<ObjectMessageFilter>;
};

/**
 * A condition to be used against `ObjectMessageCentroidRpy` object types. All
 * fields are tested for equality and combined with a logical ‘and.’
 */
export type ObjectMessageCentroidRpyCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `rollDeg` field. */
  rollDeg?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `pitchDeg` field. */
  pitchDeg?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `yawDeg` field. */
  yawDeg?: Maybe<Scalars['BigFloat']>;
};

/** A filter to be used against `ObjectMessageCentroidRpy` object types. All fields are combined with a logical ‘and.’ */
export type ObjectMessageCentroidRpyFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `rollDeg` field. */
  rollDeg?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `pitchDeg` field. */
  pitchDeg?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `yawDeg` field. */
  yawDeg?: Maybe<BigFloatFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<ObjectMessageCentroidRpyFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<ObjectMessageCentroidRpyFilter>>;
  /** Negates the expression. */
  not?: Maybe<ObjectMessageCentroidRpyFilter>;
};

/** The object message enu table for the object message section */
export type ObjectMessageCircleCenter = Node & {
  __typename?: 'ObjectMessageCircleCenter';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  /** The id of the row that is autoincremented */
  id: Scalars['BigInt'];
  /** The xyz camera id foreign key */
  xyzCameraId: Scalars['BigInt'];
  /** The xyz starfire id foreign key */
  xyzStarfireId: Scalars['BigInt'];
  /** The lla id foreign key */
  llaId: Scalars['BigInt'];
  /** The enu id foreign key */
  enuId: Scalars['BigInt'];
  /** The field origin id foreign key */
  fieldOriginId: Scalars['BigInt'];
  /** The ecef id of the row that is autoincremented */
  ecefId: Scalars['BigInt'];
  /** Reads a single `ObjectMessageXyzCamera` that is related to this `ObjectMessageCircleCenter`. */
  xyzCamera?: Maybe<ObjectMessageXyzCamera>;
  /** Reads a single `ObjectMessageXyzStarfire` that is related to this `ObjectMessageCircleCenter`. */
  xyzStarfire?: Maybe<ObjectMessageXyzStarfire>;
  /** Reads a single `ObjectMessageLla` that is related to this `ObjectMessageCircleCenter`. */
  lla?: Maybe<ObjectMessageLla>;
  /** Reads a single `ObjectMessageEnu` that is related to this `ObjectMessageCircleCenter`. */
  enu?: Maybe<ObjectMessageEnu>;
  /** Reads a single `ObjectMessageFieldOrigin` that is related to this `ObjectMessageCircleCenter`. */
  fieldOrigin?: Maybe<ObjectMessageFieldOrigin>;
  /** Reads a single `ObjectMessageEcef` that is related to this `ObjectMessageCircleCenter`. */
  ecef?: Maybe<ObjectMessageEcef>;
  /** Reads and enables pagination through a set of `ObjectMessage`. */
  objectMessagesByCircleCenterId: ObjectMessagesConnection;
};


/** The object message enu table for the object message section */
export type ObjectMessageCircleCenterObjectMessagesByCircleCenterIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ObjectMessagesOrderBy>>;
  condition?: Maybe<ObjectMessageCondition>;
  filter?: Maybe<ObjectMessageFilter>;
};

/**
 * A condition to be used against `ObjectMessageCircleCenter` object types. All
 * fields are tested for equality and combined with a logical ‘and.’
 */
export type ObjectMessageCircleCenterCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `xyzCameraId` field. */
  xyzCameraId?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `xyzStarfireId` field. */
  xyzStarfireId?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `llaId` field. */
  llaId?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `enuId` field. */
  enuId?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `fieldOriginId` field. */
  fieldOriginId?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `ecefId` field. */
  ecefId?: Maybe<Scalars['BigInt']>;
};

/** A filter to be used against `ObjectMessageCircleCenter` object types. All fields are combined with a logical ‘and.’ */
export type ObjectMessageCircleCenterFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `xyzCameraId` field. */
  xyzCameraId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `xyzStarfireId` field. */
  xyzStarfireId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `llaId` field. */
  llaId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `enuId` field. */
  enuId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `fieldOriginId` field. */
  fieldOriginId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `ecefId` field. */
  ecefId?: Maybe<BigIntFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<ObjectMessageCircleCenterFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<ObjectMessageCircleCenterFilter>>;
  /** Negates the expression. */
  not?: Maybe<ObjectMessageCircleCenterFilter>;
};

/** A connection to a list of `ObjectMessageCircleCenter` values. */
export type ObjectMessageCircleCentersConnection = {
  __typename?: 'ObjectMessageCircleCentersConnection';
  /** A list of `ObjectMessageCircleCenter` objects. */
  nodes: Array<Maybe<ObjectMessageCircleCenter>>;
  /** A list of edges which contains the `ObjectMessageCircleCenter` and cursor to aid in pagination. */
  edges: Array<ObjectMessageCircleCentersEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ObjectMessageCircleCenter` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `ObjectMessageCircleCenter` edge in the connection. */
export type ObjectMessageCircleCentersEdge = {
  __typename?: 'ObjectMessageCircleCentersEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `ObjectMessageCircleCenter` at the end of the edge. */
  node?: Maybe<ObjectMessageCircleCenter>;
};

/** Methods to use when ordering `ObjectMessageCircleCenter`. */
export enum ObjectMessageCircleCentersOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  XyzCameraIdAsc = 'XYZ_CAMERA_ID_ASC',
  XyzCameraIdDesc = 'XYZ_CAMERA_ID_DESC',
  XyzStarfireIdAsc = 'XYZ_STARFIRE_ID_ASC',
  XyzStarfireIdDesc = 'XYZ_STARFIRE_ID_DESC',
  LlaIdAsc = 'LLA_ID_ASC',
  LlaIdDesc = 'LLA_ID_DESC',
  EnuIdAsc = 'ENU_ID_ASC',
  EnuIdDesc = 'ENU_ID_DESC',
  FieldOriginIdAsc = 'FIELD_ORIGIN_ID_ASC',
  FieldOriginIdDesc = 'FIELD_ORIGIN_ID_DESC',
  EcefIdAsc = 'ECEF_ID_ASC',
  EcefIdDesc = 'ECEF_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/**
 * A condition to be used against `ObjectMessage` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type ObjectMessageCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `referenceid` field. */
  referenceid?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `headerId` field. */
  headerId?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `detectionId` field. */
  detectionId?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `centroidRpyId` field. */
  centroidRpyId?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `centroidLocationId` field. */
  centroidLocationId?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `circleCenterId` field. */
  circleCenterId?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `circleRadiusM` field. */
  circleRadiusM?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `onPath` field. */
  onPath?: Maybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `isActivePathSet` field. */
  isActivePathSet?: Maybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `cameraName` field. */
  cameraName?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: Maybe<Scalars['Datetime']>;
};

/** The object message detection table for the object message section */
export type ObjectMessageDetection = Node & {
  __typename?: 'ObjectMessageDetection';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  /** The id of the row that is autoincremented */
  id: Scalars['BigInt'];
  /** The header_id of the object message detection */
  headerId: Scalars['BigInt'];
  /** The cuboid id of the object message detection */
  cuboidId: Scalars['BigInt'];
  /** The roi id of the object message detection */
  roiId: Scalars['BigInt'];
  /** The label of the object message detection */
  label?: Maybe<Scalars['BigFloat']>;
  /** The confidence of the object message detection */
  confidence?: Maybe<Scalars['BigFloat']>;
  /** Reads a single `ObjectMessageDetectionHeader` that is related to this `ObjectMessageDetection`. */
  header?: Maybe<ObjectMessageDetectionHeader>;
  /** Reads a single `ObjectMessageDetectionCuboid` that is related to this `ObjectMessageDetection`. */
  cuboid?: Maybe<ObjectMessageDetectionCuboid>;
  /** Reads a single `ObjectMessageDetectionRoi` that is related to this `ObjectMessageDetection`. */
  roi?: Maybe<ObjectMessageDetectionRoi>;
  /** Reads and enables pagination through a set of `ObjectMessage`. */
  objectMessagesByDetectionId: ObjectMessagesConnection;
};


/** The object message detection table for the object message section */
export type ObjectMessageDetectionObjectMessagesByDetectionIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ObjectMessagesOrderBy>>;
  condition?: Maybe<ObjectMessageCondition>;
  filter?: Maybe<ObjectMessageFilter>;
};

/**
 * A condition to be used against `ObjectMessageDetection` object types. All fields
 * are tested for equality and combined with a logical ‘and.’
 */
export type ObjectMessageDetectionCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `headerId` field. */
  headerId?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `cuboidId` field. */
  cuboidId?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `roiId` field. */
  roiId?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `label` field. */
  label?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `confidence` field. */
  confidence?: Maybe<Scalars['BigFloat']>;
};

/** The object message detection cuboid table for the object message section */
export type ObjectMessageDetectionCuboid = Node & {
  __typename?: 'ObjectMessageDetectionCuboid';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  /** The id of the row that is autoincremented */
  id: Scalars['BigInt'];
  /** The id of the centroid row */
  centroidId: Scalars['BigInt'];
  /** The id of the dimension row */
  dimensionId: Scalars['BigInt'];
  /** The id of the orientation row */
  orientationId: Scalars['BigInt'];
  /** Reads a single `ObjectMessageDetectionCuboidCentroid` that is related to this `ObjectMessageDetectionCuboid`. */
  centroid?: Maybe<ObjectMessageDetectionCuboidCentroid>;
  /** Reads a single `ObjectMessageDetectionCuboidDimension` that is related to this `ObjectMessageDetectionCuboid`. */
  dimension?: Maybe<ObjectMessageDetectionCuboidDimension>;
  /** Reads a single `ObjectMessageDetectionCuboidOrientation` that is related to this `ObjectMessageDetectionCuboid`. */
  orientation?: Maybe<ObjectMessageDetectionCuboidOrientation>;
  /** Reads and enables pagination through a set of `ObjectMessageDetection`. */
  objectMessageDetectionsByCuboidId: ObjectMessageDetectionsConnection;
};


/** The object message detection cuboid table for the object message section */
export type ObjectMessageDetectionCuboidObjectMessageDetectionsByCuboidIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ObjectMessageDetectionsOrderBy>>;
  condition?: Maybe<ObjectMessageDetectionCondition>;
  filter?: Maybe<ObjectMessageDetectionFilter>;
};

/** The object message detection cuboid centroid table for the object message section */
export type ObjectMessageDetectionCuboidCentroid = Node & {
  __typename?: 'ObjectMessageDetectionCuboidCentroid';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  /** The id of the row that is autoincremented */
  id: Scalars['BigInt'];
  /** The x object location measurement in meters */
  xM?: Maybe<Scalars['BigFloat']>;
  /** The y object location measurement in meters */
  yM?: Maybe<Scalars['BigFloat']>;
  /** The z object location measurement in meters */
  zM?: Maybe<Scalars['BigFloat']>;
  /** Reads and enables pagination through a set of `ObjectMessageDetectionCuboid`. */
  objectMessageDetectionCuboidsByCentroidId: ObjectMessageDetectionCuboidsConnection;
};


/** The object message detection cuboid centroid table for the object message section */
export type ObjectMessageDetectionCuboidCentroidObjectMessageDetectionCuboidsByCentroidIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ObjectMessageDetectionCuboidsOrderBy>>;
  condition?: Maybe<ObjectMessageDetectionCuboidCondition>;
  filter?: Maybe<ObjectMessageDetectionCuboidFilter>;
};

/**
 * A condition to be used against `ObjectMessageDetectionCuboidCentroid` object
 * types. All fields are tested for equality and combined with a logical ‘and.’
 */
export type ObjectMessageDetectionCuboidCentroidCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `xM` field. */
  xM?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `yM` field. */
  yM?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `zM` field. */
  zM?: Maybe<Scalars['BigFloat']>;
};

/** A filter to be used against `ObjectMessageDetectionCuboidCentroid` object types. All fields are combined with a logical ‘and.’ */
export type ObjectMessageDetectionCuboidCentroidFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `xM` field. */
  xM?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `yM` field. */
  yM?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `zM` field. */
  zM?: Maybe<BigFloatFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<ObjectMessageDetectionCuboidCentroidFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<ObjectMessageDetectionCuboidCentroidFilter>>;
  /** Negates the expression. */
  not?: Maybe<ObjectMessageDetectionCuboidCentroidFilter>;
};

/** A connection to a list of `ObjectMessageDetectionCuboidCentroid` values. */
export type ObjectMessageDetectionCuboidCentroidsConnection = {
  __typename?: 'ObjectMessageDetectionCuboidCentroidsConnection';
  /** A list of `ObjectMessageDetectionCuboidCentroid` objects. */
  nodes: Array<Maybe<ObjectMessageDetectionCuboidCentroid>>;
  /** A list of edges which contains the `ObjectMessageDetectionCuboidCentroid` and cursor to aid in pagination. */
  edges: Array<ObjectMessageDetectionCuboidCentroidsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ObjectMessageDetectionCuboidCentroid` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `ObjectMessageDetectionCuboidCentroid` edge in the connection. */
export type ObjectMessageDetectionCuboidCentroidsEdge = {
  __typename?: 'ObjectMessageDetectionCuboidCentroidsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `ObjectMessageDetectionCuboidCentroid` at the end of the edge. */
  node?: Maybe<ObjectMessageDetectionCuboidCentroid>;
};

/** Methods to use when ordering `ObjectMessageDetectionCuboidCentroid`. */
export enum ObjectMessageDetectionCuboidCentroidsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  XMAsc = 'X_M_ASC',
  XMDesc = 'X_M_DESC',
  YMAsc = 'Y_M_ASC',
  YMDesc = 'Y_M_DESC',
  ZMAsc = 'Z_M_ASC',
  ZMDesc = 'Z_M_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/**
 * A condition to be used against `ObjectMessageDetectionCuboid` object types. All
 * fields are tested for equality and combined with a logical ‘and.’
 */
export type ObjectMessageDetectionCuboidCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `centroidId` field. */
  centroidId?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `dimensionId` field. */
  dimensionId?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `orientationId` field. */
  orientationId?: Maybe<Scalars['BigInt']>;
};

/** The object message detection cuboid dimension table for the object message section */
export type ObjectMessageDetectionCuboidDimension = Node & {
  __typename?: 'ObjectMessageDetectionCuboidDimension';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  /** The id of the row that is autoincremented */
  id: Scalars['BigInt'];
  /** The width object in meters */
  widthM?: Maybe<Scalars['BigFloat']>;
  /** The depth object in meters */
  depthM?: Maybe<Scalars['BigFloat']>;
  /** The height object in meters */
  heightM?: Maybe<Scalars['BigFloat']>;
  /** Reads and enables pagination through a set of `ObjectMessageDetectionCuboid`. */
  objectMessageDetectionCuboidsByDimensionId: ObjectMessageDetectionCuboidsConnection;
};


/** The object message detection cuboid dimension table for the object message section */
export type ObjectMessageDetectionCuboidDimensionObjectMessageDetectionCuboidsByDimensionIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ObjectMessageDetectionCuboidsOrderBy>>;
  condition?: Maybe<ObjectMessageDetectionCuboidCondition>;
  filter?: Maybe<ObjectMessageDetectionCuboidFilter>;
};

/**
 * A condition to be used against `ObjectMessageDetectionCuboidDimension` object
 * types. All fields are tested for equality and combined with a logical ‘and.’
 */
export type ObjectMessageDetectionCuboidDimensionCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `widthM` field. */
  widthM?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `depthM` field. */
  depthM?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `heightM` field. */
  heightM?: Maybe<Scalars['BigFloat']>;
};

/** A filter to be used against `ObjectMessageDetectionCuboidDimension` object types. All fields are combined with a logical ‘and.’ */
export type ObjectMessageDetectionCuboidDimensionFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `widthM` field. */
  widthM?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `depthM` field. */
  depthM?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `heightM` field. */
  heightM?: Maybe<BigFloatFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<ObjectMessageDetectionCuboidDimensionFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<ObjectMessageDetectionCuboidDimensionFilter>>;
  /** Negates the expression. */
  not?: Maybe<ObjectMessageDetectionCuboidDimensionFilter>;
};

/** A connection to a list of `ObjectMessageDetectionCuboidDimension` values. */
export type ObjectMessageDetectionCuboidDimensionsConnection = {
  __typename?: 'ObjectMessageDetectionCuboidDimensionsConnection';
  /** A list of `ObjectMessageDetectionCuboidDimension` objects. */
  nodes: Array<Maybe<ObjectMessageDetectionCuboidDimension>>;
  /** A list of edges which contains the `ObjectMessageDetectionCuboidDimension` and cursor to aid in pagination. */
  edges: Array<ObjectMessageDetectionCuboidDimensionsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ObjectMessageDetectionCuboidDimension` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `ObjectMessageDetectionCuboidDimension` edge in the connection. */
export type ObjectMessageDetectionCuboidDimensionsEdge = {
  __typename?: 'ObjectMessageDetectionCuboidDimensionsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `ObjectMessageDetectionCuboidDimension` at the end of the edge. */
  node?: Maybe<ObjectMessageDetectionCuboidDimension>;
};

/** Methods to use when ordering `ObjectMessageDetectionCuboidDimension`. */
export enum ObjectMessageDetectionCuboidDimensionsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  WidthMAsc = 'WIDTH_M_ASC',
  WidthMDesc = 'WIDTH_M_DESC',
  DepthMAsc = 'DEPTH_M_ASC',
  DepthMDesc = 'DEPTH_M_DESC',
  HeightMAsc = 'HEIGHT_M_ASC',
  HeightMDesc = 'HEIGHT_M_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/** A filter to be used against `ObjectMessageDetectionCuboid` object types. All fields are combined with a logical ‘and.’ */
export type ObjectMessageDetectionCuboidFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `centroidId` field. */
  centroidId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `dimensionId` field. */
  dimensionId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `orientationId` field. */
  orientationId?: Maybe<BigIntFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<ObjectMessageDetectionCuboidFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<ObjectMessageDetectionCuboidFilter>>;
  /** Negates the expression. */
  not?: Maybe<ObjectMessageDetectionCuboidFilter>;
};

/** The object message detection cuboid orientation table for the object message section */
export type ObjectMessageDetectionCuboidOrientation = Node & {
  __typename?: 'ObjectMessageDetectionCuboidOrientation';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  /** The id of the row that is autoincremented */
  id: Scalars['BigInt'];
  /** The roll degrees of the object detection */
  rollDeg?: Maybe<Scalars['BigFloat']>;
  /** The pitch degrees of the object detection */
  pitchDeg?: Maybe<Scalars['BigFloat']>;
  /** The yaw degrees of the object detection */
  yawDeg?: Maybe<Scalars['BigFloat']>;
  /** Reads and enables pagination through a set of `ObjectMessageDetectionCuboid`. */
  objectMessageDetectionCuboidsByOrientationId: ObjectMessageDetectionCuboidsConnection;
};


/** The object message detection cuboid orientation table for the object message section */
export type ObjectMessageDetectionCuboidOrientationObjectMessageDetectionCuboidsByOrientationIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ObjectMessageDetectionCuboidsOrderBy>>;
  condition?: Maybe<ObjectMessageDetectionCuboidCondition>;
  filter?: Maybe<ObjectMessageDetectionCuboidFilter>;
};

/**
 * A condition to be used against `ObjectMessageDetectionCuboidOrientation` object
 * types. All fields are tested for equality and combined with a logical ‘and.’
 */
export type ObjectMessageDetectionCuboidOrientationCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `rollDeg` field. */
  rollDeg?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `pitchDeg` field. */
  pitchDeg?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `yawDeg` field. */
  yawDeg?: Maybe<Scalars['BigFloat']>;
};

/** A filter to be used against `ObjectMessageDetectionCuboidOrientation` object types. All fields are combined with a logical ‘and.’ */
export type ObjectMessageDetectionCuboidOrientationFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `rollDeg` field. */
  rollDeg?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `pitchDeg` field. */
  pitchDeg?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `yawDeg` field. */
  yawDeg?: Maybe<BigFloatFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<ObjectMessageDetectionCuboidOrientationFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<ObjectMessageDetectionCuboidOrientationFilter>>;
  /** Negates the expression. */
  not?: Maybe<ObjectMessageDetectionCuboidOrientationFilter>;
};

/** A connection to a list of `ObjectMessageDetectionCuboidOrientation` values. */
export type ObjectMessageDetectionCuboidOrientationsConnection = {
  __typename?: 'ObjectMessageDetectionCuboidOrientationsConnection';
  /** A list of `ObjectMessageDetectionCuboidOrientation` objects. */
  nodes: Array<Maybe<ObjectMessageDetectionCuboidOrientation>>;
  /** A list of edges which contains the `ObjectMessageDetectionCuboidOrientation` and cursor to aid in pagination. */
  edges: Array<ObjectMessageDetectionCuboidOrientationsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ObjectMessageDetectionCuboidOrientation` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `ObjectMessageDetectionCuboidOrientation` edge in the connection. */
export type ObjectMessageDetectionCuboidOrientationsEdge = {
  __typename?: 'ObjectMessageDetectionCuboidOrientationsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `ObjectMessageDetectionCuboidOrientation` at the end of the edge. */
  node?: Maybe<ObjectMessageDetectionCuboidOrientation>;
};

/** Methods to use when ordering `ObjectMessageDetectionCuboidOrientation`. */
export enum ObjectMessageDetectionCuboidOrientationsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  RollDegAsc = 'ROLL_DEG_ASC',
  RollDegDesc = 'ROLL_DEG_DESC',
  PitchDegAsc = 'PITCH_DEG_ASC',
  PitchDegDesc = 'PITCH_DEG_DESC',
  YawDegAsc = 'YAW_DEG_ASC',
  YawDegDesc = 'YAW_DEG_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/** A connection to a list of `ObjectMessageDetectionCuboid` values. */
export type ObjectMessageDetectionCuboidsConnection = {
  __typename?: 'ObjectMessageDetectionCuboidsConnection';
  /** A list of `ObjectMessageDetectionCuboid` objects. */
  nodes: Array<Maybe<ObjectMessageDetectionCuboid>>;
  /** A list of edges which contains the `ObjectMessageDetectionCuboid` and cursor to aid in pagination. */
  edges: Array<ObjectMessageDetectionCuboidsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ObjectMessageDetectionCuboid` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `ObjectMessageDetectionCuboid` edge in the connection. */
export type ObjectMessageDetectionCuboidsEdge = {
  __typename?: 'ObjectMessageDetectionCuboidsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `ObjectMessageDetectionCuboid` at the end of the edge. */
  node?: Maybe<ObjectMessageDetectionCuboid>;
};

/** Methods to use when ordering `ObjectMessageDetectionCuboid`. */
export enum ObjectMessageDetectionCuboidsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  CentroidIdAsc = 'CENTROID_ID_ASC',
  CentroidIdDesc = 'CENTROID_ID_DESC',
  DimensionIdAsc = 'DIMENSION_ID_ASC',
  DimensionIdDesc = 'DIMENSION_ID_DESC',
  OrientationIdAsc = 'ORIENTATION_ID_ASC',
  OrientationIdDesc = 'ORIENTATION_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/** A filter to be used against `ObjectMessageDetection` object types. All fields are combined with a logical ‘and.’ */
export type ObjectMessageDetectionFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `headerId` field. */
  headerId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `cuboidId` field. */
  cuboidId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `roiId` field. */
  roiId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `label` field. */
  label?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `confidence` field. */
  confidence?: Maybe<BigFloatFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<ObjectMessageDetectionFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<ObjectMessageDetectionFilter>>;
  /** Negates the expression. */
  not?: Maybe<ObjectMessageDetectionFilter>;
};

/** The header table for the object message detection section */
export type ObjectMessageDetectionHeader = Node & {
  __typename?: 'ObjectMessageDetectionHeader';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  /** The id of the row that is autoincremented */
  id: Scalars['BigInt'];
  /** The header id for the object message detection section which is provided by the vehicle */
  headerid: Scalars['BigInt'];
  /** The readingAt is the timestamp provided by the vehicle */
  readingat: Scalars['Datetime'];
  /** The seq information in the object message detection section */
  seq: Scalars['Int'];
  /** The node associated with the readings */
  node: Scalars['String'];
  /** Reads and enables pagination through a set of `ObjectMessageDetection`. */
  objectMessageDetectionsByHeaderId: ObjectMessageDetectionsConnection;
};


/** The header table for the object message detection section */
export type ObjectMessageDetectionHeaderObjectMessageDetectionsByHeaderIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ObjectMessageDetectionsOrderBy>>;
  condition?: Maybe<ObjectMessageDetectionCondition>;
  filter?: Maybe<ObjectMessageDetectionFilter>;
};

/**
 * A condition to be used against `ObjectMessageDetectionHeader` object types. All
 * fields are tested for equality and combined with a logical ‘and.’
 */
export type ObjectMessageDetectionHeaderCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `headerid` field. */
  headerid?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `readingat` field. */
  readingat?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `seq` field. */
  seq?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `node` field. */
  node?: Maybe<Scalars['String']>;
};

/** A filter to be used against `ObjectMessageDetectionHeader` object types. All fields are combined with a logical ‘and.’ */
export type ObjectMessageDetectionHeaderFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `headerid` field. */
  headerid?: Maybe<BigIntFilter>;
  /** Filter by the object’s `readingat` field. */
  readingat?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `seq` field. */
  seq?: Maybe<IntFilter>;
  /** Filter by the object’s `node` field. */
  node?: Maybe<StringFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<ObjectMessageDetectionHeaderFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<ObjectMessageDetectionHeaderFilter>>;
  /** Negates the expression. */
  not?: Maybe<ObjectMessageDetectionHeaderFilter>;
};

/** A connection to a list of `ObjectMessageDetectionHeader` values. */
export type ObjectMessageDetectionHeadersConnection = {
  __typename?: 'ObjectMessageDetectionHeadersConnection';
  /** A list of `ObjectMessageDetectionHeader` objects. */
  nodes: Array<Maybe<ObjectMessageDetectionHeader>>;
  /** A list of edges which contains the `ObjectMessageDetectionHeader` and cursor to aid in pagination. */
  edges: Array<ObjectMessageDetectionHeadersEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ObjectMessageDetectionHeader` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `ObjectMessageDetectionHeader` edge in the connection. */
export type ObjectMessageDetectionHeadersEdge = {
  __typename?: 'ObjectMessageDetectionHeadersEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `ObjectMessageDetectionHeader` at the end of the edge. */
  node?: Maybe<ObjectMessageDetectionHeader>;
};

/** Methods to use when ordering `ObjectMessageDetectionHeader`. */
export enum ObjectMessageDetectionHeadersOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  HeaderidAsc = 'HEADERID_ASC',
  HeaderidDesc = 'HEADERID_DESC',
  ReadingatAsc = 'READINGAT_ASC',
  ReadingatDesc = 'READINGAT_DESC',
  SeqAsc = 'SEQ_ASC',
  SeqDesc = 'SEQ_DESC',
  NodeAsc = 'NODE_ASC',
  NodeDesc = 'NODE_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/** The object message detection roi table for the object message section */
export type ObjectMessageDetectionRoi = Node & {
  __typename?: 'ObjectMessageDetectionRoi';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  /** The id of the row that is autoincremented */
  id: Scalars['BigInt'];
  /** The x location of roi */
  x?: Maybe<Scalars['BigFloat']>;
  /** The y location of roi */
  y?: Maybe<Scalars['BigFloat']>;
  /** The width of roi */
  width?: Maybe<Scalars['BigFloat']>;
  /** The height of roi */
  height?: Maybe<Scalars['BigFloat']>;
  /** The theta degrees location of roi */
  thetaDeg?: Maybe<Scalars['BigFloat']>;
  /** Reads and enables pagination through a set of `ObjectMessageDetection`. */
  objectMessageDetectionsByRoiId: ObjectMessageDetectionsConnection;
};


/** The object message detection roi table for the object message section */
export type ObjectMessageDetectionRoiObjectMessageDetectionsByRoiIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ObjectMessageDetectionsOrderBy>>;
  condition?: Maybe<ObjectMessageDetectionCondition>;
  filter?: Maybe<ObjectMessageDetectionFilter>;
};

/**
 * A condition to be used against `ObjectMessageDetectionRoi` object types. All
 * fields are tested for equality and combined with a logical ‘and.’
 */
export type ObjectMessageDetectionRoiCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `x` field. */
  x?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `y` field. */
  y?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `width` field. */
  width?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `height` field. */
  height?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `thetaDeg` field. */
  thetaDeg?: Maybe<Scalars['BigFloat']>;
};

/** A filter to be used against `ObjectMessageDetectionRoi` object types. All fields are combined with a logical ‘and.’ */
export type ObjectMessageDetectionRoiFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `x` field. */
  x?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `y` field. */
  y?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `width` field. */
  width?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `height` field. */
  height?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `thetaDeg` field. */
  thetaDeg?: Maybe<BigFloatFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<ObjectMessageDetectionRoiFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<ObjectMessageDetectionRoiFilter>>;
  /** Negates the expression. */
  not?: Maybe<ObjectMessageDetectionRoiFilter>;
};

/** A connection to a list of `ObjectMessageDetectionRoi` values. */
export type ObjectMessageDetectionRoisConnection = {
  __typename?: 'ObjectMessageDetectionRoisConnection';
  /** A list of `ObjectMessageDetectionRoi` objects. */
  nodes: Array<Maybe<ObjectMessageDetectionRoi>>;
  /** A list of edges which contains the `ObjectMessageDetectionRoi` and cursor to aid in pagination. */
  edges: Array<ObjectMessageDetectionRoisEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ObjectMessageDetectionRoi` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `ObjectMessageDetectionRoi` edge in the connection. */
export type ObjectMessageDetectionRoisEdge = {
  __typename?: 'ObjectMessageDetectionRoisEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `ObjectMessageDetectionRoi` at the end of the edge. */
  node?: Maybe<ObjectMessageDetectionRoi>;
};

/** Methods to use when ordering `ObjectMessageDetectionRoi`. */
export enum ObjectMessageDetectionRoisOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  XAsc = 'X_ASC',
  XDesc = 'X_DESC',
  YAsc = 'Y_ASC',
  YDesc = 'Y_DESC',
  WidthAsc = 'WIDTH_ASC',
  WidthDesc = 'WIDTH_DESC',
  HeightAsc = 'HEIGHT_ASC',
  HeightDesc = 'HEIGHT_DESC',
  ThetaDegAsc = 'THETA_DEG_ASC',
  ThetaDegDesc = 'THETA_DEG_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/** A connection to a list of `ObjectMessageDetection` values. */
export type ObjectMessageDetectionsConnection = {
  __typename?: 'ObjectMessageDetectionsConnection';
  /** A list of `ObjectMessageDetection` objects. */
  nodes: Array<Maybe<ObjectMessageDetection>>;
  /** A list of edges which contains the `ObjectMessageDetection` and cursor to aid in pagination. */
  edges: Array<ObjectMessageDetectionsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ObjectMessageDetection` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `ObjectMessageDetection` edge in the connection. */
export type ObjectMessageDetectionsEdge = {
  __typename?: 'ObjectMessageDetectionsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `ObjectMessageDetection` at the end of the edge. */
  node?: Maybe<ObjectMessageDetection>;
};

/** Methods to use when ordering `ObjectMessageDetection`. */
export enum ObjectMessageDetectionsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  HeaderIdAsc = 'HEADER_ID_ASC',
  HeaderIdDesc = 'HEADER_ID_DESC',
  CuboidIdAsc = 'CUBOID_ID_ASC',
  CuboidIdDesc = 'CUBOID_ID_DESC',
  RoiIdAsc = 'ROI_ID_ASC',
  RoiIdDesc = 'ROI_ID_DESC',
  LabelAsc = 'LABEL_ASC',
  LabelDesc = 'LABEL_DESC',
  ConfidenceAsc = 'CONFIDENCE_ASC',
  ConfidenceDesc = 'CONFIDENCE_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/** The object message enu table for the object message section */
export type ObjectMessageEcef = Node & {
  __typename?: 'ObjectMessageEcef';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  /** The id of the row that is autoincremented */
  id: Scalars['BigInt'];
  /** The x location measured in meters for object message xecef */
  xM?: Maybe<Scalars['BigFloat']>;
  /** The y location measured in meters for object message xecef */
  yM?: Maybe<Scalars['BigFloat']>;
  /** The z location measured in meters for object message xecef */
  zM?: Maybe<Scalars['BigFloat']>;
  /** Reads and enables pagination through a set of `ObjectMessageCentroidLocation`. */
  objectMessageCentroidLocationsByEcefId: ObjectMessageCentroidLocationsConnection;
  /** Reads and enables pagination through a set of `ObjectMessageCircleCenter`. */
  objectMessageCircleCentersByEcefId: ObjectMessageCircleCentersConnection;
  /** Reads and enables pagination through a set of `ObjectMessageVertex`. */
  objectMessageVerticesByEcefId: ObjectMessageVerticesConnection;
};


/** The object message enu table for the object message section */
export type ObjectMessageEcefObjectMessageCentroidLocationsByEcefIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ObjectMessageCentroidLocationsOrderBy>>;
  condition?: Maybe<ObjectMessageCentroidLocationCondition>;
  filter?: Maybe<ObjectMessageCentroidLocationFilter>;
};


/** The object message enu table for the object message section */
export type ObjectMessageEcefObjectMessageCircleCentersByEcefIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ObjectMessageCircleCentersOrderBy>>;
  condition?: Maybe<ObjectMessageCircleCenterCondition>;
  filter?: Maybe<ObjectMessageCircleCenterFilter>;
};


/** The object message enu table for the object message section */
export type ObjectMessageEcefObjectMessageVerticesByEcefIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ObjectMessageVerticesOrderBy>>;
  condition?: Maybe<ObjectMessageVertexCondition>;
  filter?: Maybe<ObjectMessageVertexFilter>;
};

/**
 * A condition to be used against `ObjectMessageEcef` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type ObjectMessageEcefCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `xM` field. */
  xM?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `yM` field. */
  yM?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `zM` field. */
  zM?: Maybe<Scalars['BigFloat']>;
};

/** A filter to be used against `ObjectMessageEcef` object types. All fields are combined with a logical ‘and.’ */
export type ObjectMessageEcefFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `xM` field. */
  xM?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `yM` field. */
  yM?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `zM` field. */
  zM?: Maybe<BigFloatFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<ObjectMessageEcefFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<ObjectMessageEcefFilter>>;
  /** Negates the expression. */
  not?: Maybe<ObjectMessageEcefFilter>;
};

/** A connection to a list of `ObjectMessageEcef` values. */
export type ObjectMessageEcefsConnection = {
  __typename?: 'ObjectMessageEcefsConnection';
  /** A list of `ObjectMessageEcef` objects. */
  nodes: Array<Maybe<ObjectMessageEcef>>;
  /** A list of edges which contains the `ObjectMessageEcef` and cursor to aid in pagination. */
  edges: Array<ObjectMessageEcefsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ObjectMessageEcef` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `ObjectMessageEcef` edge in the connection. */
export type ObjectMessageEcefsEdge = {
  __typename?: 'ObjectMessageEcefsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `ObjectMessageEcef` at the end of the edge. */
  node?: Maybe<ObjectMessageEcef>;
};

/** Methods to use when ordering `ObjectMessageEcef`. */
export enum ObjectMessageEcefsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  XMAsc = 'X_M_ASC',
  XMDesc = 'X_M_DESC',
  YMAsc = 'Y_M_ASC',
  YMDesc = 'Y_M_DESC',
  ZMAsc = 'Z_M_ASC',
  ZMDesc = 'Z_M_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/** The object message enu table for the object message section */
export type ObjectMessageEnu = Node & {
  __typename?: 'ObjectMessageEnu';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  /** The id of the row that is autoincremented */
  id: Scalars['BigInt'];
  /** The east direction in meeters */
  eastM?: Maybe<Scalars['BigFloat']>;
  /** The north direction in meeters */
  northM?: Maybe<Scalars['BigFloat']>;
  /** The up direction in meeters */
  upM?: Maybe<Scalars['BigFloat']>;
  /** Reads and enables pagination through a set of `ObjectMessageCentroidLocation`. */
  objectMessageCentroidLocationsByEnuId: ObjectMessageCentroidLocationsConnection;
  /** Reads and enables pagination through a set of `ObjectMessageCircleCenter`. */
  objectMessageCircleCentersByEnuId: ObjectMessageCircleCentersConnection;
  /** Reads and enables pagination through a set of `ObjectMessageVertex`. */
  objectMessageVerticesByEnuId: ObjectMessageVerticesConnection;
};


/** The object message enu table for the object message section */
export type ObjectMessageEnuObjectMessageCentroidLocationsByEnuIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ObjectMessageCentroidLocationsOrderBy>>;
  condition?: Maybe<ObjectMessageCentroidLocationCondition>;
  filter?: Maybe<ObjectMessageCentroidLocationFilter>;
};


/** The object message enu table for the object message section */
export type ObjectMessageEnuObjectMessageCircleCentersByEnuIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ObjectMessageCircleCentersOrderBy>>;
  condition?: Maybe<ObjectMessageCircleCenterCondition>;
  filter?: Maybe<ObjectMessageCircleCenterFilter>;
};


/** The object message enu table for the object message section */
export type ObjectMessageEnuObjectMessageVerticesByEnuIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ObjectMessageVerticesOrderBy>>;
  condition?: Maybe<ObjectMessageVertexCondition>;
  filter?: Maybe<ObjectMessageVertexFilter>;
};

/**
 * A condition to be used against `ObjectMessageEnu` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type ObjectMessageEnuCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `eastM` field. */
  eastM?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `northM` field. */
  northM?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `upM` field. */
  upM?: Maybe<Scalars['BigFloat']>;
};

/** A filter to be used against `ObjectMessageEnu` object types. All fields are combined with a logical ‘and.’ */
export type ObjectMessageEnuFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `eastM` field. */
  eastM?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `northM` field. */
  northM?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `upM` field. */
  upM?: Maybe<BigFloatFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<ObjectMessageEnuFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<ObjectMessageEnuFilter>>;
  /** Negates the expression. */
  not?: Maybe<ObjectMessageEnuFilter>;
};

/** A connection to a list of `ObjectMessageEnu` values. */
export type ObjectMessageEnusConnection = {
  __typename?: 'ObjectMessageEnusConnection';
  /** A list of `ObjectMessageEnu` objects. */
  nodes: Array<Maybe<ObjectMessageEnu>>;
  /** A list of edges which contains the `ObjectMessageEnu` and cursor to aid in pagination. */
  edges: Array<ObjectMessageEnusEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ObjectMessageEnu` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `ObjectMessageEnu` edge in the connection. */
export type ObjectMessageEnusEdge = {
  __typename?: 'ObjectMessageEnusEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `ObjectMessageEnu` at the end of the edge. */
  node?: Maybe<ObjectMessageEnu>;
};

/** Methods to use when ordering `ObjectMessageEnu`. */
export enum ObjectMessageEnusOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  EastMAsc = 'EAST_M_ASC',
  EastMDesc = 'EAST_M_DESC',
  NorthMAsc = 'NORTH_M_ASC',
  NorthMDesc = 'NORTH_M_DESC',
  UpMAsc = 'UP_M_ASC',
  UpMDesc = 'UP_M_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/** The object message enu table for the object message section */
export type ObjectMessageFieldOrigin = Node & {
  __typename?: 'ObjectMessageFieldOrigin';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  /** The id of the row that is autoincremented */
  id: Scalars['BigInt'];
  latitudeDeg?: Maybe<Scalars['BigFloat']>;
  /** The longitude in degrees */
  longitudeDeg?: Maybe<Scalars['BigFloat']>;
  /** The altitude in degrees */
  altitudeM?: Maybe<Scalars['BigFloat']>;
  /** Reads and enables pagination through a set of `ObjectMessageCentroidLocation`. */
  objectMessageCentroidLocationsByFieldOriginId: ObjectMessageCentroidLocationsConnection;
  /** Reads and enables pagination through a set of `ObjectMessageCircleCenter`. */
  objectMessageCircleCentersByFieldOriginId: ObjectMessageCircleCentersConnection;
  /** Reads and enables pagination through a set of `ObjectMessageVertex`. */
  objectMessageVerticesByFieldOriginId: ObjectMessageVerticesConnection;
};


/** The object message enu table for the object message section */
export type ObjectMessageFieldOriginObjectMessageCentroidLocationsByFieldOriginIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ObjectMessageCentroidLocationsOrderBy>>;
  condition?: Maybe<ObjectMessageCentroidLocationCondition>;
  filter?: Maybe<ObjectMessageCentroidLocationFilter>;
};


/** The object message enu table for the object message section */
export type ObjectMessageFieldOriginObjectMessageCircleCentersByFieldOriginIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ObjectMessageCircleCentersOrderBy>>;
  condition?: Maybe<ObjectMessageCircleCenterCondition>;
  filter?: Maybe<ObjectMessageCircleCenterFilter>;
};


/** The object message enu table for the object message section */
export type ObjectMessageFieldOriginObjectMessageVerticesByFieldOriginIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ObjectMessageVerticesOrderBy>>;
  condition?: Maybe<ObjectMessageVertexCondition>;
  filter?: Maybe<ObjectMessageVertexFilter>;
};

/**
 * A condition to be used against `ObjectMessageFieldOrigin` object types. All
 * fields are tested for equality and combined with a logical ‘and.’
 */
export type ObjectMessageFieldOriginCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `latitudeDeg` field. */
  latitudeDeg?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `longitudeDeg` field. */
  longitudeDeg?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `altitudeM` field. */
  altitudeM?: Maybe<Scalars['BigFloat']>;
};

/** A filter to be used against `ObjectMessageFieldOrigin` object types. All fields are combined with a logical ‘and.’ */
export type ObjectMessageFieldOriginFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `latitudeDeg` field. */
  latitudeDeg?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `longitudeDeg` field. */
  longitudeDeg?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `altitudeM` field. */
  altitudeM?: Maybe<BigFloatFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<ObjectMessageFieldOriginFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<ObjectMessageFieldOriginFilter>>;
  /** Negates the expression. */
  not?: Maybe<ObjectMessageFieldOriginFilter>;
};

/** An input for mutations affecting `ObjectMessageFieldOrigin` */
export type ObjectMessageFieldOriginInput = {
  latitudeDeg?: Maybe<Scalars['BigFloat']>;
};

/** Represents an update to a `ObjectMessageFieldOrigin`. Fields that are set will be updated. */
export type ObjectMessageFieldOriginPatch = {
  latitudeDeg?: Maybe<Scalars['BigFloat']>;
};

/** A connection to a list of `ObjectMessageFieldOrigin` values. */
export type ObjectMessageFieldOriginsConnection = {
  __typename?: 'ObjectMessageFieldOriginsConnection';
  /** A list of `ObjectMessageFieldOrigin` objects. */
  nodes: Array<Maybe<ObjectMessageFieldOrigin>>;
  /** A list of edges which contains the `ObjectMessageFieldOrigin` and cursor to aid in pagination. */
  edges: Array<ObjectMessageFieldOriginsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ObjectMessageFieldOrigin` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `ObjectMessageFieldOrigin` edge in the connection. */
export type ObjectMessageFieldOriginsEdge = {
  __typename?: 'ObjectMessageFieldOriginsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `ObjectMessageFieldOrigin` at the end of the edge. */
  node?: Maybe<ObjectMessageFieldOrigin>;
};

/** Methods to use when ordering `ObjectMessageFieldOrigin`. */
export enum ObjectMessageFieldOriginsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  LatitudeDegAsc = 'LATITUDE_DEG_ASC',
  LatitudeDegDesc = 'LATITUDE_DEG_DESC',
  LongitudeDegAsc = 'LONGITUDE_DEG_ASC',
  LongitudeDegDesc = 'LONGITUDE_DEG_DESC',
  AltitudeMAsc = 'ALTITUDE_M_ASC',
  AltitudeMDesc = 'ALTITUDE_M_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/** A filter to be used against `ObjectMessage` object types. All fields are combined with a logical ‘and.’ */
export type ObjectMessageFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `referenceid` field. */
  referenceid?: Maybe<BigIntFilter>;
  /** Filter by the object’s `headerId` field. */
  headerId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `detectionId` field. */
  detectionId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `centroidRpyId` field. */
  centroidRpyId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `centroidLocationId` field. */
  centroidLocationId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `circleCenterId` field. */
  circleCenterId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `circleRadiusM` field. */
  circleRadiusM?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `onPath` field. */
  onPath?: Maybe<BooleanFilter>;
  /** Filter by the object’s `isActivePathSet` field. */
  isActivePathSet?: Maybe<BooleanFilter>;
  /** Filter by the object’s `cameraName` field. */
  cameraName?: Maybe<StringFilter>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: Maybe<DatetimeFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<ObjectMessageFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<ObjectMessageFilter>>;
  /** Negates the expression. */
  not?: Maybe<ObjectMessageFilter>;
};

/** The header table for an object message */
export type ObjectMessageHeader = Node & {
  __typename?: 'ObjectMessageHeader';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  /** The id of the row that is autoincremented */
  id: Scalars['BigInt'];
  /** The header id of message header which is provided by the vehicle */
  headerid: Scalars['BigInt'];
  /** The seq information in the message header */
  seq: Scalars['Int'];
  /** The node associated with the readings */
  node: Scalars['String'];
  /** The readingAt is the timestamp provided by the vehicle */
  readingat: Scalars['Datetime'];
  createdAt: Scalars['Datetime'];
  updatedAt: Scalars['Datetime'];
  /** Reads and enables pagination through a set of `ObjectMessage`. */
  objectMessagesByHeaderId: ObjectMessagesConnection;
};


/** The header table for an object message */
export type ObjectMessageHeaderObjectMessagesByHeaderIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ObjectMessagesOrderBy>>;
  condition?: Maybe<ObjectMessageCondition>;
  filter?: Maybe<ObjectMessageFilter>;
};

/**
 * A condition to be used against `ObjectMessageHeader` object types. All fields
 * are tested for equality and combined with a logical ‘and.’
 */
export type ObjectMessageHeaderCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `headerid` field. */
  headerid?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `seq` field. */
  seq?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `node` field. */
  node?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `readingat` field. */
  readingat?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: Maybe<Scalars['Datetime']>;
};

/** A filter to be used against `ObjectMessageHeader` object types. All fields are combined with a logical ‘and.’ */
export type ObjectMessageHeaderFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `headerid` field. */
  headerid?: Maybe<BigIntFilter>;
  /** Filter by the object’s `seq` field. */
  seq?: Maybe<IntFilter>;
  /** Filter by the object’s `node` field. */
  node?: Maybe<StringFilter>;
  /** Filter by the object’s `readingat` field. */
  readingat?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: Maybe<DatetimeFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<ObjectMessageHeaderFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<ObjectMessageHeaderFilter>>;
  /** Negates the expression. */
  not?: Maybe<ObjectMessageHeaderFilter>;
};

/** An input for mutations affecting `ObjectMessageHeader` */
export type ObjectMessageHeaderInput = {
  createdAt?: Maybe<Scalars['Datetime']>;
  updatedAt?: Maybe<Scalars['Datetime']>;
};

/** Represents an update to a `ObjectMessageHeader`. Fields that are set will be updated. */
export type ObjectMessageHeaderPatch = {
  createdAt?: Maybe<Scalars['Datetime']>;
  updatedAt?: Maybe<Scalars['Datetime']>;
};

/** A connection to a list of `ObjectMessageHeader` values. */
export type ObjectMessageHeadersConnection = {
  __typename?: 'ObjectMessageHeadersConnection';
  /** A list of `ObjectMessageHeader` objects. */
  nodes: Array<Maybe<ObjectMessageHeader>>;
  /** A list of edges which contains the `ObjectMessageHeader` and cursor to aid in pagination. */
  edges: Array<ObjectMessageHeadersEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ObjectMessageHeader` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `ObjectMessageHeader` edge in the connection. */
export type ObjectMessageHeadersEdge = {
  __typename?: 'ObjectMessageHeadersEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `ObjectMessageHeader` at the end of the edge. */
  node?: Maybe<ObjectMessageHeader>;
};

/** Methods to use when ordering `ObjectMessageHeader`. */
export enum ObjectMessageHeadersOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  HeaderidAsc = 'HEADERID_ASC',
  HeaderidDesc = 'HEADERID_DESC',
  SeqAsc = 'SEQ_ASC',
  SeqDesc = 'SEQ_DESC',
  NodeAsc = 'NODE_ASC',
  NodeDesc = 'NODE_DESC',
  ReadingatAsc = 'READINGAT_ASC',
  ReadingatDesc = 'READINGAT_DESC',
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/** The object message lla table for the object message section */
export type ObjectMessageLla = Node & {
  __typename?: 'ObjectMessageLla';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  /** The id of the row that is autoincremented */
  id: Scalars['BigInt'];
  /** The latitude in degrees */
  latitudeDeg?: Maybe<Scalars['BigFloat']>;
  /** The longitude in degrees */
  longitudeDeg?: Maybe<Scalars['BigFloat']>;
  /** The altitude in meters */
  altitudeM?: Maybe<Scalars['BigFloat']>;
  /** Reads and enables pagination through a set of `ObjectMessageCentroidLocation`. */
  objectMessageCentroidLocationsByLlaId: ObjectMessageCentroidLocationsConnection;
  /** Reads and enables pagination through a set of `ObjectMessageCircleCenter`. */
  objectMessageCircleCentersByLlaId: ObjectMessageCircleCentersConnection;
  /** Reads and enables pagination through a set of `ObjectMessageVertex`. */
  objectMessageVerticesByLlaId: ObjectMessageVerticesConnection;
};


/** The object message lla table for the object message section */
export type ObjectMessageLlaObjectMessageCentroidLocationsByLlaIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ObjectMessageCentroidLocationsOrderBy>>;
  condition?: Maybe<ObjectMessageCentroidLocationCondition>;
  filter?: Maybe<ObjectMessageCentroidLocationFilter>;
};


/** The object message lla table for the object message section */
export type ObjectMessageLlaObjectMessageCircleCentersByLlaIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ObjectMessageCircleCentersOrderBy>>;
  condition?: Maybe<ObjectMessageCircleCenterCondition>;
  filter?: Maybe<ObjectMessageCircleCenterFilter>;
};


/** The object message lla table for the object message section */
export type ObjectMessageLlaObjectMessageVerticesByLlaIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ObjectMessageVerticesOrderBy>>;
  condition?: Maybe<ObjectMessageVertexCondition>;
  filter?: Maybe<ObjectMessageVertexFilter>;
};

/**
 * A condition to be used against `ObjectMessageLla` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type ObjectMessageLlaCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `latitudeDeg` field. */
  latitudeDeg?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `longitudeDeg` field. */
  longitudeDeg?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `altitudeM` field. */
  altitudeM?: Maybe<Scalars['BigFloat']>;
};

/** A filter to be used against `ObjectMessageLla` object types. All fields are combined with a logical ‘and.’ */
export type ObjectMessageLlaFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `latitudeDeg` field. */
  latitudeDeg?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `longitudeDeg` field. */
  longitudeDeg?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `altitudeM` field. */
  altitudeM?: Maybe<BigFloatFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<ObjectMessageLlaFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<ObjectMessageLlaFilter>>;
  /** Negates the expression. */
  not?: Maybe<ObjectMessageLlaFilter>;
};

/** A connection to a list of `ObjectMessageLla` values. */
export type ObjectMessageLlasConnection = {
  __typename?: 'ObjectMessageLlasConnection';
  /** A list of `ObjectMessageLla` objects. */
  nodes: Array<Maybe<ObjectMessageLla>>;
  /** A list of edges which contains the `ObjectMessageLla` and cursor to aid in pagination. */
  edges: Array<ObjectMessageLlasEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ObjectMessageLla` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `ObjectMessageLla` edge in the connection. */
export type ObjectMessageLlasEdge = {
  __typename?: 'ObjectMessageLlasEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `ObjectMessageLla` at the end of the edge. */
  node?: Maybe<ObjectMessageLla>;
};

/** Methods to use when ordering `ObjectMessageLla`. */
export enum ObjectMessageLlasOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  LatitudeDegAsc = 'LATITUDE_DEG_ASC',
  LatitudeDegDesc = 'LATITUDE_DEG_DESC',
  LongitudeDegAsc = 'LONGITUDE_DEG_ASC',
  LongitudeDegDesc = 'LONGITUDE_DEG_DESC',
  AltitudeMAsc = 'ALTITUDE_M_ASC',
  AltitudeMDesc = 'ALTITUDE_M_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/** The object message enu table for the object message section */
export type ObjectMessageVertex = Node & {
  __typename?: 'ObjectMessageVertex';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  /** The id of the row that is autoincremented */
  id: Scalars['BigInt'];
  /** The object message id linked to the object_message table */
  objectMessageId: Scalars['BigInt'];
  /** The xyz camera id foreign key */
  xyzCameraId: Scalars['BigInt'];
  /** The xyz starfire id foreign key */
  xyzStarfireId: Scalars['BigInt'];
  /** The lla id foreign key */
  llaId: Scalars['BigInt'];
  /** The enu id foreign key */
  enuId: Scalars['BigInt'];
  /** The field origin id foreign key */
  fieldOriginId: Scalars['BigInt'];
  /** The ecef id of the row that is autoincremented */
  ecefId: Scalars['BigInt'];
  /** Reads a single `ObjectMessage` that is related to this `ObjectMessageVertex`. */
  objectMessage?: Maybe<ObjectMessage>;
  /** Reads a single `ObjectMessageXyzCamera` that is related to this `ObjectMessageVertex`. */
  xyzCamera?: Maybe<ObjectMessageXyzCamera>;
  /** Reads a single `ObjectMessageXyzStarfire` that is related to this `ObjectMessageVertex`. */
  xyzStarfire?: Maybe<ObjectMessageXyzStarfire>;
  /** Reads a single `ObjectMessageLla` that is related to this `ObjectMessageVertex`. */
  lla?: Maybe<ObjectMessageLla>;
  /** Reads a single `ObjectMessageEnu` that is related to this `ObjectMessageVertex`. */
  enu?: Maybe<ObjectMessageEnu>;
  /** Reads a single `ObjectMessageFieldOrigin` that is related to this `ObjectMessageVertex`. */
  fieldOrigin?: Maybe<ObjectMessageFieldOrigin>;
  /** Reads a single `ObjectMessageEcef` that is related to this `ObjectMessageVertex`. */
  ecef?: Maybe<ObjectMessageEcef>;
};

/**
 * A condition to be used against `ObjectMessageVertex` object types. All fields
 * are tested for equality and combined with a logical ‘and.’
 */
export type ObjectMessageVertexCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `objectMessageId` field. */
  objectMessageId?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `xyzCameraId` field. */
  xyzCameraId?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `xyzStarfireId` field. */
  xyzStarfireId?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `llaId` field. */
  llaId?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `enuId` field. */
  enuId?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `fieldOriginId` field. */
  fieldOriginId?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `ecefId` field. */
  ecefId?: Maybe<Scalars['BigInt']>;
};

/** A filter to be used against `ObjectMessageVertex` object types. All fields are combined with a logical ‘and.’ */
export type ObjectMessageVertexFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `objectMessageId` field. */
  objectMessageId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `xyzCameraId` field. */
  xyzCameraId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `xyzStarfireId` field. */
  xyzStarfireId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `llaId` field. */
  llaId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `enuId` field. */
  enuId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `fieldOriginId` field. */
  fieldOriginId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `ecefId` field. */
  ecefId?: Maybe<BigIntFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<ObjectMessageVertexFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<ObjectMessageVertexFilter>>;
  /** Negates the expression. */
  not?: Maybe<ObjectMessageVertexFilter>;
};

/** A connection to a list of `ObjectMessageVertex` values. */
export type ObjectMessageVerticesConnection = {
  __typename?: 'ObjectMessageVerticesConnection';
  /** A list of `ObjectMessageVertex` objects. */
  nodes: Array<Maybe<ObjectMessageVertex>>;
  /** A list of edges which contains the `ObjectMessageVertex` and cursor to aid in pagination. */
  edges: Array<ObjectMessageVerticesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ObjectMessageVertex` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `ObjectMessageVertex` edge in the connection. */
export type ObjectMessageVerticesEdge = {
  __typename?: 'ObjectMessageVerticesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `ObjectMessageVertex` at the end of the edge. */
  node?: Maybe<ObjectMessageVertex>;
};

/** Methods to use when ordering `ObjectMessageVertex`. */
export enum ObjectMessageVerticesOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  ObjectMessageIdAsc = 'OBJECT_MESSAGE_ID_ASC',
  ObjectMessageIdDesc = 'OBJECT_MESSAGE_ID_DESC',
  XyzCameraIdAsc = 'XYZ_CAMERA_ID_ASC',
  XyzCameraIdDesc = 'XYZ_CAMERA_ID_DESC',
  XyzStarfireIdAsc = 'XYZ_STARFIRE_ID_ASC',
  XyzStarfireIdDesc = 'XYZ_STARFIRE_ID_DESC',
  LlaIdAsc = 'LLA_ID_ASC',
  LlaIdDesc = 'LLA_ID_DESC',
  EnuIdAsc = 'ENU_ID_ASC',
  EnuIdDesc = 'ENU_ID_DESC',
  FieldOriginIdAsc = 'FIELD_ORIGIN_ID_ASC',
  FieldOriginIdDesc = 'FIELD_ORIGIN_ID_DESC',
  EcefIdAsc = 'ECEF_ID_ASC',
  EcefIdDesc = 'ECEF_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/** The object message message xyz camera table for the object message section */
export type ObjectMessageXyzCamera = Node & {
  __typename?: 'ObjectMessageXyzCamera';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  /** The id of the row that is autoincremented */
  id: Scalars['BigInt'];
  /** The x_m for centroid rpy */
  xM?: Maybe<Scalars['BigFloat']>;
  /** The y_m for centroid rpy */
  yM?: Maybe<Scalars['BigFloat']>;
  /** The z_m for centroid rpy */
  zM?: Maybe<Scalars['BigFloat']>;
  /** Reads and enables pagination through a set of `ObjectMessageCentroidLocation`. */
  objectMessageCentroidLocationsByXyzCameraId: ObjectMessageCentroidLocationsConnection;
  /** Reads and enables pagination through a set of `ObjectMessageCircleCenter`. */
  objectMessageCircleCentersByXyzCameraId: ObjectMessageCircleCentersConnection;
  /** Reads and enables pagination through a set of `ObjectMessageVertex`. */
  objectMessageVerticesByXyzCameraId: ObjectMessageVerticesConnection;
};


/** The object message message xyz camera table for the object message section */
export type ObjectMessageXyzCameraObjectMessageCentroidLocationsByXyzCameraIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ObjectMessageCentroidLocationsOrderBy>>;
  condition?: Maybe<ObjectMessageCentroidLocationCondition>;
  filter?: Maybe<ObjectMessageCentroidLocationFilter>;
};


/** The object message message xyz camera table for the object message section */
export type ObjectMessageXyzCameraObjectMessageCircleCentersByXyzCameraIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ObjectMessageCircleCentersOrderBy>>;
  condition?: Maybe<ObjectMessageCircleCenterCondition>;
  filter?: Maybe<ObjectMessageCircleCenterFilter>;
};


/** The object message message xyz camera table for the object message section */
export type ObjectMessageXyzCameraObjectMessageVerticesByXyzCameraIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ObjectMessageVerticesOrderBy>>;
  condition?: Maybe<ObjectMessageVertexCondition>;
  filter?: Maybe<ObjectMessageVertexFilter>;
};

/**
 * A condition to be used against `ObjectMessageXyzCamera` object types. All fields
 * are tested for equality and combined with a logical ‘and.’
 */
export type ObjectMessageXyzCameraCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `xM` field. */
  xM?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `yM` field. */
  yM?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `zM` field. */
  zM?: Maybe<Scalars['BigFloat']>;
};

/** A filter to be used against `ObjectMessageXyzCamera` object types. All fields are combined with a logical ‘and.’ */
export type ObjectMessageXyzCameraFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `xM` field. */
  xM?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `yM` field. */
  yM?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `zM` field. */
  zM?: Maybe<BigFloatFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<ObjectMessageXyzCameraFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<ObjectMessageXyzCameraFilter>>;
  /** Negates the expression. */
  not?: Maybe<ObjectMessageXyzCameraFilter>;
};

/** A connection to a list of `ObjectMessageXyzCamera` values. */
export type ObjectMessageXyzCamerasConnection = {
  __typename?: 'ObjectMessageXyzCamerasConnection';
  /** A list of `ObjectMessageXyzCamera` objects. */
  nodes: Array<Maybe<ObjectMessageXyzCamera>>;
  /** A list of edges which contains the `ObjectMessageXyzCamera` and cursor to aid in pagination. */
  edges: Array<ObjectMessageXyzCamerasEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ObjectMessageXyzCamera` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `ObjectMessageXyzCamera` edge in the connection. */
export type ObjectMessageXyzCamerasEdge = {
  __typename?: 'ObjectMessageXyzCamerasEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `ObjectMessageXyzCamera` at the end of the edge. */
  node?: Maybe<ObjectMessageXyzCamera>;
};

/** Methods to use when ordering `ObjectMessageXyzCamera`. */
export enum ObjectMessageXyzCamerasOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  XMAsc = 'X_M_ASC',
  XMDesc = 'X_M_DESC',
  YMAsc = 'Y_M_ASC',
  YMDesc = 'Y_M_DESC',
  ZMAsc = 'Z_M_ASC',
  ZMDesc = 'Z_M_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/** The object message xyz starfire table for the object message section */
export type ObjectMessageXyzStarfire = Node & {
  __typename?: 'ObjectMessageXyzStarfire';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  /** The id of the row that is autoincremented */
  id: Scalars['BigInt'];
  /** The x location measured in meters for object message xyz starfire  */
  xM?: Maybe<Scalars['BigFloat']>;
  /** The y location measured in meters for object message xyz starfire  */
  yM?: Maybe<Scalars['BigFloat']>;
  /** The z location measured in meters for object message xyz starfire  */
  zM?: Maybe<Scalars['BigFloat']>;
  /** Reads and enables pagination through a set of `ObjectMessageCentroidLocation`. */
  objectMessageCentroidLocationsByXyzStarfireId: ObjectMessageCentroidLocationsConnection;
  /** Reads and enables pagination through a set of `ObjectMessageCircleCenter`. */
  objectMessageCircleCentersByXyzStarfireId: ObjectMessageCircleCentersConnection;
  /** Reads and enables pagination through a set of `ObjectMessageVertex`. */
  objectMessageVerticesByXyzStarfireId: ObjectMessageVerticesConnection;
};


/** The object message xyz starfire table for the object message section */
export type ObjectMessageXyzStarfireObjectMessageCentroidLocationsByXyzStarfireIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ObjectMessageCentroidLocationsOrderBy>>;
  condition?: Maybe<ObjectMessageCentroidLocationCondition>;
  filter?: Maybe<ObjectMessageCentroidLocationFilter>;
};


/** The object message xyz starfire table for the object message section */
export type ObjectMessageXyzStarfireObjectMessageCircleCentersByXyzStarfireIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ObjectMessageCircleCentersOrderBy>>;
  condition?: Maybe<ObjectMessageCircleCenterCondition>;
  filter?: Maybe<ObjectMessageCircleCenterFilter>;
};


/** The object message xyz starfire table for the object message section */
export type ObjectMessageXyzStarfireObjectMessageVerticesByXyzStarfireIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ObjectMessageVerticesOrderBy>>;
  condition?: Maybe<ObjectMessageVertexCondition>;
  filter?: Maybe<ObjectMessageVertexFilter>;
};

/**
 * A condition to be used against `ObjectMessageXyzStarfire` object types. All
 * fields are tested for equality and combined with a logical ‘and.’
 */
export type ObjectMessageXyzStarfireCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `xM` field. */
  xM?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `yM` field. */
  yM?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `zM` field. */
  zM?: Maybe<Scalars['BigFloat']>;
};

/** A filter to be used against `ObjectMessageXyzStarfire` object types. All fields are combined with a logical ‘and.’ */
export type ObjectMessageXyzStarfireFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `xM` field. */
  xM?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `yM` field. */
  yM?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `zM` field. */
  zM?: Maybe<BigFloatFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<ObjectMessageXyzStarfireFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<ObjectMessageXyzStarfireFilter>>;
  /** Negates the expression. */
  not?: Maybe<ObjectMessageXyzStarfireFilter>;
};

/** A connection to a list of `ObjectMessageXyzStarfire` values. */
export type ObjectMessageXyzStarfiresConnection = {
  __typename?: 'ObjectMessageXyzStarfiresConnection';
  /** A list of `ObjectMessageXyzStarfire` objects. */
  nodes: Array<Maybe<ObjectMessageXyzStarfire>>;
  /** A list of edges which contains the `ObjectMessageXyzStarfire` and cursor to aid in pagination. */
  edges: Array<ObjectMessageXyzStarfiresEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ObjectMessageXyzStarfire` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `ObjectMessageXyzStarfire` edge in the connection. */
export type ObjectMessageXyzStarfiresEdge = {
  __typename?: 'ObjectMessageXyzStarfiresEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `ObjectMessageXyzStarfire` at the end of the edge. */
  node?: Maybe<ObjectMessageXyzStarfire>;
};

/** Methods to use when ordering `ObjectMessageXyzStarfire`. */
export enum ObjectMessageXyzStarfiresOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  XMAsc = 'X_M_ASC',
  XMDesc = 'X_M_DESC',
  YMAsc = 'Y_M_ASC',
  YMDesc = 'Y_M_DESC',
  ZMAsc = 'Z_M_ASC',
  ZMDesc = 'Z_M_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/** A connection to a list of `ObjectMessage` values. */
export type ObjectMessagesConnection = {
  __typename?: 'ObjectMessagesConnection';
  /** A list of `ObjectMessage` objects. */
  nodes: Array<Maybe<ObjectMessage>>;
  /** A list of edges which contains the `ObjectMessage` and cursor to aid in pagination. */
  edges: Array<ObjectMessagesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ObjectMessage` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `ObjectMessage` edge in the connection. */
export type ObjectMessagesEdge = {
  __typename?: 'ObjectMessagesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `ObjectMessage` at the end of the edge. */
  node?: Maybe<ObjectMessage>;
};

/** Methods to use when ordering `ObjectMessage`. */
export enum ObjectMessagesOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  ReferenceidAsc = 'REFERENCEID_ASC',
  ReferenceidDesc = 'REFERENCEID_DESC',
  HeaderIdAsc = 'HEADER_ID_ASC',
  HeaderIdDesc = 'HEADER_ID_DESC',
  DetectionIdAsc = 'DETECTION_ID_ASC',
  DetectionIdDesc = 'DETECTION_ID_DESC',
  CentroidRpyIdAsc = 'CENTROID_RPY_ID_ASC',
  CentroidRpyIdDesc = 'CENTROID_RPY_ID_DESC',
  CentroidLocationIdAsc = 'CENTROID_LOCATION_ID_ASC',
  CentroidLocationIdDesc = 'CENTROID_LOCATION_ID_DESC',
  CircleCenterIdAsc = 'CIRCLE_CENTER_ID_ASC',
  CircleCenterIdDesc = 'CIRCLE_CENTER_ID_DESC',
  CircleRadiusMAsc = 'CIRCLE_RADIUS_M_ASC',
  CircleRadiusMDesc = 'CIRCLE_RADIUS_M_DESC',
  OnPathAsc = 'ON_PATH_ASC',
  OnPathDesc = 'ON_PATH_DESC',
  IsActivePathSetAsc = 'IS_ACTIVE_PATH_SET_ASC',
  IsActivePathSetDesc = 'IS_ACTIVE_PATH_SET_DESC',
  CameraNameAsc = 'CAMERA_NAME_ASC',
  CameraNameDesc = 'CAMERA_NAME_DESC',
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/** Represents an update to a `Object`. Fields that are set will be updated. */
export type ObjectPatch = {
  readingat?: Maybe<Scalars['Datetime']>;
};

/** A connection to a list of `Object` values. */
export type ObjectsConnection = {
  __typename?: 'ObjectsConnection';
  /** A list of `Object` objects. */
  nodes: Array<Maybe<Object>>;
  /** A list of edges which contains the `Object` and cursor to aid in pagination. */
  edges: Array<ObjectsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Object` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `Object` edge in the connection. */
export type ObjectsEdge = {
  __typename?: 'ObjectsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Object` at the end of the edge. */
  node?: Maybe<Object>;
};

/** Methods to use when ordering `Object`. */
export enum ObjectsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  ReadingatAsc = 'READINGAT_ASC',
  ReadingatDesc = 'READINGAT_DESC',
  VehicleIdAsc = 'VEHICLE_ID_ASC',
  VehicleIdDesc = 'VEHICLE_ID_DESC',
  TopicIdAsc = 'TOPIC_ID_ASC',
  TopicIdDesc = 'TOPIC_ID_DESC',
  MessageIdAsc = 'MESSAGE_ID_ASC',
  MessageIdDesc = 'MESSAGE_ID_DESC',
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/** Information about pagination in a connection. */
export type PageInfo = {
  __typename?: 'PageInfo';
  /** When paginating forwards, are there more items? */
  hasNextPage: Scalars['Boolean'];
  /** When paginating backwards, are there more items? */
  hasPreviousPage: Scalars['Boolean'];
  /** When paginating backwards, the cursor to continue. */
  startCursor?: Maybe<Scalars['Cursor']>;
  /** When paginating forwards, the cursor to continue. */
  endCursor?: Maybe<Scalars['Cursor']>;
};

/** The root query type which gives access points into the data universe. */
export type Query = Node & {
  __typename?: 'Query';
  /**
   * Exposes the root query type nested one level down. This is helpful for Relay 1
   * which can only query top level fields if they are in a particular form.
   */
  query: Query;
  /** The root query type must be a `Node` to work well with Relay 1 mutations. This just resolves to `query`. */
  nodeId: Scalars['ID'];
  /** Fetches an object given its globally unique `ID`. */
  node?: Maybe<Node>;
  /** Reads and enables pagination through a set of `VehicleTopic`. */
  vehicleTopics?: Maybe<VehicleTopicsConnection>;
  /** Reads and enables pagination through a set of `VehicleType`. */
  vehicleTypes?: Maybe<VehicleTypesConnection>;
  /** Reads and enables pagination through a set of `Vehicle`. */
  vehicles?: Maybe<VehiclesConnection>;
  /** Reads and enables pagination through a set of `VehiclesOffline`. */
  vehiclesOfflines?: Maybe<VehiclesOfflinesConnection>;
  /** Reads and enables pagination through a set of `VehiclesOnline`. */
  vehiclesOnlines?: Maybe<VehiclesOnlinesConnection>;
  /** Reads and enables pagination through a set of `TopicCategory`. */
  topicCategories?: Maybe<TopicCategoriesConnection>;
  /** Reads and enables pagination through a set of `TopicType`. */
  topicTypes?: Maybe<TopicTypesConnection>;
  /** Reads and enables pagination through a set of `Topic`. */
  topics?: Maybe<TopicsConnection>;
  /** Reads and enables pagination through a set of `Test`. */
  tests?: Maybe<TestsConnection>;
  /** Reads and enables pagination through a set of `VehicleLogMessageStamp`. */
  vehicleLogMessageStamps?: Maybe<VehicleLogMessageStampsConnection>;
  /** Reads and enables pagination through a set of `VehicleLogMessage`. */
  vehicleLogMessages?: Maybe<VehicleLogMessagesConnection>;
  /** Reads and enables pagination through a set of `VehicleLogNodeType`. */
  vehicleLogNodeTypes?: Maybe<VehicleLogNodeTypesConnection>;
  /** Reads and enables pagination through a set of `VehicleLog`. */
  vehicleLogs?: Maybe<VehicleLogsConnection>;
  /** Reads and enables pagination through a set of `Starfire`. */
  starfires?: Maybe<StarfiresConnection>;
  /** Reads and enables pagination through a set of `StarfireHeader`. */
  starfireHeaders?: Maybe<StarfireHeadersConnection>;
  /** Reads and enables pagination through a set of `StarfireMessage`. */
  starfireMessages?: Maybe<StarfireMessagesConnection>;
  /** Reads and enables pagination through a set of `Camera`. */
  cameras?: Maybe<CamerasConnection>;
  /** Reads and enables pagination through a set of `CameraHistogram`. */
  cameraHistograms?: Maybe<CameraHistogramsConnection>;
  /** Reads and enables pagination through a set of `CameraMessage`. */
  cameraMessages?: Maybe<CameraMessagesConnection>;
  /** Reads and enables pagination through a set of `CameraMessageHeader`. */
  cameraMessageHeaders?: Maybe<CameraMessageHeadersConnection>;
  /** Reads and enables pagination through a set of `CameraMeta`. */
  cameraMetas?: Maybe<CameraMetasConnection>;
  /** Reads and enables pagination through a set of `CameraMetaE`. */
  cameraMetaEs?: Maybe<CameraMetaEsConnection>;
  /** Reads and enables pagination through a set of `CameraMetaF`. */
  cameraMetaFs?: Maybe<CameraMetaFsConnection>;
  /** Reads and enables pagination through a set of `CameraMetaP1`. */
  cameraMetaP1s?: Maybe<CameraMetaP1sConnection>;
  /** Reads and enables pagination through a set of `CameraMetaP2`. */
  cameraMetaP2s?: Maybe<CameraMetaP2sConnection>;
  /** Reads and enables pagination through a set of `CameraMetaQ`. */
  cameraMetaQs?: Maybe<CameraMetaQsConnection>;
  /** Reads and enables pagination through a set of `CameraMetaR1`. */
  cameraMetaR1s?: Maybe<CameraMetaR1sConnection>;
  /** Reads and enables pagination through a set of `CameraMetaR2`. */
  cameraMetaR2s?: Maybe<CameraMetaR2sConnection>;
  /** Reads and enables pagination through a set of `CameraPair`. */
  cameraPairs?: Maybe<CameraPairsConnection>;
  /** Reads and enables pagination through a set of `CameraPairMessage`. */
  cameraPairMessages?: Maybe<CameraPairMessagesConnection>;
  /** Reads and enables pagination through a set of `CameraRoi`. */
  cameraRois?: Maybe<CameraRoisConnection>;
  /** Reads and enables pagination through a set of `FullHistogram`. */
  fullHistograms?: Maybe<FullHistogramsConnection>;
  /** Reads and enables pagination through a set of `ImageDatum`. */
  imageData?: Maybe<ImageDataConnection>;
  /** Reads and enables pagination through a set of `ImageHeader`. */
  imageHeaders?: Maybe<ImageHeadersConnection>;
  /** Reads and enables pagination through a set of `ImageHeaderStamp`. */
  imageHeaderStamps?: Maybe<ImageHeaderStampsConnection>;
  /** Reads and enables pagination through a set of `Image`. */
  images?: Maybe<ImagesConnection>;
  /** Reads and enables pagination through a set of `SegmentationMap`. */
  segmentationMaps?: Maybe<SegmentationMapsConnection>;
  /** Reads and enables pagination through a set of `SideIntrinsic`. */
  sideIntrinsics?: Maybe<SideIntrinsicsConnection>;
  /** Reads and enables pagination through a set of `SideIntrinsicsD`. */
  sideIntrinsicsDs?: Maybe<SideIntrinsicsDsConnection>;
  /** Reads and enables pagination through a set of `SideIntrinsicsK`. */
  sideIntrinsicsKs?: Maybe<SideIntrinsicsKsConnection>;
  /** Reads and enables pagination through a set of `SmallHistogram`. */
  smallHistograms?: Maybe<SmallHistogramsConnection>;
  /** Reads and enables pagination through a set of `StereoExtrinsic`. */
  stereoExtrinsics?: Maybe<StereoExtrinsicsConnection>;
  /** Reads and enables pagination through a set of `StereoExtrinsicsR`. */
  stereoExtrinsicsRs?: Maybe<StereoExtrinsicsRsConnection>;
  /** Reads and enables pagination through a set of `StereoExtrinsicsRRodrigue`. */
  stereoExtrinsicsRRodrigues?: Maybe<StereoExtrinsicsRRodriguesConnection>;
  /** Reads and enables pagination through a set of `StereoExtrinsicsT`. */
  stereoExtrinsicsTs?: Maybe<StereoExtrinsicsTsConnection>;
  /** Reads and enables pagination through a set of `TractorExtrinsic`. */
  tractorExtrinsics?: Maybe<TractorExtrinsicsConnection>;
  /** Reads and enables pagination through a set of `TractorExtrinsicsR`. */
  tractorExtrinsicsRs?: Maybe<TractorExtrinsicsRsConnection>;
  /** Reads and enables pagination through a set of `TractorExtrinsicsRRodrigue`. */
  tractorExtrinsicsRRodrigues?: Maybe<TractorExtrinsicsRRodriguesConnection>;
  /** Reads and enables pagination through a set of `TractorExtrinsicsT`. */
  tractorExtrinsicsTs?: Maybe<TractorExtrinsicsTsConnection>;
  /** Reads and enables pagination through a set of `AlertType`. */
  alertTypes?: Maybe<AlertTypesConnection>;
  /** Reads and enables pagination through a set of `Alert`. */
  alerts?: Maybe<AlertsConnection>;
  /** Reads and enables pagination through a set of `StatusMessage`. */
  statusMessages?: Maybe<StatusMessagesConnection>;
  /** Reads and enables pagination through a set of `StatusMessageHeader`. */
  statusMessageHeaders?: Maybe<StatusMessageHeadersConnection>;
  /** Reads and enables pagination through a set of `StatusMessageMissionStat`. */
  statusMessageMissionStats?: Maybe<StatusMessageMissionStatsConnection>;
  /** Reads and enables pagination through a set of `VehicleStateReason`. */
  vehicleStateReasons?: Maybe<VehicleStateReasonsConnection>;
  /** Reads and enables pagination through a set of `VehicleState`. */
  vehicleStates?: Maybe<VehicleStatesConnection>;
  /** Reads and enables pagination through a set of `VehicleStatus`. */
  vehicleStatuses?: Maybe<VehicleStatusesConnection>;
  /** Reads and enables pagination through a set of `VehicleStatusDetail`. */
  vehicleStatusDetails?: Maybe<VehicleStatusDetailsConnection>;
  /** Reads and enables pagination through a set of `ObjectDetectionImage`. */
  objectDetectionImages?: Maybe<ObjectDetectionImagesConnection>;
  /** Reads and enables pagination through a set of `ObjectMessage`. */
  objectMessages?: Maybe<ObjectMessagesConnection>;
  /** Reads and enables pagination through a set of `ObjectMessageCentroidLocation`. */
  objectMessageCentroidLocations?: Maybe<ObjectMessageCentroidLocationsConnection>;
  /** Reads and enables pagination through a set of `ObjectMessageCentroidRpy`. */
  objectMessageCentroidRpies?: Maybe<ObjectMessageCentroidRpiesConnection>;
  /** Reads and enables pagination through a set of `ObjectMessageCircleCenter`. */
  objectMessageCircleCenters?: Maybe<ObjectMessageCircleCentersConnection>;
  /** Reads and enables pagination through a set of `ObjectMessageDetection`. */
  objectMessageDetections?: Maybe<ObjectMessageDetectionsConnection>;
  /** Reads and enables pagination through a set of `ObjectMessageDetectionCuboid`. */
  objectMessageDetectionCuboids?: Maybe<ObjectMessageDetectionCuboidsConnection>;
  /** Reads and enables pagination through a set of `ObjectMessageDetectionCuboidCentroid`. */
  objectMessageDetectionCuboidCentroids?: Maybe<ObjectMessageDetectionCuboidCentroidsConnection>;
  /** Reads and enables pagination through a set of `ObjectMessageDetectionCuboidDimension`. */
  objectMessageDetectionCuboidDimensions?: Maybe<ObjectMessageDetectionCuboidDimensionsConnection>;
  /** Reads and enables pagination through a set of `ObjectMessageDetectionCuboidOrientation`. */
  objectMessageDetectionCuboidOrientations?: Maybe<ObjectMessageDetectionCuboidOrientationsConnection>;
  /** Reads and enables pagination through a set of `ObjectMessageDetectionHeader`. */
  objectMessageDetectionHeaders?: Maybe<ObjectMessageDetectionHeadersConnection>;
  /** Reads and enables pagination through a set of `ObjectMessageDetectionRoi`. */
  objectMessageDetectionRois?: Maybe<ObjectMessageDetectionRoisConnection>;
  /** Reads and enables pagination through a set of `ObjectMessageEcef`. */
  objectMessageEcefs?: Maybe<ObjectMessageEcefsConnection>;
  /** Reads and enables pagination through a set of `ObjectMessageEnu`. */
  objectMessageEnus?: Maybe<ObjectMessageEnusConnection>;
  /** Reads and enables pagination through a set of `ObjectMessageFieldOrigin`. */
  objectMessageFieldOrigins?: Maybe<ObjectMessageFieldOriginsConnection>;
  /** Reads and enables pagination through a set of `ObjectMessageHeader`. */
  objectMessageHeaders?: Maybe<ObjectMessageHeadersConnection>;
  /** Reads and enables pagination through a set of `ObjectMessageLla`. */
  objectMessageLlas?: Maybe<ObjectMessageLlasConnection>;
  /** Reads and enables pagination through a set of `ObjectMessageVertex`. */
  objectMessageVertices?: Maybe<ObjectMessageVerticesConnection>;
  /** Reads and enables pagination through a set of `ObjectMessageXyzCamera`. */
  objectMessageXyzCameras?: Maybe<ObjectMessageXyzCamerasConnection>;
  /** Reads and enables pagination through a set of `ObjectMessageXyzStarfire`. */
  objectMessageXyzStarfires?: Maybe<ObjectMessageXyzStarfiresConnection>;
  /** Reads and enables pagination through a set of `Object`. */
  objects?: Maybe<ObjectsConnection>;
  vehicleTopic?: Maybe<VehicleTopic>;
  vehicleType?: Maybe<VehicleType>;
  vehicleTypeByType?: Maybe<VehicleType>;
  vehicle?: Maybe<Vehicle>;
  vehicleByDeviceId?: Maybe<Vehicle>;
  vehiclesOnline?: Maybe<VehiclesOnline>;
  vehiclesOnlineByVehicleId?: Maybe<VehiclesOnline>;
  topicCategory?: Maybe<TopicCategory>;
  topicType?: Maybe<TopicType>;
  topicTypeByModule?: Maybe<TopicType>;
  topic?: Maybe<Topic>;
  topicByName?: Maybe<Topic>;
  test?: Maybe<Test>;
  vehicleLogMessageStamp?: Maybe<VehicleLogMessageStamp>;
  vehicleLogMessage?: Maybe<VehicleLogMessage>;
  vehicleLog?: Maybe<VehicleLog>;
  starfire?: Maybe<Starfire>;
  starfireHeader?: Maybe<StarfireHeader>;
  starfireMessage?: Maybe<StarfireMessage>;
  camera?: Maybe<Camera>;
  cameraHistogram?: Maybe<CameraHistogram>;
  cameraMessage?: Maybe<CameraMessage>;
  cameraMessageHeader?: Maybe<CameraMessageHeader>;
  cameraMeta?: Maybe<CameraMeta>;
  cameraMetaE?: Maybe<CameraMetaE>;
  cameraMetaF?: Maybe<CameraMetaF>;
  cameraMetaP1?: Maybe<CameraMetaP1>;
  cameraMetaP2?: Maybe<CameraMetaP2>;
  cameraMetaQ?: Maybe<CameraMetaQ>;
  cameraMetaR1?: Maybe<CameraMetaR1>;
  cameraMetaR2?: Maybe<CameraMetaR2>;
  cameraPair?: Maybe<CameraPair>;
  cameraPairMessage?: Maybe<CameraPairMessage>;
  cameraRoi?: Maybe<CameraRoi>;
  fullHistogram?: Maybe<FullHistogram>;
  imageDatum?: Maybe<ImageDatum>;
  imageHeader?: Maybe<ImageHeader>;
  imageHeaderStamp?: Maybe<ImageHeaderStamp>;
  image?: Maybe<Image>;
  segmentationMap?: Maybe<SegmentationMap>;
  sideIntrinsic?: Maybe<SideIntrinsic>;
  sideIntrinsicsD?: Maybe<SideIntrinsicsD>;
  sideIntrinsicsK?: Maybe<SideIntrinsicsK>;
  smallHistogram?: Maybe<SmallHistogram>;
  stereoExtrinsic?: Maybe<StereoExtrinsic>;
  stereoExtrinsicsR?: Maybe<StereoExtrinsicsR>;
  stereoExtrinsicsRRodrigue?: Maybe<StereoExtrinsicsRRodrigue>;
  stereoExtrinsicsT?: Maybe<StereoExtrinsicsT>;
  tractorExtrinsic?: Maybe<TractorExtrinsic>;
  tractorExtrinsicsR?: Maybe<TractorExtrinsicsR>;
  tractorExtrinsicsRRodrigue?: Maybe<TractorExtrinsicsRRodrigue>;
  tractorExtrinsicsT?: Maybe<TractorExtrinsicsT>;
  alertType?: Maybe<AlertType>;
  alert?: Maybe<Alert>;
  statusMessage?: Maybe<StatusMessage>;
  statusMessageHeader?: Maybe<StatusMessageHeader>;
  statusMessageMissionStat?: Maybe<StatusMessageMissionStat>;
  vehicleStateReason?: Maybe<VehicleStateReason>;
  vehicleState?: Maybe<VehicleState>;
  vehicleStateByName?: Maybe<VehicleState>;
  vehicleStateByCode?: Maybe<VehicleState>;
  vehicleStatus?: Maybe<VehicleStatus>;
  vehicleStatusDetail?: Maybe<VehicleStatusDetail>;
  objectMessage?: Maybe<ObjectMessage>;
  objectMessageCentroidLocation?: Maybe<ObjectMessageCentroidLocation>;
  objectMessageCentroidRpy?: Maybe<ObjectMessageCentroidRpy>;
  objectMessageCircleCenter?: Maybe<ObjectMessageCircleCenter>;
  objectMessageDetection?: Maybe<ObjectMessageDetection>;
  objectMessageDetectionCuboid?: Maybe<ObjectMessageDetectionCuboid>;
  objectMessageDetectionCuboidCentroid?: Maybe<ObjectMessageDetectionCuboidCentroid>;
  objectMessageDetectionCuboidDimension?: Maybe<ObjectMessageDetectionCuboidDimension>;
  objectMessageDetectionCuboidOrientation?: Maybe<ObjectMessageDetectionCuboidOrientation>;
  objectMessageDetectionHeader?: Maybe<ObjectMessageDetectionHeader>;
  objectMessageDetectionRoi?: Maybe<ObjectMessageDetectionRoi>;
  objectMessageEcef?: Maybe<ObjectMessageEcef>;
  objectMessageEnu?: Maybe<ObjectMessageEnu>;
  objectMessageFieldOrigin?: Maybe<ObjectMessageFieldOrigin>;
  objectMessageHeader?: Maybe<ObjectMessageHeader>;
  objectMessageLla?: Maybe<ObjectMessageLla>;
  objectMessageVertex?: Maybe<ObjectMessageVertex>;
  objectMessageXyzCamera?: Maybe<ObjectMessageXyzCamera>;
  objectMessageXyzStarfire?: Maybe<ObjectMessageXyzStarfire>;
  object?: Maybe<Object>;
  /** Reads a single `VehicleTopic` using its globally unique `ID`. */
  vehicleTopicByNodeId?: Maybe<VehicleTopic>;
  /** Reads a single `VehicleType` using its globally unique `ID`. */
  vehicleTypeByNodeId?: Maybe<VehicleType>;
  /** Reads a single `Vehicle` using its globally unique `ID`. */
  vehicleByNodeId?: Maybe<Vehicle>;
  /** Reads a single `VehiclesOnline` using its globally unique `ID`. */
  vehiclesOnlineByNodeId?: Maybe<VehiclesOnline>;
  /** Reads a single `TopicCategory` using its globally unique `ID`. */
  topicCategoryByNodeId?: Maybe<TopicCategory>;
  /** Reads a single `TopicType` using its globally unique `ID`. */
  topicTypeByNodeId?: Maybe<TopicType>;
  /** Reads a single `Topic` using its globally unique `ID`. */
  topicByNodeId?: Maybe<Topic>;
  /** Reads a single `Test` using its globally unique `ID`. */
  testByNodeId?: Maybe<Test>;
  /** Reads a single `VehicleLogMessageStamp` using its globally unique `ID`. */
  vehicleLogMessageStampByNodeId?: Maybe<VehicleLogMessageStamp>;
  /** Reads a single `VehicleLogMessage` using its globally unique `ID`. */
  vehicleLogMessageByNodeId?: Maybe<VehicleLogMessage>;
  /** Reads a single `VehicleLog` using its globally unique `ID`. */
  vehicleLogByNodeId?: Maybe<VehicleLog>;
  /** Reads a single `Starfire` using its globally unique `ID`. */
  starfireByNodeId?: Maybe<Starfire>;
  /** Reads a single `StarfireHeader` using its globally unique `ID`. */
  starfireHeaderByNodeId?: Maybe<StarfireHeader>;
  /** Reads a single `StarfireMessage` using its globally unique `ID`. */
  starfireMessageByNodeId?: Maybe<StarfireMessage>;
  /** Reads a single `Camera` using its globally unique `ID`. */
  cameraByNodeId?: Maybe<Camera>;
  /** Reads a single `CameraHistogram` using its globally unique `ID`. */
  cameraHistogramByNodeId?: Maybe<CameraHistogram>;
  /** Reads a single `CameraMessage` using its globally unique `ID`. */
  cameraMessageByNodeId?: Maybe<CameraMessage>;
  /** Reads a single `CameraMessageHeader` using its globally unique `ID`. */
  cameraMessageHeaderByNodeId?: Maybe<CameraMessageHeader>;
  /** Reads a single `CameraMeta` using its globally unique `ID`. */
  cameraMetaByNodeId?: Maybe<CameraMeta>;
  /** Reads a single `CameraMetaE` using its globally unique `ID`. */
  cameraMetaEByNodeId?: Maybe<CameraMetaE>;
  /** Reads a single `CameraMetaF` using its globally unique `ID`. */
  cameraMetaFByNodeId?: Maybe<CameraMetaF>;
  /** Reads a single `CameraMetaP1` using its globally unique `ID`. */
  cameraMetaP1ByNodeId?: Maybe<CameraMetaP1>;
  /** Reads a single `CameraMetaP2` using its globally unique `ID`. */
  cameraMetaP2ByNodeId?: Maybe<CameraMetaP2>;
  /** Reads a single `CameraMetaQ` using its globally unique `ID`. */
  cameraMetaQByNodeId?: Maybe<CameraMetaQ>;
  /** Reads a single `CameraMetaR1` using its globally unique `ID`. */
  cameraMetaR1ByNodeId?: Maybe<CameraMetaR1>;
  /** Reads a single `CameraMetaR2` using its globally unique `ID`. */
  cameraMetaR2ByNodeId?: Maybe<CameraMetaR2>;
  /** Reads a single `CameraPair` using its globally unique `ID`. */
  cameraPairByNodeId?: Maybe<CameraPair>;
  /** Reads a single `CameraPairMessage` using its globally unique `ID`. */
  cameraPairMessageByNodeId?: Maybe<CameraPairMessage>;
  /** Reads a single `CameraRoi` using its globally unique `ID`. */
  cameraRoiByNodeId?: Maybe<CameraRoi>;
  /** Reads a single `FullHistogram` using its globally unique `ID`. */
  fullHistogramByNodeId?: Maybe<FullHistogram>;
  /** Reads a single `ImageDatum` using its globally unique `ID`. */
  imageDatumByNodeId?: Maybe<ImageDatum>;
  /** Reads a single `ImageHeader` using its globally unique `ID`. */
  imageHeaderByNodeId?: Maybe<ImageHeader>;
  /** Reads a single `ImageHeaderStamp` using its globally unique `ID`. */
  imageHeaderStampByNodeId?: Maybe<ImageHeaderStamp>;
  /** Reads a single `Image` using its globally unique `ID`. */
  imageByNodeId?: Maybe<Image>;
  /** Reads a single `SegmentationMap` using its globally unique `ID`. */
  segmentationMapByNodeId?: Maybe<SegmentationMap>;
  /** Reads a single `SideIntrinsic` using its globally unique `ID`. */
  sideIntrinsicByNodeId?: Maybe<SideIntrinsic>;
  /** Reads a single `SideIntrinsicsD` using its globally unique `ID`. */
  sideIntrinsicsDByNodeId?: Maybe<SideIntrinsicsD>;
  /** Reads a single `SideIntrinsicsK` using its globally unique `ID`. */
  sideIntrinsicsKByNodeId?: Maybe<SideIntrinsicsK>;
  /** Reads a single `SmallHistogram` using its globally unique `ID`. */
  smallHistogramByNodeId?: Maybe<SmallHistogram>;
  /** Reads a single `StereoExtrinsic` using its globally unique `ID`. */
  stereoExtrinsicByNodeId?: Maybe<StereoExtrinsic>;
  /** Reads a single `StereoExtrinsicsR` using its globally unique `ID`. */
  stereoExtrinsicsRByNodeId?: Maybe<StereoExtrinsicsR>;
  /** Reads a single `StereoExtrinsicsRRodrigue` using its globally unique `ID`. */
  stereoExtrinsicsRRodrigueByNodeId?: Maybe<StereoExtrinsicsRRodrigue>;
  /** Reads a single `StereoExtrinsicsT` using its globally unique `ID`. */
  stereoExtrinsicsTByNodeId?: Maybe<StereoExtrinsicsT>;
  /** Reads a single `TractorExtrinsic` using its globally unique `ID`. */
  tractorExtrinsicByNodeId?: Maybe<TractorExtrinsic>;
  /** Reads a single `TractorExtrinsicsR` using its globally unique `ID`. */
  tractorExtrinsicsRByNodeId?: Maybe<TractorExtrinsicsR>;
  /** Reads a single `TractorExtrinsicsRRodrigue` using its globally unique `ID`. */
  tractorExtrinsicsRRodrigueByNodeId?: Maybe<TractorExtrinsicsRRodrigue>;
  /** Reads a single `TractorExtrinsicsT` using its globally unique `ID`. */
  tractorExtrinsicsTByNodeId?: Maybe<TractorExtrinsicsT>;
  /** Reads a single `AlertType` using its globally unique `ID`. */
  alertTypeByNodeId?: Maybe<AlertType>;
  /** Reads a single `Alert` using its globally unique `ID`. */
  alertByNodeId?: Maybe<Alert>;
  /** Reads a single `StatusMessage` using its globally unique `ID`. */
  statusMessageByNodeId?: Maybe<StatusMessage>;
  /** Reads a single `StatusMessageHeader` using its globally unique `ID`. */
  statusMessageHeaderByNodeId?: Maybe<StatusMessageHeader>;
  /** Reads a single `StatusMessageMissionStat` using its globally unique `ID`. */
  statusMessageMissionStatByNodeId?: Maybe<StatusMessageMissionStat>;
  /** Reads a single `VehicleStateReason` using its globally unique `ID`. */
  vehicleStateReasonByNodeId?: Maybe<VehicleStateReason>;
  /** Reads a single `VehicleState` using its globally unique `ID`. */
  vehicleStateByNodeId?: Maybe<VehicleState>;
  /** Reads a single `VehicleStatus` using its globally unique `ID`. */
  vehicleStatusByNodeId?: Maybe<VehicleStatus>;
  /** Reads a single `VehicleStatusDetail` using its globally unique `ID`. */
  vehicleStatusDetailByNodeId?: Maybe<VehicleStatusDetail>;
  /** Reads a single `ObjectMessage` using its globally unique `ID`. */
  objectMessageByNodeId?: Maybe<ObjectMessage>;
  /** Reads a single `ObjectMessageCentroidLocation` using its globally unique `ID`. */
  objectMessageCentroidLocationByNodeId?: Maybe<ObjectMessageCentroidLocation>;
  /** Reads a single `ObjectMessageCentroidRpy` using its globally unique `ID`. */
  objectMessageCentroidRpyByNodeId?: Maybe<ObjectMessageCentroidRpy>;
  /** Reads a single `ObjectMessageCircleCenter` using its globally unique `ID`. */
  objectMessageCircleCenterByNodeId?: Maybe<ObjectMessageCircleCenter>;
  /** Reads a single `ObjectMessageDetection` using its globally unique `ID`. */
  objectMessageDetectionByNodeId?: Maybe<ObjectMessageDetection>;
  /** Reads a single `ObjectMessageDetectionCuboid` using its globally unique `ID`. */
  objectMessageDetectionCuboidByNodeId?: Maybe<ObjectMessageDetectionCuboid>;
  /** Reads a single `ObjectMessageDetectionCuboidCentroid` using its globally unique `ID`. */
  objectMessageDetectionCuboidCentroidByNodeId?: Maybe<ObjectMessageDetectionCuboidCentroid>;
  /** Reads a single `ObjectMessageDetectionCuboidDimension` using its globally unique `ID`. */
  objectMessageDetectionCuboidDimensionByNodeId?: Maybe<ObjectMessageDetectionCuboidDimension>;
  /** Reads a single `ObjectMessageDetectionCuboidOrientation` using its globally unique `ID`. */
  objectMessageDetectionCuboidOrientationByNodeId?: Maybe<ObjectMessageDetectionCuboidOrientation>;
  /** Reads a single `ObjectMessageDetectionHeader` using its globally unique `ID`. */
  objectMessageDetectionHeaderByNodeId?: Maybe<ObjectMessageDetectionHeader>;
  /** Reads a single `ObjectMessageDetectionRoi` using its globally unique `ID`. */
  objectMessageDetectionRoiByNodeId?: Maybe<ObjectMessageDetectionRoi>;
  /** Reads a single `ObjectMessageEcef` using its globally unique `ID`. */
  objectMessageEcefByNodeId?: Maybe<ObjectMessageEcef>;
  /** Reads a single `ObjectMessageEnu` using its globally unique `ID`. */
  objectMessageEnuByNodeId?: Maybe<ObjectMessageEnu>;
  /** Reads a single `ObjectMessageFieldOrigin` using its globally unique `ID`. */
  objectMessageFieldOriginByNodeId?: Maybe<ObjectMessageFieldOrigin>;
  /** Reads a single `ObjectMessageHeader` using its globally unique `ID`. */
  objectMessageHeaderByNodeId?: Maybe<ObjectMessageHeader>;
  /** Reads a single `ObjectMessageLla` using its globally unique `ID`. */
  objectMessageLlaByNodeId?: Maybe<ObjectMessageLla>;
  /** Reads a single `ObjectMessageVertex` using its globally unique `ID`. */
  objectMessageVertexByNodeId?: Maybe<ObjectMessageVertex>;
  /** Reads a single `ObjectMessageXyzCamera` using its globally unique `ID`. */
  objectMessageXyzCameraByNodeId?: Maybe<ObjectMessageXyzCamera>;
  /** Reads a single `ObjectMessageXyzStarfire` using its globally unique `ID`. */
  objectMessageXyzStarfireByNodeId?: Maybe<ObjectMessageXyzStarfire>;
  /** Reads a single `Object` using its globally unique `ID`. */
  objectByNodeId?: Maybe<Object>;
};


/** The root query type which gives access points into the data universe. */
export type QueryNodeArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryVehicleTopicsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<VehicleTopicsOrderBy>>;
  condition?: Maybe<VehicleTopicCondition>;
  filter?: Maybe<VehicleTopicFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryVehicleTypesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<VehicleTypesOrderBy>>;
  condition?: Maybe<VehicleTypeCondition>;
  filter?: Maybe<VehicleTypeFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryVehiclesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<VehiclesOrderBy>>;
  condition?: Maybe<VehicleCondition>;
  filter?: Maybe<VehicleFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryVehiclesOfflinesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<VehiclesOfflinesOrderBy>>;
  condition?: Maybe<VehiclesOfflineCondition>;
  filter?: Maybe<VehiclesOfflineFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryVehiclesOnlinesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<VehiclesOnlinesOrderBy>>;
  condition?: Maybe<VehiclesOnlineCondition>;
  filter?: Maybe<VehiclesOnlineFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryTopicCategoriesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<TopicCategoriesOrderBy>>;
  condition?: Maybe<TopicCategoryCondition>;
  filter?: Maybe<TopicCategoryFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryTopicTypesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<TopicTypesOrderBy>>;
  condition?: Maybe<TopicTypeCondition>;
  filter?: Maybe<TopicTypeFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryTopicsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<TopicsOrderBy>>;
  condition?: Maybe<TopicCondition>;
  filter?: Maybe<TopicFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryTestsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<TestsOrderBy>>;
  condition?: Maybe<TestCondition>;
  filter?: Maybe<TestFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryVehicleLogMessageStampsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<VehicleLogMessageStampsOrderBy>>;
  condition?: Maybe<VehicleLogMessageStampCondition>;
  filter?: Maybe<VehicleLogMessageStampFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryVehicleLogMessagesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<VehicleLogMessagesOrderBy>>;
  condition?: Maybe<VehicleLogMessageCondition>;
  filter?: Maybe<VehicleLogMessageFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryVehicleLogNodeTypesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<VehicleLogNodeTypesOrderBy>>;
  condition?: Maybe<VehicleLogNodeTypeCondition>;
  filter?: Maybe<VehicleLogNodeTypeFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryVehicleLogsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<VehicleLogsOrderBy>>;
  condition?: Maybe<VehicleLogCondition>;
  filter?: Maybe<VehicleLogFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryStarfiresArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<StarfiresOrderBy>>;
  condition?: Maybe<StarfireCondition>;
  filter?: Maybe<StarfireFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryStarfireHeadersArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<StarfireHeadersOrderBy>>;
  condition?: Maybe<StarfireHeaderCondition>;
  filter?: Maybe<StarfireHeaderFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryStarfireMessagesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<StarfireMessagesOrderBy>>;
  condition?: Maybe<StarfireMessageCondition>;
  filter?: Maybe<StarfireMessageFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryCamerasArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CamerasOrderBy>>;
  condition?: Maybe<CameraCondition>;
  filter?: Maybe<CameraFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryCameraHistogramsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CameraHistogramsOrderBy>>;
  condition?: Maybe<CameraHistogramCondition>;
  filter?: Maybe<CameraHistogramFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryCameraMessagesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CameraMessagesOrderBy>>;
  condition?: Maybe<CameraMessageCondition>;
  filter?: Maybe<CameraMessageFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryCameraMessageHeadersArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CameraMessageHeadersOrderBy>>;
  condition?: Maybe<CameraMessageHeaderCondition>;
  filter?: Maybe<CameraMessageHeaderFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryCameraMetasArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CameraMetasOrderBy>>;
  condition?: Maybe<CameraMetaCondition>;
  filter?: Maybe<CameraMetaFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryCameraMetaEsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CameraMetaEsOrderBy>>;
  condition?: Maybe<CameraMetaECondition>;
  filter?: Maybe<CameraMetaEFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryCameraMetaFsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CameraMetaFsOrderBy>>;
  condition?: Maybe<CameraMetaFCondition>;
  filter?: Maybe<CameraMetaFFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryCameraMetaP1sArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CameraMetaP1sOrderBy>>;
  condition?: Maybe<CameraMetaP1Condition>;
  filter?: Maybe<CameraMetaP1Filter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryCameraMetaP2sArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CameraMetaP2sOrderBy>>;
  condition?: Maybe<CameraMetaP2Condition>;
  filter?: Maybe<CameraMetaP2Filter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryCameraMetaQsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CameraMetaQsOrderBy>>;
  condition?: Maybe<CameraMetaQCondition>;
  filter?: Maybe<CameraMetaQFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryCameraMetaR1sArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CameraMetaR1sOrderBy>>;
  condition?: Maybe<CameraMetaR1Condition>;
  filter?: Maybe<CameraMetaR1Filter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryCameraMetaR2sArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CameraMetaR2sOrderBy>>;
  condition?: Maybe<CameraMetaR2Condition>;
  filter?: Maybe<CameraMetaR2Filter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryCameraPairsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CameraPairsOrderBy>>;
  condition?: Maybe<CameraPairCondition>;
  filter?: Maybe<CameraPairFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryCameraPairMessagesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CameraPairMessagesOrderBy>>;
  condition?: Maybe<CameraPairMessageCondition>;
  filter?: Maybe<CameraPairMessageFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryCameraRoisArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CameraRoisOrderBy>>;
  condition?: Maybe<CameraRoiCondition>;
  filter?: Maybe<CameraRoiFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryFullHistogramsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<FullHistogramsOrderBy>>;
  condition?: Maybe<FullHistogramCondition>;
  filter?: Maybe<FullHistogramFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryImageDataArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ImageDataOrderBy>>;
  condition?: Maybe<ImageDatumCondition>;
  filter?: Maybe<ImageDatumFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryImageHeadersArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ImageHeadersOrderBy>>;
  condition?: Maybe<ImageHeaderCondition>;
  filter?: Maybe<ImageHeaderFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryImageHeaderStampsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ImageHeaderStampsOrderBy>>;
  condition?: Maybe<ImageHeaderStampCondition>;
  filter?: Maybe<ImageHeaderStampFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryImagesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ImagesOrderBy>>;
  condition?: Maybe<ImageCondition>;
  filter?: Maybe<ImageFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QuerySegmentationMapsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<SegmentationMapsOrderBy>>;
  condition?: Maybe<SegmentationMapCondition>;
  filter?: Maybe<SegmentationMapFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QuerySideIntrinsicsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<SideIntrinsicsOrderBy>>;
  condition?: Maybe<SideIntrinsicCondition>;
  filter?: Maybe<SideIntrinsicFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QuerySideIntrinsicsDsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<SideIntrinsicsDsOrderBy>>;
  condition?: Maybe<SideIntrinsicsDCondition>;
  filter?: Maybe<SideIntrinsicsDFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QuerySideIntrinsicsKsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<SideIntrinsicsKsOrderBy>>;
  condition?: Maybe<SideIntrinsicsKCondition>;
  filter?: Maybe<SideIntrinsicsKFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QuerySmallHistogramsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<SmallHistogramsOrderBy>>;
  condition?: Maybe<SmallHistogramCondition>;
  filter?: Maybe<SmallHistogramFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryStereoExtrinsicsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<StereoExtrinsicsOrderBy>>;
  condition?: Maybe<StereoExtrinsicCondition>;
  filter?: Maybe<StereoExtrinsicFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryStereoExtrinsicsRsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<StereoExtrinsicsRsOrderBy>>;
  condition?: Maybe<StereoExtrinsicsRCondition>;
  filter?: Maybe<StereoExtrinsicsRFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryStereoExtrinsicsRRodriguesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<StereoExtrinsicsRRodriguesOrderBy>>;
  condition?: Maybe<StereoExtrinsicsRRodrigueCondition>;
  filter?: Maybe<StereoExtrinsicsRRodrigueFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryStereoExtrinsicsTsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<StereoExtrinsicsTsOrderBy>>;
  condition?: Maybe<StereoExtrinsicsTCondition>;
  filter?: Maybe<StereoExtrinsicsTFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryTractorExtrinsicsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<TractorExtrinsicsOrderBy>>;
  condition?: Maybe<TractorExtrinsicCondition>;
  filter?: Maybe<TractorExtrinsicFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryTractorExtrinsicsRsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<TractorExtrinsicsRsOrderBy>>;
  condition?: Maybe<TractorExtrinsicsRCondition>;
  filter?: Maybe<TractorExtrinsicsRFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryTractorExtrinsicsRRodriguesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<TractorExtrinsicsRRodriguesOrderBy>>;
  condition?: Maybe<TractorExtrinsicsRRodrigueCondition>;
  filter?: Maybe<TractorExtrinsicsRRodrigueFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryTractorExtrinsicsTsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<TractorExtrinsicsTsOrderBy>>;
  condition?: Maybe<TractorExtrinsicsTCondition>;
  filter?: Maybe<TractorExtrinsicsTFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAlertTypesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<AlertTypesOrderBy>>;
  condition?: Maybe<AlertTypeCondition>;
  filter?: Maybe<AlertTypeFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAlertsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<AlertsOrderBy>>;
  condition?: Maybe<AlertCondition>;
  filter?: Maybe<AlertFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryStatusMessagesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<StatusMessagesOrderBy>>;
  condition?: Maybe<StatusMessageCondition>;
  filter?: Maybe<StatusMessageFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryStatusMessageHeadersArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<StatusMessageHeadersOrderBy>>;
  condition?: Maybe<StatusMessageHeaderCondition>;
  filter?: Maybe<StatusMessageHeaderFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryStatusMessageMissionStatsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<StatusMessageMissionStatsOrderBy>>;
  condition?: Maybe<StatusMessageMissionStatCondition>;
  filter?: Maybe<StatusMessageMissionStatFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryVehicleStateReasonsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<VehicleStateReasonsOrderBy>>;
  condition?: Maybe<VehicleStateReasonCondition>;
  filter?: Maybe<VehicleStateReasonFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryVehicleStatesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<VehicleStatesOrderBy>>;
  condition?: Maybe<VehicleStateCondition>;
  filter?: Maybe<VehicleStateFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryVehicleStatusesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<VehicleStatusesOrderBy>>;
  condition?: Maybe<VehicleStatusCondition>;
  filter?: Maybe<VehicleStatusFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryVehicleStatusDetailsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<VehicleStatusDetailsOrderBy>>;
  condition?: Maybe<VehicleStatusDetailCondition>;
  filter?: Maybe<VehicleStatusDetailFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryObjectDetectionImagesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ObjectDetectionImagesOrderBy>>;
  condition?: Maybe<ObjectDetectionImageCondition>;
  filter?: Maybe<ObjectDetectionImageFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryObjectMessagesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ObjectMessagesOrderBy>>;
  condition?: Maybe<ObjectMessageCondition>;
  filter?: Maybe<ObjectMessageFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryObjectMessageCentroidLocationsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ObjectMessageCentroidLocationsOrderBy>>;
  condition?: Maybe<ObjectMessageCentroidLocationCondition>;
  filter?: Maybe<ObjectMessageCentroidLocationFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryObjectMessageCentroidRpiesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ObjectMessageCentroidRpiesOrderBy>>;
  condition?: Maybe<ObjectMessageCentroidRpyCondition>;
  filter?: Maybe<ObjectMessageCentroidRpyFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryObjectMessageCircleCentersArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ObjectMessageCircleCentersOrderBy>>;
  condition?: Maybe<ObjectMessageCircleCenterCondition>;
  filter?: Maybe<ObjectMessageCircleCenterFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryObjectMessageDetectionsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ObjectMessageDetectionsOrderBy>>;
  condition?: Maybe<ObjectMessageDetectionCondition>;
  filter?: Maybe<ObjectMessageDetectionFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryObjectMessageDetectionCuboidsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ObjectMessageDetectionCuboidsOrderBy>>;
  condition?: Maybe<ObjectMessageDetectionCuboidCondition>;
  filter?: Maybe<ObjectMessageDetectionCuboidFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryObjectMessageDetectionCuboidCentroidsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ObjectMessageDetectionCuboidCentroidsOrderBy>>;
  condition?: Maybe<ObjectMessageDetectionCuboidCentroidCondition>;
  filter?: Maybe<ObjectMessageDetectionCuboidCentroidFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryObjectMessageDetectionCuboidDimensionsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ObjectMessageDetectionCuboidDimensionsOrderBy>>;
  condition?: Maybe<ObjectMessageDetectionCuboidDimensionCondition>;
  filter?: Maybe<ObjectMessageDetectionCuboidDimensionFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryObjectMessageDetectionCuboidOrientationsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ObjectMessageDetectionCuboidOrientationsOrderBy>>;
  condition?: Maybe<ObjectMessageDetectionCuboidOrientationCondition>;
  filter?: Maybe<ObjectMessageDetectionCuboidOrientationFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryObjectMessageDetectionHeadersArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ObjectMessageDetectionHeadersOrderBy>>;
  condition?: Maybe<ObjectMessageDetectionHeaderCondition>;
  filter?: Maybe<ObjectMessageDetectionHeaderFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryObjectMessageDetectionRoisArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ObjectMessageDetectionRoisOrderBy>>;
  condition?: Maybe<ObjectMessageDetectionRoiCondition>;
  filter?: Maybe<ObjectMessageDetectionRoiFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryObjectMessageEcefsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ObjectMessageEcefsOrderBy>>;
  condition?: Maybe<ObjectMessageEcefCondition>;
  filter?: Maybe<ObjectMessageEcefFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryObjectMessageEnusArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ObjectMessageEnusOrderBy>>;
  condition?: Maybe<ObjectMessageEnuCondition>;
  filter?: Maybe<ObjectMessageEnuFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryObjectMessageFieldOriginsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ObjectMessageFieldOriginsOrderBy>>;
  condition?: Maybe<ObjectMessageFieldOriginCondition>;
  filter?: Maybe<ObjectMessageFieldOriginFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryObjectMessageHeadersArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ObjectMessageHeadersOrderBy>>;
  condition?: Maybe<ObjectMessageHeaderCondition>;
  filter?: Maybe<ObjectMessageHeaderFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryObjectMessageLlasArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ObjectMessageLlasOrderBy>>;
  condition?: Maybe<ObjectMessageLlaCondition>;
  filter?: Maybe<ObjectMessageLlaFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryObjectMessageVerticesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ObjectMessageVerticesOrderBy>>;
  condition?: Maybe<ObjectMessageVertexCondition>;
  filter?: Maybe<ObjectMessageVertexFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryObjectMessageXyzCamerasArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ObjectMessageXyzCamerasOrderBy>>;
  condition?: Maybe<ObjectMessageXyzCameraCondition>;
  filter?: Maybe<ObjectMessageXyzCameraFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryObjectMessageXyzStarfiresArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ObjectMessageXyzStarfiresOrderBy>>;
  condition?: Maybe<ObjectMessageXyzStarfireCondition>;
  filter?: Maybe<ObjectMessageXyzStarfireFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryObjectsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ObjectsOrderBy>>;
  condition?: Maybe<ObjectCondition>;
  filter?: Maybe<ObjectFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryVehicleTopicArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryVehicleTypeArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryVehicleTypeByTypeArgs = {
  type: Scalars['String'];
};


/** The root query type which gives access points into the data universe. */
export type QueryVehicleArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryVehicleByDeviceIdArgs = {
  deviceId: Scalars['String'];
};


/** The root query type which gives access points into the data universe. */
export type QueryVehiclesOnlineArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryVehiclesOnlineByVehicleIdArgs = {
  vehicleId: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTopicCategoryArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTopicTypeArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTopicTypeByModuleArgs = {
  module: Scalars['String'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTopicArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTopicByNameArgs = {
  name: Scalars['String'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTestArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryVehicleLogMessageStampArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryVehicleLogMessageArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryVehicleLogArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryStarfireArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryStarfireHeaderArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryStarfireMessageArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryCameraArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryCameraHistogramArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryCameraMessageArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryCameraMessageHeaderArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryCameraMetaArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryCameraMetaEArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryCameraMetaFArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryCameraMetaP1Args = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryCameraMetaP2Args = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryCameraMetaQArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryCameraMetaR1Args = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryCameraMetaR2Args = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryCameraPairArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryCameraPairMessageArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryCameraRoiArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryFullHistogramArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryImageDatumArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryImageHeaderArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryImageHeaderStampArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryImageArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QuerySegmentationMapArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QuerySideIntrinsicArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QuerySideIntrinsicsDArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QuerySideIntrinsicsKArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QuerySmallHistogramArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryStereoExtrinsicArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryStereoExtrinsicsRArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryStereoExtrinsicsRRodrigueArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryStereoExtrinsicsTArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTractorExtrinsicArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTractorExtrinsicsRArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTractorExtrinsicsRRodrigueArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTractorExtrinsicsTArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryAlertTypeArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryAlertArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryStatusMessageArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryStatusMessageHeaderArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryStatusMessageMissionStatArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryVehicleStateReasonArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryVehicleStateArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryVehicleStateByNameArgs = {
  name: Scalars['String'];
};


/** The root query type which gives access points into the data universe. */
export type QueryVehicleStateByCodeArgs = {
  code: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QueryVehicleStatusArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryVehicleStatusDetailArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryObjectMessageArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryObjectMessageCentroidLocationArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryObjectMessageCentroidRpyArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryObjectMessageCircleCenterArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryObjectMessageDetectionArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryObjectMessageDetectionCuboidArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryObjectMessageDetectionCuboidCentroidArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryObjectMessageDetectionCuboidDimensionArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryObjectMessageDetectionCuboidOrientationArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryObjectMessageDetectionHeaderArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryObjectMessageDetectionRoiArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryObjectMessageEcefArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryObjectMessageEnuArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryObjectMessageFieldOriginArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryObjectMessageHeaderArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryObjectMessageLlaArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryObjectMessageVertexArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryObjectMessageXyzCameraArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryObjectMessageXyzStarfireArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryObjectArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryVehicleTopicByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryVehicleTypeByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryVehicleByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryVehiclesOnlineByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTopicCategoryByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTopicTypeByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTopicByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTestByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryVehicleLogMessageStampByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryVehicleLogMessageByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryVehicleLogByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryStarfireByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryStarfireHeaderByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryStarfireMessageByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryCameraByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryCameraHistogramByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryCameraMessageByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryCameraMessageHeaderByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryCameraMetaByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryCameraMetaEByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryCameraMetaFByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryCameraMetaP1ByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryCameraMetaP2ByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryCameraMetaQByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryCameraMetaR1ByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryCameraMetaR2ByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryCameraPairByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryCameraPairMessageByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryCameraRoiByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryFullHistogramByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryImageDatumByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryImageHeaderByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryImageHeaderStampByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryImageByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QuerySegmentationMapByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QuerySideIntrinsicByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QuerySideIntrinsicsDByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QuerySideIntrinsicsKByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QuerySmallHistogramByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryStereoExtrinsicByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryStereoExtrinsicsRByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryStereoExtrinsicsRRodrigueByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryStereoExtrinsicsTByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTractorExtrinsicByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTractorExtrinsicsRByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTractorExtrinsicsRRodrigueByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTractorExtrinsicsTByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryAlertTypeByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryAlertByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryStatusMessageByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryStatusMessageHeaderByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryStatusMessageMissionStatByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryVehicleStateReasonByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryVehicleStateByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryVehicleStatusByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryVehicleStatusDetailByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryObjectMessageByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryObjectMessageCentroidLocationByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryObjectMessageCentroidRpyByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryObjectMessageCircleCenterByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryObjectMessageDetectionByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryObjectMessageDetectionCuboidByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryObjectMessageDetectionCuboidCentroidByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryObjectMessageDetectionCuboidDimensionByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryObjectMessageDetectionCuboidOrientationByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryObjectMessageDetectionHeaderByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryObjectMessageDetectionRoiByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryObjectMessageEcefByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryObjectMessageEnuByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryObjectMessageFieldOriginByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryObjectMessageHeaderByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryObjectMessageLlaByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryObjectMessageVertexByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryObjectMessageXyzCameraByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryObjectMessageXyzStarfireByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryObjectByNodeIdArgs = {
  nodeId: Scalars['ID'];
};

export type SqlAlertsPayload = {
  __typename?: 'SQLAlertsPayload';
  alerts?: Maybe<Alert>;
  event?: Maybe<Scalars['String']>;
};

export type SqlCameraPayload = {
  __typename?: 'SQLCameraPayload';
  camera?: Maybe<Camera>;
  id?: Maybe<Scalars['BigInt']>;
  event?: Maybe<Scalars['String']>;
};


export type SqlCameraPayloadCameraArgs = {
  vehicleId?: Maybe<Scalars['BigInt']>;
};

export type SqlObjectDetectionPayload = {
  __typename?: 'SQLObjectDetectionPayload';
  object?: Maybe<Object>;
  event?: Maybe<Scalars['String']>;
};


export type SqlObjectDetectionPayloadObjectArgs = {
  vehicleId?: Maybe<Scalars['BigInt']>;
};

export type SqlStarfirePayload = {
  __typename?: 'SQLStarfirePayload';
  starfire?: Maybe<Starfire>;
  event?: Maybe<Scalars['String']>;
};


export type SqlStarfirePayloadStarfireArgs = {
  vehicleId?: Maybe<Scalars['Float']>;
};

export type SqlVehicleLoggingPayload = {
  __typename?: 'SQLVehicleLoggingPayload';
  vehicle_logs?: Maybe<VehicleLog>;
  event?: Maybe<Scalars['String']>;
};


export type SqlVehicleLoggingPayloadVehicle_LogsArgs = {
  vehicleId?: Maybe<Scalars['BigInt']>;
};

export type SqlVehiclePayload = {
  __typename?: 'SQLVehiclePayload';
  vehicle?: Maybe<Vehicle>;
  event?: Maybe<Scalars['String']>;
};

export type SqlVehicleStatusPayload = {
  __typename?: 'SQLVehicleStatusPayload';
  vehicle_status?: Maybe<VehicleStatus>;
  event?: Maybe<Scalars['String']>;
};


export type SqlVehicleStatusPayloadVehicle_StatusArgs = {
  vehicleId?: Maybe<Scalars['BigInt']>;
};

export type SqlVehiclesOnlinePayload = {
  __typename?: 'SQLVehiclesOnlinePayload';
  vehicle_online?: Maybe<VehiclesOnline>;
  row?: Maybe<VehiclesOnline>;
  event?: Maybe<Scalars['String']>;
};


export type SqlVehiclesOnlinePayloadVehicle_OnlineArgs = {
  vehicleId?: Maybe<Scalars['BigInt']>;
};

/** Table segmentation map */
export type SegmentationMap = Node & {
  __typename?: 'SegmentationMap';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  /** id auto-incremented by database */
  id: Scalars['BigInt'];
  /** timestamp of segementation map */
  readingat: Scalars['Datetime'];
  /** topic of segementation map */
  topicId: Scalars['BigInt'];
  /** message of segementation map */
  msgId: Scalars['BigInt'];
  /** vehicle of segementation map */
  vehicleId: Scalars['BigInt'];
  /** Reads a single `Topic` that is related to this `SegmentationMap`. */
  topic?: Maybe<Topic>;
  /** Reads a single `CameraMessage` that is related to this `SegmentationMap`. */
  msg?: Maybe<CameraMessage>;
  /** Reads a single `Vehicle` that is related to this `SegmentationMap`. */
  vehicle?: Maybe<Vehicle>;
};

/**
 * A condition to be used against `SegmentationMap` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type SegmentationMapCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `readingat` field. */
  readingat?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `topicId` field. */
  topicId?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `msgId` field. */
  msgId?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `vehicleId` field. */
  vehicleId?: Maybe<Scalars['BigInt']>;
};

/** A filter to be used against `SegmentationMap` object types. All fields are combined with a logical ‘and.’ */
export type SegmentationMapFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `readingat` field. */
  readingat?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `topicId` field. */
  topicId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `msgId` field. */
  msgId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `vehicleId` field. */
  vehicleId?: Maybe<BigIntFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<SegmentationMapFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<SegmentationMapFilter>>;
  /** Negates the expression. */
  not?: Maybe<SegmentationMapFilter>;
};

/** Represents an update to a `SegmentationMap`. Fields that are set will be updated. */
export type SegmentationMapPatch = {
  /** id auto-incremented by database */
  id?: Maybe<Scalars['BigInt']>;
  /** timestamp of segementation map */
  readingat?: Maybe<Scalars['Datetime']>;
  /** topic of segementation map */
  topicId?: Maybe<Scalars['BigInt']>;
  /** message of segementation map */
  msgId?: Maybe<Scalars['BigInt']>;
  /** vehicle of segementation map */
  vehicleId?: Maybe<Scalars['BigInt']>;
};

/** A connection to a list of `SegmentationMap` values. */
export type SegmentationMapsConnection = {
  __typename?: 'SegmentationMapsConnection';
  /** A list of `SegmentationMap` objects. */
  nodes: Array<Maybe<SegmentationMap>>;
  /** A list of edges which contains the `SegmentationMap` and cursor to aid in pagination. */
  edges: Array<SegmentationMapsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `SegmentationMap` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `SegmentationMap` edge in the connection. */
export type SegmentationMapsEdge = {
  __typename?: 'SegmentationMapsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `SegmentationMap` at the end of the edge. */
  node?: Maybe<SegmentationMap>;
};

/** Methods to use when ordering `SegmentationMap`. */
export enum SegmentationMapsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  ReadingatAsc = 'READINGAT_ASC',
  ReadingatDesc = 'READINGAT_DESC',
  TopicIdAsc = 'TOPIC_ID_ASC',
  TopicIdDesc = 'TOPIC_ID_DESC',
  MsgIdAsc = 'MSG_ID_ASC',
  MsgIdDesc = 'MSG_ID_DESC',
  VehicleIdAsc = 'VEHICLE_ID_ASC',
  VehicleIdDesc = 'VEHICLE_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/** Table side intrinsics from camera */
export type SideIntrinsic = Node & {
  __typename?: 'SideIntrinsic';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  /** Id generated by database, auto incremented */
  id: Scalars['BigInt'];
  /** height of side intrinsics */
  height: Scalars['Int'];
  /** width of side intrinsics */
  width: Scalars['Int'];
  /** k id of side intrinsics */
  kId: Scalars['BigInt'];
  /** d id id of side intrinsics */
  dId: Scalars['BigInt'];
  /** Reads a single `SideIntrinsicsK` that is related to this `SideIntrinsic`. */
  k?: Maybe<SideIntrinsicsK>;
  /** Reads a single `SideIntrinsicsD` that is related to this `SideIntrinsic`. */
  d?: Maybe<SideIntrinsicsD>;
  /** Reads and enables pagination through a set of `CameraMeta`. */
  cameraMetasByLeftIntrinsicsId: CameraMetasConnection;
  /** Reads and enables pagination through a set of `CameraMeta`. */
  cameraMetasByRightIntrinsicsId: CameraMetasConnection;
};


/** Table side intrinsics from camera */
export type SideIntrinsicCameraMetasByLeftIntrinsicsIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CameraMetasOrderBy>>;
  condition?: Maybe<CameraMetaCondition>;
  filter?: Maybe<CameraMetaFilter>;
};


/** Table side intrinsics from camera */
export type SideIntrinsicCameraMetasByRightIntrinsicsIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CameraMetasOrderBy>>;
  condition?: Maybe<CameraMetaCondition>;
  filter?: Maybe<CameraMetaFilter>;
};

/**
 * A condition to be used against `SideIntrinsic` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type SideIntrinsicCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `height` field. */
  height?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `width` field. */
  width?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `kId` field. */
  kId?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `dId` field. */
  dId?: Maybe<Scalars['BigInt']>;
};

/** A filter to be used against `SideIntrinsic` object types. All fields are combined with a logical ‘and.’ */
export type SideIntrinsicFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `height` field. */
  height?: Maybe<IntFilter>;
  /** Filter by the object’s `width` field. */
  width?: Maybe<IntFilter>;
  /** Filter by the object’s `kId` field. */
  kId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `dId` field. */
  dId?: Maybe<BigIntFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<SideIntrinsicFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<SideIntrinsicFilter>>;
  /** Negates the expression. */
  not?: Maybe<SideIntrinsicFilter>;
};

/** A connection to a list of `SideIntrinsic` values. */
export type SideIntrinsicsConnection = {
  __typename?: 'SideIntrinsicsConnection';
  /** A list of `SideIntrinsic` objects. */
  nodes: Array<Maybe<SideIntrinsic>>;
  /** A list of edges which contains the `SideIntrinsic` and cursor to aid in pagination. */
  edges: Array<SideIntrinsicsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `SideIntrinsic` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** Table side intrinsics d from camera */
export type SideIntrinsicsD = Node & {
  __typename?: 'SideIntrinsicsD';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  /** Id generated by database, auto incremented */
  id: Scalars['BigInt'];
  data: Scalars['String'];
  /** Reads and enables pagination through a set of `SideIntrinsic`. */
  sideIntrinsicsByDId: SideIntrinsicsConnection;
};


/** Table side intrinsics d from camera */
export type SideIntrinsicsDSideIntrinsicsByDIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<SideIntrinsicsOrderBy>>;
  condition?: Maybe<SideIntrinsicCondition>;
  filter?: Maybe<SideIntrinsicFilter>;
};

/**
 * A condition to be used against `SideIntrinsicsD` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type SideIntrinsicsDCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `data` field. */
  data?: Maybe<Scalars['String']>;
};

/** A filter to be used against `SideIntrinsicsD` object types. All fields are combined with a logical ‘and.’ */
export type SideIntrinsicsDFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `data` field. */
  data?: Maybe<StringFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<SideIntrinsicsDFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<SideIntrinsicsDFilter>>;
  /** Negates the expression. */
  not?: Maybe<SideIntrinsicsDFilter>;
};

/** An input for mutations affecting `SideIntrinsicsD` */
export type SideIntrinsicsDInput = {
  data: Scalars['String'];
};

/** Represents an update to a `SideIntrinsicsD`. Fields that are set will be updated. */
export type SideIntrinsicsDPatch = {
  data?: Maybe<Scalars['String']>;
};

/** A connection to a list of `SideIntrinsicsD` values. */
export type SideIntrinsicsDsConnection = {
  __typename?: 'SideIntrinsicsDsConnection';
  /** A list of `SideIntrinsicsD` objects. */
  nodes: Array<Maybe<SideIntrinsicsD>>;
  /** A list of edges which contains the `SideIntrinsicsD` and cursor to aid in pagination. */
  edges: Array<SideIntrinsicsDsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `SideIntrinsicsD` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `SideIntrinsicsD` edge in the connection. */
export type SideIntrinsicsDsEdge = {
  __typename?: 'SideIntrinsicsDsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `SideIntrinsicsD` at the end of the edge. */
  node?: Maybe<SideIntrinsicsD>;
};

/** Methods to use when ordering `SideIntrinsicsD`. */
export enum SideIntrinsicsDsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  DataAsc = 'DATA_ASC',
  DataDesc = 'DATA_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/** A `SideIntrinsic` edge in the connection. */
export type SideIntrinsicsEdge = {
  __typename?: 'SideIntrinsicsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `SideIntrinsic` at the end of the edge. */
  node?: Maybe<SideIntrinsic>;
};

/** Table side intrinsics k from camera */
export type SideIntrinsicsK = Node & {
  __typename?: 'SideIntrinsicsK';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  /** Id generated by database, auto incremented */
  id: Scalars['BigInt'];
  data: Scalars['String'];
  /** Reads and enables pagination through a set of `SideIntrinsic`. */
  sideIntrinsicsByKId: SideIntrinsicsConnection;
};


/** Table side intrinsics k from camera */
export type SideIntrinsicsKSideIntrinsicsByKIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<SideIntrinsicsOrderBy>>;
  condition?: Maybe<SideIntrinsicCondition>;
  filter?: Maybe<SideIntrinsicFilter>;
};

/**
 * A condition to be used against `SideIntrinsicsK` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type SideIntrinsicsKCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `data` field. */
  data?: Maybe<Scalars['String']>;
};

/** A filter to be used against `SideIntrinsicsK` object types. All fields are combined with a logical ‘and.’ */
export type SideIntrinsicsKFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `data` field. */
  data?: Maybe<StringFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<SideIntrinsicsKFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<SideIntrinsicsKFilter>>;
  /** Negates the expression. */
  not?: Maybe<SideIntrinsicsKFilter>;
};

/** An input for mutations affecting `SideIntrinsicsK` */
export type SideIntrinsicsKInput = {
  data: Scalars['String'];
};

/** Represents an update to a `SideIntrinsicsK`. Fields that are set will be updated. */
export type SideIntrinsicsKPatch = {
  data?: Maybe<Scalars['String']>;
};

/** A connection to a list of `SideIntrinsicsK` values. */
export type SideIntrinsicsKsConnection = {
  __typename?: 'SideIntrinsicsKsConnection';
  /** A list of `SideIntrinsicsK` objects. */
  nodes: Array<Maybe<SideIntrinsicsK>>;
  /** A list of edges which contains the `SideIntrinsicsK` and cursor to aid in pagination. */
  edges: Array<SideIntrinsicsKsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `SideIntrinsicsK` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `SideIntrinsicsK` edge in the connection. */
export type SideIntrinsicsKsEdge = {
  __typename?: 'SideIntrinsicsKsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `SideIntrinsicsK` at the end of the edge. */
  node?: Maybe<SideIntrinsicsK>;
};

/** Methods to use when ordering `SideIntrinsicsK`. */
export enum SideIntrinsicsKsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  DataAsc = 'DATA_ASC',
  DataDesc = 'DATA_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/** Methods to use when ordering `SideIntrinsic`. */
export enum SideIntrinsicsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  HeightAsc = 'HEIGHT_ASC',
  HeightDesc = 'HEIGHT_DESC',
  WidthAsc = 'WIDTH_ASC',
  WidthDesc = 'WIDTH_DESC',
  KIdAsc = 'K_ID_ASC',
  KIdDesc = 'K_ID_DESC',
  DIdAsc = 'D_ID_ASC',
  DIdDesc = 'D_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/** Table small histogram from camera */
export type SmallHistogram = Node & {
  __typename?: 'SmallHistogram';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  /** Id generated by database, auto incremented */
  id: Scalars['BigInt'];
  /** data for small histogram */
  data: Scalars['String'];
  /** Reads and enables pagination through a set of `CameraHistogram`. */
  cameraHistograms: CameraHistogramsConnection;
};


/** Table small histogram from camera */
export type SmallHistogramCameraHistogramsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CameraHistogramsOrderBy>>;
  condition?: Maybe<CameraHistogramCondition>;
  filter?: Maybe<CameraHistogramFilter>;
};

/**
 * A condition to be used against `SmallHistogram` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type SmallHistogramCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `data` field. */
  data?: Maybe<Scalars['String']>;
};

/** A filter to be used against `SmallHistogram` object types. All fields are combined with a logical ‘and.’ */
export type SmallHistogramFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `data` field. */
  data?: Maybe<StringFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<SmallHistogramFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<SmallHistogramFilter>>;
  /** Negates the expression. */
  not?: Maybe<SmallHistogramFilter>;
};

/** A connection to a list of `SmallHistogram` values. */
export type SmallHistogramsConnection = {
  __typename?: 'SmallHistogramsConnection';
  /** A list of `SmallHistogram` objects. */
  nodes: Array<Maybe<SmallHistogram>>;
  /** A list of edges which contains the `SmallHistogram` and cursor to aid in pagination. */
  edges: Array<SmallHistogramsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `SmallHistogram` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `SmallHistogram` edge in the connection. */
export type SmallHistogramsEdge = {
  __typename?: 'SmallHistogramsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `SmallHistogram` at the end of the edge. */
  node?: Maybe<SmallHistogram>;
};

/** Methods to use when ordering `SmallHistogram`. */
export enum SmallHistogramsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  DataAsc = 'DATA_ASC',
  DataDesc = 'DATA_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/** This is the starfire table, which is related to the header object on the topic */
export type Starfire = Node & {
  __typename?: 'Starfire';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  /** The ID of starfire assigned by the database */
  id: Scalars['BigInt'];
  /** The reading timestamp of starfire message from vehicle */
  readingat: Scalars['Datetime'];
  /** The topic of starfire message from vehicle */
  topicId: Scalars['BigInt'];
  /** The message information of starfire message from vehicle */
  msgId: Scalars['BigInt'];
  /** The vehicle id information of starfire message */
  vehicleId: Scalars['BigInt'];
  /** The timestamp starfire was added to database */
  createdAt: Scalars['Datetime'];
  /** The timestamp starfire was updated on database */
  updatedAt: Scalars['Datetime'];
  /** Reads a single `Topic` that is related to this `Starfire`. */
  topic?: Maybe<Topic>;
  /** Reads a single `StarfireMessage` that is related to this `Starfire`. */
  msg?: Maybe<StarfireMessage>;
  /** Reads a single `Vehicle` that is related to this `Starfire`. */
  vehicle?: Maybe<Vehicle>;
};

/**
 * A condition to be used against `Starfire` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type StarfireCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `readingat` field. */
  readingat?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `topicId` field. */
  topicId?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `msgId` field. */
  msgId?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `vehicleId` field. */
  vehicleId?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: Maybe<Scalars['Datetime']>;
};

/** A filter to be used against `Starfire` object types. All fields are combined with a logical ‘and.’ */
export type StarfireFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `readingat` field. */
  readingat?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `topicId` field. */
  topicId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `msgId` field. */
  msgId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `vehicleId` field. */
  vehicleId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: Maybe<DatetimeFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<StarfireFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<StarfireFilter>>;
  /** Negates the expression. */
  not?: Maybe<StarfireFilter>;
};

/** This is the starfire header table, which is related to the header object on the topic message */
export type StarfireHeader = Node & {
  __typename?: 'StarfireHeader';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  /** The ID of starfire header assigned by the database */
  id: Scalars['BigInt'];
  /** The header id  of starfire header from vehicle */
  headerId: Scalars['BigInt'];
  /** The timestamp of starfire header from vehicle */
  readingat: Scalars['Datetime'];
  /** The seq of starfire header from vehicle */
  seq: Scalars['BigFloat'];
  /** The node of starfire header from vehicle */
  node: Scalars['String'];
  /** The timestamp of starfire header added to the database */
  createdAt: Scalars['Datetime'];
  /** The timestamp of starfire header was updated on the database */
  updatedAt: Scalars['Datetime'];
  /** Reads and enables pagination through a set of `StarfireMessage`. */
  starfireMessagesByHeaderId: StarfireMessagesConnection;
};


/** This is the starfire header table, which is related to the header object on the topic message */
export type StarfireHeaderStarfireMessagesByHeaderIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<StarfireMessagesOrderBy>>;
  condition?: Maybe<StarfireMessageCondition>;
  filter?: Maybe<StarfireMessageFilter>;
};

/**
 * A condition to be used against `StarfireHeader` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type StarfireHeaderCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `headerId` field. */
  headerId?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `readingat` field. */
  readingat?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `seq` field. */
  seq?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `node` field. */
  node?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: Maybe<Scalars['Datetime']>;
};

/** A filter to be used against `StarfireHeader` object types. All fields are combined with a logical ‘and.’ */
export type StarfireHeaderFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `headerId` field. */
  headerId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `readingat` field. */
  readingat?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `seq` field. */
  seq?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `node` field. */
  node?: Maybe<StringFilter>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: Maybe<DatetimeFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<StarfireHeaderFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<StarfireHeaderFilter>>;
  /** Negates the expression. */
  not?: Maybe<StarfireHeaderFilter>;
};

/** An input for mutations affecting `StarfireHeader` */
export type StarfireHeaderInput = {
  /** The header id  of starfire header from vehicle */
  headerId: Scalars['BigInt'];
  /** The timestamp of starfire header from vehicle */
  readingat: Scalars['Datetime'];
  /** The seq of starfire header from vehicle */
  seq: Scalars['BigFloat'];
  /** The node of starfire header from vehicle */
  node: Scalars['String'];
  /** The timestamp of starfire header was updated on the database */
  updatedAt?: Maybe<Scalars['Datetime']>;
};

/** Represents an update to a `StarfireHeader`. Fields that are set will be updated. */
export type StarfireHeaderPatch = {
  /** The header id  of starfire header from vehicle */
  headerId?: Maybe<Scalars['BigInt']>;
  /** The timestamp of starfire header from vehicle */
  readingat?: Maybe<Scalars['Datetime']>;
  /** The seq of starfire header from vehicle */
  seq?: Maybe<Scalars['BigFloat']>;
  /** The node of starfire header from vehicle */
  node?: Maybe<Scalars['String']>;
  /** The timestamp of starfire header was updated on the database */
  updatedAt?: Maybe<Scalars['Datetime']>;
};

/** A connection to a list of `StarfireHeader` values. */
export type StarfireHeadersConnection = {
  __typename?: 'StarfireHeadersConnection';
  /** A list of `StarfireHeader` objects. */
  nodes: Array<Maybe<StarfireHeader>>;
  /** A list of edges which contains the `StarfireHeader` and cursor to aid in pagination. */
  edges: Array<StarfireHeadersEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `StarfireHeader` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `StarfireHeader` edge in the connection. */
export type StarfireHeadersEdge = {
  __typename?: 'StarfireHeadersEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `StarfireHeader` at the end of the edge. */
  node?: Maybe<StarfireHeader>;
};

/** Methods to use when ordering `StarfireHeader`. */
export enum StarfireHeadersOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  HeaderIdAsc = 'HEADER_ID_ASC',
  HeaderIdDesc = 'HEADER_ID_DESC',
  ReadingatAsc = 'READINGAT_ASC',
  ReadingatDesc = 'READINGAT_DESC',
  SeqAsc = 'SEQ_ASC',
  SeqDesc = 'SEQ_DESC',
  NodeAsc = 'NODE_ASC',
  NodeDesc = 'NODE_DESC',
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/** An input for mutations affecting `Starfire` */
export type StarfireInput = {
  /** The reading timestamp of starfire message from vehicle */
  readingat: Scalars['Datetime'];
  /** The topic of starfire message from vehicle */
  topicId: Scalars['BigInt'];
  /** The message information of starfire message from vehicle */
  msgId: Scalars['BigInt'];
  /** The vehicle id information of starfire message */
  vehicleId: Scalars['BigInt'];
};

/** This is the starfire message table, which is related to the header object on the topic */
export type StarfireMessage = Node & {
  __typename?: 'StarfireMessage';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  /** The ID of starfire message assigned by the database */
  id: Scalars['BigInt'];
  /** The header id  of starfire message from vehicle */
  headerId: Scalars['BigInt'];
  /** The pgn_address of starfire message from vehicle */
  pgnAddress?: Maybe<Scalars['BigFloat']>;
  /** The serial number of starfire message from vehicle */
  serialNumber?: Maybe<Scalars['BigFloat']>;
  /** The type of starfire message from vehicle */
  type?: Maybe<Scalars['String']>;
  /** The latitude of starfire message from vehicle */
  latitude?: Maybe<Scalars['BigFloat']>;
  /** The longitude of starfire message from vehicle */
  longitude?: Maybe<Scalars['BigFloat']>;
  /** The altitude of starfire message from vehicle */
  altitude?: Maybe<Scalars['BigFloat']>;
  /** The bearing of starfire message from vehicle */
  bearing?: Maybe<Scalars['BigFloat']>;
  /** The speed of starfire message from vehicle */
  speed?: Maybe<Scalars['BigFloat']>;
  /** The pitch of starfire message from vehicle */
  pitch?: Maybe<Scalars['BigFloat']>;
  /** The roll of starfire message from vehicle */
  roll?: Maybe<Scalars['BigFloat']>;
  /** The yaw_rate of starfire message from vehicle */
  yawRate?: Maybe<Scalars['BigFloat']>;
  /** The correction_mode of starfire message from vehicle */
  correctionMode?: Maybe<Scalars['BigFloat']>;
  /** The snr_db of starfire message from vehicle */
  snrDb?: Maybe<Scalars['BigFloat']>;
  /** The is_gps_locked of starfire message from vehicle */
  isGpsLocked?: Maybe<Scalars['Boolean']>;
  /** The timestamp of starfire message added to the database */
  createdAt: Scalars['Datetime'];
  /** The timestamp of starfire message was updated on the database */
  updatedAt: Scalars['Datetime'];
  /** Reads a single `StarfireHeader` that is related to this `StarfireMessage`. */
  header?: Maybe<StarfireHeader>;
  /** Reads and enables pagination through a set of `Starfire`. */
  starfiresByMsgId: StarfiresConnection;
};


/** This is the starfire message table, which is related to the header object on the topic */
export type StarfireMessageStarfiresByMsgIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<StarfiresOrderBy>>;
  condition?: Maybe<StarfireCondition>;
  filter?: Maybe<StarfireFilter>;
};

/**
 * A condition to be used against `StarfireMessage` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type StarfireMessageCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `headerId` field. */
  headerId?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `pgnAddress` field. */
  pgnAddress?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `serialNumber` field. */
  serialNumber?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `type` field. */
  type?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `latitude` field. */
  latitude?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `longitude` field. */
  longitude?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `altitude` field. */
  altitude?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `bearing` field. */
  bearing?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `speed` field. */
  speed?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `pitch` field. */
  pitch?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `roll` field. */
  roll?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `yawRate` field. */
  yawRate?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `correctionMode` field. */
  correctionMode?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `snrDb` field. */
  snrDb?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `isGpsLocked` field. */
  isGpsLocked?: Maybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: Maybe<Scalars['Datetime']>;
};

/** A filter to be used against `StarfireMessage` object types. All fields are combined with a logical ‘and.’ */
export type StarfireMessageFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `headerId` field. */
  headerId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `pgnAddress` field. */
  pgnAddress?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `serialNumber` field. */
  serialNumber?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `type` field. */
  type?: Maybe<StringFilter>;
  /** Filter by the object’s `latitude` field. */
  latitude?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `longitude` field. */
  longitude?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `altitude` field. */
  altitude?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `bearing` field. */
  bearing?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `speed` field. */
  speed?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `pitch` field. */
  pitch?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `roll` field. */
  roll?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `yawRate` field. */
  yawRate?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `correctionMode` field. */
  correctionMode?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `snrDb` field. */
  snrDb?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `isGpsLocked` field. */
  isGpsLocked?: Maybe<BooleanFilter>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: Maybe<DatetimeFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<StarfireMessageFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<StarfireMessageFilter>>;
  /** Negates the expression. */
  not?: Maybe<StarfireMessageFilter>;
};

/** An input for mutations affecting `StarfireMessage` */
export type StarfireMessageInput = {
  /** The header id  of starfire message from vehicle */
  headerId: Scalars['BigInt'];
  /** The pgn_address of starfire message from vehicle */
  pgnAddress?: Maybe<Scalars['BigFloat']>;
  /** The serial number of starfire message from vehicle */
  serialNumber?: Maybe<Scalars['BigFloat']>;
  /** The type of starfire message from vehicle */
  type?: Maybe<Scalars['String']>;
  /** The latitude of starfire message from vehicle */
  latitude?: Maybe<Scalars['BigFloat']>;
  /** The longitude of starfire message from vehicle */
  longitude?: Maybe<Scalars['BigFloat']>;
  /** The altitude of starfire message from vehicle */
  altitude?: Maybe<Scalars['BigFloat']>;
  /** The bearing of starfire message from vehicle */
  bearing?: Maybe<Scalars['BigFloat']>;
  /** The speed of starfire message from vehicle */
  speed?: Maybe<Scalars['BigFloat']>;
  /** The pitch of starfire message from vehicle */
  pitch?: Maybe<Scalars['BigFloat']>;
  /** The roll of starfire message from vehicle */
  roll?: Maybe<Scalars['BigFloat']>;
  /** The yaw_rate of starfire message from vehicle */
  yawRate?: Maybe<Scalars['BigFloat']>;
  /** The correction_mode of starfire message from vehicle */
  correctionMode?: Maybe<Scalars['BigFloat']>;
  /** The snr_db of starfire message from vehicle */
  snrDb?: Maybe<Scalars['BigFloat']>;
  /** The is_gps_locked of starfire message from vehicle */
  isGpsLocked?: Maybe<Scalars['Boolean']>;
  /** The timestamp of starfire message was updated on the database */
  updatedAt?: Maybe<Scalars['Datetime']>;
};

/** Represents an update to a `StarfireMessage`. Fields that are set will be updated. */
export type StarfireMessagePatch = {
  /** The header id  of starfire message from vehicle */
  headerId?: Maybe<Scalars['BigInt']>;
  /** The pgn_address of starfire message from vehicle */
  pgnAddress?: Maybe<Scalars['BigFloat']>;
  /** The serial number of starfire message from vehicle */
  serialNumber?: Maybe<Scalars['BigFloat']>;
  /** The type of starfire message from vehicle */
  type?: Maybe<Scalars['String']>;
  /** The latitude of starfire message from vehicle */
  latitude?: Maybe<Scalars['BigFloat']>;
  /** The longitude of starfire message from vehicle */
  longitude?: Maybe<Scalars['BigFloat']>;
  /** The altitude of starfire message from vehicle */
  altitude?: Maybe<Scalars['BigFloat']>;
  /** The bearing of starfire message from vehicle */
  bearing?: Maybe<Scalars['BigFloat']>;
  /** The speed of starfire message from vehicle */
  speed?: Maybe<Scalars['BigFloat']>;
  /** The pitch of starfire message from vehicle */
  pitch?: Maybe<Scalars['BigFloat']>;
  /** The roll of starfire message from vehicle */
  roll?: Maybe<Scalars['BigFloat']>;
  /** The yaw_rate of starfire message from vehicle */
  yawRate?: Maybe<Scalars['BigFloat']>;
  /** The correction_mode of starfire message from vehicle */
  correctionMode?: Maybe<Scalars['BigFloat']>;
  /** The snr_db of starfire message from vehicle */
  snrDb?: Maybe<Scalars['BigFloat']>;
  /** The is_gps_locked of starfire message from vehicle */
  isGpsLocked?: Maybe<Scalars['Boolean']>;
  /** The timestamp of starfire message was updated on the database */
  updatedAt?: Maybe<Scalars['Datetime']>;
};

/** A connection to a list of `StarfireMessage` values. */
export type StarfireMessagesConnection = {
  __typename?: 'StarfireMessagesConnection';
  /** A list of `StarfireMessage` objects. */
  nodes: Array<Maybe<StarfireMessage>>;
  /** A list of edges which contains the `StarfireMessage` and cursor to aid in pagination. */
  edges: Array<StarfireMessagesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `StarfireMessage` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `StarfireMessage` edge in the connection. */
export type StarfireMessagesEdge = {
  __typename?: 'StarfireMessagesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `StarfireMessage` at the end of the edge. */
  node?: Maybe<StarfireMessage>;
};

/** Methods to use when ordering `StarfireMessage`. */
export enum StarfireMessagesOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  HeaderIdAsc = 'HEADER_ID_ASC',
  HeaderIdDesc = 'HEADER_ID_DESC',
  PgnAddressAsc = 'PGN_ADDRESS_ASC',
  PgnAddressDesc = 'PGN_ADDRESS_DESC',
  SerialNumberAsc = 'SERIAL_NUMBER_ASC',
  SerialNumberDesc = 'SERIAL_NUMBER_DESC',
  TypeAsc = 'TYPE_ASC',
  TypeDesc = 'TYPE_DESC',
  LatitudeAsc = 'LATITUDE_ASC',
  LatitudeDesc = 'LATITUDE_DESC',
  LongitudeAsc = 'LONGITUDE_ASC',
  LongitudeDesc = 'LONGITUDE_DESC',
  AltitudeAsc = 'ALTITUDE_ASC',
  AltitudeDesc = 'ALTITUDE_DESC',
  BearingAsc = 'BEARING_ASC',
  BearingDesc = 'BEARING_DESC',
  SpeedAsc = 'SPEED_ASC',
  SpeedDesc = 'SPEED_DESC',
  PitchAsc = 'PITCH_ASC',
  PitchDesc = 'PITCH_DESC',
  RollAsc = 'ROLL_ASC',
  RollDesc = 'ROLL_DESC',
  YawRateAsc = 'YAW_RATE_ASC',
  YawRateDesc = 'YAW_RATE_DESC',
  CorrectionModeAsc = 'CORRECTION_MODE_ASC',
  CorrectionModeDesc = 'CORRECTION_MODE_DESC',
  SnrDbAsc = 'SNR_DB_ASC',
  SnrDbDesc = 'SNR_DB_DESC',
  IsGpsLockedAsc = 'IS_GPS_LOCKED_ASC',
  IsGpsLockedDesc = 'IS_GPS_LOCKED_DESC',
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/** Represents an update to a `Starfire`. Fields that are set will be updated. */
export type StarfirePatch = {
  /** The reading timestamp of starfire message from vehicle */
  readingat?: Maybe<Scalars['Datetime']>;
  /** The topic of starfire message from vehicle */
  topicId?: Maybe<Scalars['BigInt']>;
  /** The message information of starfire message from vehicle */
  msgId?: Maybe<Scalars['BigInt']>;
  /** The vehicle id information of starfire message */
  vehicleId?: Maybe<Scalars['BigInt']>;
};

/** A connection to a list of `Starfire` values. */
export type StarfiresConnection = {
  __typename?: 'StarfiresConnection';
  /** A list of `Starfire` objects. */
  nodes: Array<Maybe<Starfire>>;
  /** A list of edges which contains the `Starfire` and cursor to aid in pagination. */
  edges: Array<StarfiresEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Starfire` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `Starfire` edge in the connection. */
export type StarfiresEdge = {
  __typename?: 'StarfiresEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Starfire` at the end of the edge. */
  node?: Maybe<Starfire>;
};

/** Methods to use when ordering `Starfire`. */
export enum StarfiresOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  ReadingatAsc = 'READINGAT_ASC',
  ReadingatDesc = 'READINGAT_DESC',
  TopicIdAsc = 'TOPIC_ID_ASC',
  TopicIdDesc = 'TOPIC_ID_DESC',
  MsgIdAsc = 'MSG_ID_ASC',
  MsgIdDesc = 'MSG_ID_DESC',
  VehicleIdAsc = 'VEHICLE_ID_ASC',
  VehicleIdDesc = 'VEHICLE_ID_DESC',
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

export type StatusMessage = Node & {
  __typename?: 'StatusMessage';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  /** Column is auto incremented by database */
  id: Scalars['BigInt'];
  /** Message header for the a status */
  headerId: Scalars['BigInt'];
  missionStatsId: Scalars['BigInt'];
  /** Reads a single `StatusMessageHeader` that is related to this `StatusMessage`. */
  header?: Maybe<StatusMessageHeader>;
  /** Reads a single `StatusMessageMissionStat` that is related to this `StatusMessage`. */
  missionStats?: Maybe<StatusMessageMissionStat>;
  /** Reads and enables pagination through a set of `VehicleStatus`. */
  vehicleStatuses: VehicleStatusesConnection;
};


export type StatusMessageVehicleStatusesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<VehicleStatusesOrderBy>>;
  condition?: Maybe<VehicleStatusCondition>;
  filter?: Maybe<VehicleStatusFilter>;
};

/**
 * A condition to be used against `StatusMessage` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type StatusMessageCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `headerId` field. */
  headerId?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `missionStatsId` field. */
  missionStatsId?: Maybe<Scalars['BigInt']>;
};

/** A filter to be used against `StatusMessage` object types. All fields are combined with a logical ‘and.’ */
export type StatusMessageFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `headerId` field. */
  headerId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `missionStatsId` field. */
  missionStatsId?: Maybe<BigIntFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<StatusMessageFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<StatusMessageFilter>>;
  /** Negates the expression. */
  not?: Maybe<StatusMessageFilter>;
};

export type StatusMessageHeader = Node & {
  __typename?: 'StatusMessageHeader';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  /** Column is auto incremented by databased */
  id: Scalars['BigInt'];
  /** The header id passed from the vehicle in its message header */
  headerid: Scalars['BigInt'];
  /** Is the timestamp of when the telemetry was recorded on the vehicle */
  readingat: Scalars['Datetime'];
  seq: Scalars['Int'];
  /** IS the node responsible for the recording of telemetry */
  node: Scalars['String'];
  /** Reads and enables pagination through a set of `StatusMessage`. */
  statusMessagesByHeaderId: StatusMessagesConnection;
};


export type StatusMessageHeaderStatusMessagesByHeaderIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<StatusMessagesOrderBy>>;
  condition?: Maybe<StatusMessageCondition>;
  filter?: Maybe<StatusMessageFilter>;
};

/**
 * A condition to be used against `StatusMessageHeader` object types. All fields
 * are tested for equality and combined with a logical ‘and.’
 */
export type StatusMessageHeaderCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `headerid` field. */
  headerid?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `readingat` field. */
  readingat?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `seq` field. */
  seq?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `node` field. */
  node?: Maybe<Scalars['String']>;
};

/** A filter to be used against `StatusMessageHeader` object types. All fields are combined with a logical ‘and.’ */
export type StatusMessageHeaderFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `headerid` field. */
  headerid?: Maybe<BigIntFilter>;
  /** Filter by the object’s `readingat` field. */
  readingat?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `seq` field. */
  seq?: Maybe<IntFilter>;
  /** Filter by the object’s `node` field. */
  node?: Maybe<StringFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<StatusMessageHeaderFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<StatusMessageHeaderFilter>>;
  /** Negates the expression. */
  not?: Maybe<StatusMessageHeaderFilter>;
};

/** A connection to a list of `StatusMessageHeader` values. */
export type StatusMessageHeadersConnection = {
  __typename?: 'StatusMessageHeadersConnection';
  /** A list of `StatusMessageHeader` objects. */
  nodes: Array<Maybe<StatusMessageHeader>>;
  /** A list of edges which contains the `StatusMessageHeader` and cursor to aid in pagination. */
  edges: Array<StatusMessageHeadersEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `StatusMessageHeader` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `StatusMessageHeader` edge in the connection. */
export type StatusMessageHeadersEdge = {
  __typename?: 'StatusMessageHeadersEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `StatusMessageHeader` at the end of the edge. */
  node?: Maybe<StatusMessageHeader>;
};

/** Methods to use when ordering `StatusMessageHeader`. */
export enum StatusMessageHeadersOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  HeaderidAsc = 'HEADERID_ASC',
  HeaderidDesc = 'HEADERID_DESC',
  ReadingatAsc = 'READINGAT_ASC',
  ReadingatDesc = 'READINGAT_DESC',
  SeqAsc = 'SEQ_ASC',
  SeqDesc = 'SEQ_DESC',
  NodeAsc = 'NODE_ASC',
  NodeDesc = 'NODE_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/** An input for mutations affecting `StatusMessage` */
export type StatusMessageInput = {
  missionStatsId: Scalars['BigInt'];
};

/** Table is used to store the mission stats for a vehicle */
export type StatusMessageMissionStat = Node & {
  __typename?: 'StatusMessageMissionStat';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  /** Column is auto incremented by databased */
  id: Scalars['BigInt'];
  durationAutonomyStopped: Scalars['BigInt'];
  durationAutonomyDriving: Scalars['BigInt'];
  durationNoAutonomy: Scalars['BigInt'];
  durationTeleop: Scalars['BigInt'];
  autonomyDistanceTravelledM: Scalars['BigFloat'];
  autonomyAreaTravelledSqm: Scalars['BigFloat'];
  numStops: Scalars['BigInt'];
  numStateDemotion: Scalars['BigInt'];
  numTruePositives: Scalars['BigInt'];
  numFalsePositives: Scalars['BigInt'];
  numTeleopQueries: Scalars['BigInt'];
  missionStartTime: Scalars['Datetime'];
  /** Reads and enables pagination through a set of `StatusMessage`. */
  statusMessagesByMissionStatsId: StatusMessagesConnection;
};


/** Table is used to store the mission stats for a vehicle */
export type StatusMessageMissionStatStatusMessagesByMissionStatsIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<StatusMessagesOrderBy>>;
  condition?: Maybe<StatusMessageCondition>;
  filter?: Maybe<StatusMessageFilter>;
};

/**
 * A condition to be used against `StatusMessageMissionStat` object types. All
 * fields are tested for equality and combined with a logical ‘and.’
 */
export type StatusMessageMissionStatCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `durationAutonomyStopped` field. */
  durationAutonomyStopped?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `durationAutonomyDriving` field. */
  durationAutonomyDriving?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `durationNoAutonomy` field. */
  durationNoAutonomy?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `durationTeleop` field. */
  durationTeleop?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `autonomyDistanceTravelledM` field. */
  autonomyDistanceTravelledM?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `autonomyAreaTravelledSqm` field. */
  autonomyAreaTravelledSqm?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `numStops` field. */
  numStops?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `numStateDemotion` field. */
  numStateDemotion?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `numTruePositives` field. */
  numTruePositives?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `numFalsePositives` field. */
  numFalsePositives?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `numTeleopQueries` field. */
  numTeleopQueries?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `missionStartTime` field. */
  missionStartTime?: Maybe<Scalars['Datetime']>;
};

/** A filter to be used against `StatusMessageMissionStat` object types. All fields are combined with a logical ‘and.’ */
export type StatusMessageMissionStatFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `durationAutonomyStopped` field. */
  durationAutonomyStopped?: Maybe<BigIntFilter>;
  /** Filter by the object’s `durationAutonomyDriving` field. */
  durationAutonomyDriving?: Maybe<BigIntFilter>;
  /** Filter by the object’s `durationNoAutonomy` field. */
  durationNoAutonomy?: Maybe<BigIntFilter>;
  /** Filter by the object’s `durationTeleop` field. */
  durationTeleop?: Maybe<BigIntFilter>;
  /** Filter by the object’s `autonomyDistanceTravelledM` field. */
  autonomyDistanceTravelledM?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `autonomyAreaTravelledSqm` field. */
  autonomyAreaTravelledSqm?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `numStops` field. */
  numStops?: Maybe<BigIntFilter>;
  /** Filter by the object’s `numStateDemotion` field. */
  numStateDemotion?: Maybe<BigIntFilter>;
  /** Filter by the object’s `numTruePositives` field. */
  numTruePositives?: Maybe<BigIntFilter>;
  /** Filter by the object’s `numFalsePositives` field. */
  numFalsePositives?: Maybe<BigIntFilter>;
  /** Filter by the object’s `numTeleopQueries` field. */
  numTeleopQueries?: Maybe<BigIntFilter>;
  /** Filter by the object’s `missionStartTime` field. */
  missionStartTime?: Maybe<DatetimeFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<StatusMessageMissionStatFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<StatusMessageMissionStatFilter>>;
  /** Negates the expression. */
  not?: Maybe<StatusMessageMissionStatFilter>;
};

/** A connection to a list of `StatusMessageMissionStat` values. */
export type StatusMessageMissionStatsConnection = {
  __typename?: 'StatusMessageMissionStatsConnection';
  /** A list of `StatusMessageMissionStat` objects. */
  nodes: Array<Maybe<StatusMessageMissionStat>>;
  /** A list of edges which contains the `StatusMessageMissionStat` and cursor to aid in pagination. */
  edges: Array<StatusMessageMissionStatsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `StatusMessageMissionStat` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `StatusMessageMissionStat` edge in the connection. */
export type StatusMessageMissionStatsEdge = {
  __typename?: 'StatusMessageMissionStatsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `StatusMessageMissionStat` at the end of the edge. */
  node?: Maybe<StatusMessageMissionStat>;
};

/** Methods to use when ordering `StatusMessageMissionStat`. */
export enum StatusMessageMissionStatsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  DurationAutonomyStoppedAsc = 'DURATION_AUTONOMY_STOPPED_ASC',
  DurationAutonomyStoppedDesc = 'DURATION_AUTONOMY_STOPPED_DESC',
  DurationAutonomyDrivingAsc = 'DURATION_AUTONOMY_DRIVING_ASC',
  DurationAutonomyDrivingDesc = 'DURATION_AUTONOMY_DRIVING_DESC',
  DurationNoAutonomyAsc = 'DURATION_NO_AUTONOMY_ASC',
  DurationNoAutonomyDesc = 'DURATION_NO_AUTONOMY_DESC',
  DurationTeleopAsc = 'DURATION_TELEOP_ASC',
  DurationTeleopDesc = 'DURATION_TELEOP_DESC',
  AutonomyDistanceTravelledMAsc = 'AUTONOMY_DISTANCE_TRAVELLED_M_ASC',
  AutonomyDistanceTravelledMDesc = 'AUTONOMY_DISTANCE_TRAVELLED_M_DESC',
  AutonomyAreaTravelledSqmAsc = 'AUTONOMY_AREA_TRAVELLED_SQM_ASC',
  AutonomyAreaTravelledSqmDesc = 'AUTONOMY_AREA_TRAVELLED_SQM_DESC',
  NumStopsAsc = 'NUM_STOPS_ASC',
  NumStopsDesc = 'NUM_STOPS_DESC',
  NumStateDemotionAsc = 'NUM_STATE_DEMOTION_ASC',
  NumStateDemotionDesc = 'NUM_STATE_DEMOTION_DESC',
  NumTruePositivesAsc = 'NUM_TRUE_POSITIVES_ASC',
  NumTruePositivesDesc = 'NUM_TRUE_POSITIVES_DESC',
  NumFalsePositivesAsc = 'NUM_FALSE_POSITIVES_ASC',
  NumFalsePositivesDesc = 'NUM_FALSE_POSITIVES_DESC',
  NumTeleopQueriesAsc = 'NUM_TELEOP_QUERIES_ASC',
  NumTeleopQueriesDesc = 'NUM_TELEOP_QUERIES_DESC',
  MissionStartTimeAsc = 'MISSION_START_TIME_ASC',
  MissionStartTimeDesc = 'MISSION_START_TIME_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/** Represents an update to a `StatusMessage`. Fields that are set will be updated. */
export type StatusMessagePatch = {
  missionStatsId?: Maybe<Scalars['BigInt']>;
};

/** A connection to a list of `StatusMessage` values. */
export type StatusMessagesConnection = {
  __typename?: 'StatusMessagesConnection';
  /** A list of `StatusMessage` objects. */
  nodes: Array<Maybe<StatusMessage>>;
  /** A list of edges which contains the `StatusMessage` and cursor to aid in pagination. */
  edges: Array<StatusMessagesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `StatusMessage` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `StatusMessage` edge in the connection. */
export type StatusMessagesEdge = {
  __typename?: 'StatusMessagesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `StatusMessage` at the end of the edge. */
  node?: Maybe<StatusMessage>;
};

/** Methods to use when ordering `StatusMessage`. */
export enum StatusMessagesOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  HeaderIdAsc = 'HEADER_ID_ASC',
  HeaderIdDesc = 'HEADER_ID_DESC',
  MissionStatsIdAsc = 'MISSION_STATS_ID_ASC',
  MissionStatsIdDesc = 'MISSION_STATS_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/** Table stereo extrinsics from camera */
export type StereoExtrinsic = Node & {
  __typename?: 'StereoExtrinsic';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  /** Id generated by database, auto incremented */
  id: Scalars['BigInt'];
  /** t id for stereo extrinsics */
  tId: Scalars['BigInt'];
  /** r id for stereo extrinsics */
  rId: Scalars['BigInt'];
  /** r rodrigues id for stereo extrinsics */
  rRodriguesId: Scalars['BigInt'];
  /** Reads a single `StereoExtrinsicsT` that is related to this `StereoExtrinsic`. */
  t?: Maybe<StereoExtrinsicsT>;
  /** Reads a single `StereoExtrinsicsR` that is related to this `StereoExtrinsic`. */
  r?: Maybe<StereoExtrinsicsR>;
  /** Reads a single `StereoExtrinsicsRRodrigue` that is related to this `StereoExtrinsic`. */
  rRodrigues?: Maybe<StereoExtrinsicsRRodrigue>;
  /** Reads and enables pagination through a set of `CameraMeta`. */
  cameraMetasByStereoExtrinsicsId: CameraMetasConnection;
};


/** Table stereo extrinsics from camera */
export type StereoExtrinsicCameraMetasByStereoExtrinsicsIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CameraMetasOrderBy>>;
  condition?: Maybe<CameraMetaCondition>;
  filter?: Maybe<CameraMetaFilter>;
};

/**
 * A condition to be used against `StereoExtrinsic` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type StereoExtrinsicCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `tId` field. */
  tId?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `rId` field. */
  rId?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `rRodriguesId` field. */
  rRodriguesId?: Maybe<Scalars['BigInt']>;
};

/** A filter to be used against `StereoExtrinsic` object types. All fields are combined with a logical ‘and.’ */
export type StereoExtrinsicFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `tId` field. */
  tId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `rId` field. */
  rId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `rRodriguesId` field. */
  rRodriguesId?: Maybe<BigIntFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<StereoExtrinsicFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<StereoExtrinsicFilter>>;
  /** Negates the expression. */
  not?: Maybe<StereoExtrinsicFilter>;
};

/** A connection to a list of `StereoExtrinsic` values. */
export type StereoExtrinsicsConnection = {
  __typename?: 'StereoExtrinsicsConnection';
  /** A list of `StereoExtrinsic` objects. */
  nodes: Array<Maybe<StereoExtrinsic>>;
  /** A list of edges which contains the `StereoExtrinsic` and cursor to aid in pagination. */
  edges: Array<StereoExtrinsicsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `StereoExtrinsic` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `StereoExtrinsic` edge in the connection. */
export type StereoExtrinsicsEdge = {
  __typename?: 'StereoExtrinsicsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `StereoExtrinsic` at the end of the edge. */
  node?: Maybe<StereoExtrinsic>;
};

/** Methods to use when ordering `StereoExtrinsic`. */
export enum StereoExtrinsicsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  TIdAsc = 'T_ID_ASC',
  TIdDesc = 'T_ID_DESC',
  RIdAsc = 'R_ID_ASC',
  RIdDesc = 'R_ID_DESC',
  RRodriguesIdAsc = 'R_RODRIGUES_ID_ASC',
  RRodriguesIdDesc = 'R_RODRIGUES_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/** Table stereo extrinsics r from camera */
export type StereoExtrinsicsR = Node & {
  __typename?: 'StereoExtrinsicsR';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  /** Id generated by database, auto incremented */
  id: Scalars['BigInt'];
  data: Scalars['String'];
  /** Reads and enables pagination through a set of `StereoExtrinsic`. */
  stereoExtrinsicsByRId: StereoExtrinsicsConnection;
};


/** Table stereo extrinsics r from camera */
export type StereoExtrinsicsRStereoExtrinsicsByRIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<StereoExtrinsicsOrderBy>>;
  condition?: Maybe<StereoExtrinsicCondition>;
  filter?: Maybe<StereoExtrinsicFilter>;
};

/**
 * A condition to be used against `StereoExtrinsicsR` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type StereoExtrinsicsRCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `data` field. */
  data?: Maybe<Scalars['String']>;
};

/** A filter to be used against `StereoExtrinsicsR` object types. All fields are combined with a logical ‘and.’ */
export type StereoExtrinsicsRFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `data` field. */
  data?: Maybe<StringFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<StereoExtrinsicsRFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<StereoExtrinsicsRFilter>>;
  /** Negates the expression. */
  not?: Maybe<StereoExtrinsicsRFilter>;
};

/** An input for mutations affecting `StereoExtrinsicsR` */
export type StereoExtrinsicsRInput = {
  data: Scalars['String'];
};

/** Represents an update to a `StereoExtrinsicsR`. Fields that are set will be updated. */
export type StereoExtrinsicsRPatch = {
  data?: Maybe<Scalars['String']>;
};

/** Table stereo extrinsics r_rodrigues from camera */
export type StereoExtrinsicsRRodrigue = Node & {
  __typename?: 'StereoExtrinsicsRRodrigue';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  /** Id generated by database, auto incremented */
  id: Scalars['BigInt'];
  /** data of stereo extrinsics r_rodrigues */
  data: Scalars['String'];
  /** Reads and enables pagination through a set of `StereoExtrinsic`. */
  stereoExtrinsicsByRRodriguesId: StereoExtrinsicsConnection;
};


/** Table stereo extrinsics r_rodrigues from camera */
export type StereoExtrinsicsRRodrigueStereoExtrinsicsByRRodriguesIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<StereoExtrinsicsOrderBy>>;
  condition?: Maybe<StereoExtrinsicCondition>;
  filter?: Maybe<StereoExtrinsicFilter>;
};

/**
 * A condition to be used against `StereoExtrinsicsRRodrigue` object types. All
 * fields are tested for equality and combined with a logical ‘and.’
 */
export type StereoExtrinsicsRRodrigueCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `data` field. */
  data?: Maybe<Scalars['String']>;
};

/** A filter to be used against `StereoExtrinsicsRRodrigue` object types. All fields are combined with a logical ‘and.’ */
export type StereoExtrinsicsRRodrigueFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `data` field. */
  data?: Maybe<StringFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<StereoExtrinsicsRRodrigueFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<StereoExtrinsicsRRodrigueFilter>>;
  /** Negates the expression. */
  not?: Maybe<StereoExtrinsicsRRodrigueFilter>;
};

/** A connection to a list of `StereoExtrinsicsRRodrigue` values. */
export type StereoExtrinsicsRRodriguesConnection = {
  __typename?: 'StereoExtrinsicsRRodriguesConnection';
  /** A list of `StereoExtrinsicsRRodrigue` objects. */
  nodes: Array<Maybe<StereoExtrinsicsRRodrigue>>;
  /** A list of edges which contains the `StereoExtrinsicsRRodrigue` and cursor to aid in pagination. */
  edges: Array<StereoExtrinsicsRRodriguesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `StereoExtrinsicsRRodrigue` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `StereoExtrinsicsRRodrigue` edge in the connection. */
export type StereoExtrinsicsRRodriguesEdge = {
  __typename?: 'StereoExtrinsicsRRodriguesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `StereoExtrinsicsRRodrigue` at the end of the edge. */
  node?: Maybe<StereoExtrinsicsRRodrigue>;
};

/** Methods to use when ordering `StereoExtrinsicsRRodrigue`. */
export enum StereoExtrinsicsRRodriguesOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  DataAsc = 'DATA_ASC',
  DataDesc = 'DATA_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/** A connection to a list of `StereoExtrinsicsR` values. */
export type StereoExtrinsicsRsConnection = {
  __typename?: 'StereoExtrinsicsRsConnection';
  /** A list of `StereoExtrinsicsR` objects. */
  nodes: Array<Maybe<StereoExtrinsicsR>>;
  /** A list of edges which contains the `StereoExtrinsicsR` and cursor to aid in pagination. */
  edges: Array<StereoExtrinsicsRsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `StereoExtrinsicsR` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `StereoExtrinsicsR` edge in the connection. */
export type StereoExtrinsicsRsEdge = {
  __typename?: 'StereoExtrinsicsRsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `StereoExtrinsicsR` at the end of the edge. */
  node?: Maybe<StereoExtrinsicsR>;
};

/** Methods to use when ordering `StereoExtrinsicsR`. */
export enum StereoExtrinsicsRsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  DataAsc = 'DATA_ASC',
  DataDesc = 'DATA_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/** Table stereo extrinsics t from camera */
export type StereoExtrinsicsT = Node & {
  __typename?: 'StereoExtrinsicsT';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  /** Id generated by database, auto incremented */
  id: Scalars['BigInt'];
  /** data of stereo extrinsics r */
  data: Scalars['String'];
  /** Reads and enables pagination through a set of `StereoExtrinsic`. */
  stereoExtrinsicsByTId: StereoExtrinsicsConnection;
};


/** Table stereo extrinsics t from camera */
export type StereoExtrinsicsTStereoExtrinsicsByTIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<StereoExtrinsicsOrderBy>>;
  condition?: Maybe<StereoExtrinsicCondition>;
  filter?: Maybe<StereoExtrinsicFilter>;
};

/**
 * A condition to be used against `StereoExtrinsicsT` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type StereoExtrinsicsTCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `data` field. */
  data?: Maybe<Scalars['String']>;
};

/** A filter to be used against `StereoExtrinsicsT` object types. All fields are combined with a logical ‘and.’ */
export type StereoExtrinsicsTFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `data` field. */
  data?: Maybe<StringFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<StereoExtrinsicsTFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<StereoExtrinsicsTFilter>>;
  /** Negates the expression. */
  not?: Maybe<StereoExtrinsicsTFilter>;
};

/** A connection to a list of `StereoExtrinsicsT` values. */
export type StereoExtrinsicsTsConnection = {
  __typename?: 'StereoExtrinsicsTsConnection';
  /** A list of `StereoExtrinsicsT` objects. */
  nodes: Array<Maybe<StereoExtrinsicsT>>;
  /** A list of edges which contains the `StereoExtrinsicsT` and cursor to aid in pagination. */
  edges: Array<StereoExtrinsicsTsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `StereoExtrinsicsT` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `StereoExtrinsicsT` edge in the connection. */
export type StereoExtrinsicsTsEdge = {
  __typename?: 'StereoExtrinsicsTsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `StereoExtrinsicsT` at the end of the edge. */
  node?: Maybe<StereoExtrinsicsT>;
};

/** Methods to use when ordering `StereoExtrinsicsT`. */
export enum StereoExtrinsicsTsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  DataAsc = 'DATA_ASC',
  DataDesc = 'DATA_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/** A filter to be used against String fields. All fields are combined with a logical ‘and.’ */
export type StringFilter = {
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: Maybe<Scalars['Boolean']>;
  /** Equal to the specified value. */
  equalTo?: Maybe<Scalars['String']>;
  /** Not equal to the specified value. */
  notEqualTo?: Maybe<Scalars['String']>;
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: Maybe<Scalars['String']>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: Maybe<Scalars['String']>;
  /** Included in the specified list. */
  in?: Maybe<Array<Scalars['String']>>;
  /** Not included in the specified list. */
  notIn?: Maybe<Array<Scalars['String']>>;
  /** Less than the specified value. */
  lessThan?: Maybe<Scalars['String']>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: Maybe<Scalars['String']>;
  /** Greater than the specified value. */
  greaterThan?: Maybe<Scalars['String']>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: Maybe<Scalars['String']>;
  /** Contains the specified string (case-sensitive). */
  includes?: Maybe<Scalars['String']>;
  /** Does not contain the specified string (case-sensitive). */
  notIncludes?: Maybe<Scalars['String']>;
  /** Contains the specified string (case-insensitive). */
  includesInsensitive?: Maybe<Scalars['String']>;
  /** Does not contain the specified string (case-insensitive). */
  notIncludesInsensitive?: Maybe<Scalars['String']>;
  /** Starts with the specified string (case-sensitive). */
  startsWith?: Maybe<Scalars['String']>;
  /** Does not start with the specified string (case-sensitive). */
  notStartsWith?: Maybe<Scalars['String']>;
  /** Starts with the specified string (case-insensitive). */
  startsWithInsensitive?: Maybe<Scalars['String']>;
  /** Does not start with the specified string (case-insensitive). */
  notStartsWithInsensitive?: Maybe<Scalars['String']>;
  /** Ends with the specified string (case-sensitive). */
  endsWith?: Maybe<Scalars['String']>;
  /** Does not end with the specified string (case-sensitive). */
  notEndsWith?: Maybe<Scalars['String']>;
  /** Ends with the specified string (case-insensitive). */
  endsWithInsensitive?: Maybe<Scalars['String']>;
  /** Does not end with the specified string (case-insensitive). */
  notEndsWithInsensitive?: Maybe<Scalars['String']>;
  /** Matches the specified pattern (case-sensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters. */
  like?: Maybe<Scalars['String']>;
  /** Does not match the specified pattern (case-sensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters. */
  notLike?: Maybe<Scalars['String']>;
  /** Matches the specified pattern (case-insensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters. */
  likeInsensitive?: Maybe<Scalars['String']>;
  /** Does not match the specified pattern (case-insensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters. */
  notLikeInsensitive?: Maybe<Scalars['String']>;
  /** Equal to the specified value (case-insensitive). */
  equalToInsensitive?: Maybe<Scalars['String']>;
  /** Not equal to the specified value (case-insensitive). */
  notEqualToInsensitive?: Maybe<Scalars['String']>;
  /** Not equal to the specified value, treating null like an ordinary value (case-insensitive). */
  distinctFromInsensitive?: Maybe<Scalars['String']>;
  /** Equal to the specified value, treating null like an ordinary value (case-insensitive). */
  notDistinctFromInsensitive?: Maybe<Scalars['String']>;
  /** Included in the specified list (case-insensitive). */
  inInsensitive?: Maybe<Array<Scalars['String']>>;
  /** Not included in the specified list (case-insensitive). */
  notInInsensitive?: Maybe<Array<Scalars['String']>>;
  /** Less than the specified value (case-insensitive). */
  lessThanInsensitive?: Maybe<Scalars['String']>;
  /** Less than or equal to the specified value (case-insensitive). */
  lessThanOrEqualToInsensitive?: Maybe<Scalars['String']>;
  /** Greater than the specified value (case-insensitive). */
  greaterThanInsensitive?: Maybe<Scalars['String']>;
  /** Greater than or equal to the specified value (case-insensitive). */
  greaterThanOrEqualToInsensitive?: Maybe<Scalars['String']>;
};

/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type Subscription = {
  __typename?: 'Subscription';
  /**
   * Exposes the root query type nested one level down. This is helpful for Relay 1
   * which can only query top level fields if they are in a particular form. (live)
   */
  query: Query;
  /** The root query type must be a `Node` to work well with Relay 1 mutations. This just resolves to `query`. (live) */
  nodeId: Scalars['ID'];
  /** Fetches an object given its globally unique `ID`. (live) */
  node?: Maybe<Node>;
  /** Reads and enables pagination through a set of `VehicleTopic`. (live) */
  vehicleTopics?: Maybe<VehicleTopicsConnection>;
  /** Reads and enables pagination through a set of `VehicleType`. (live) */
  vehicleTypes?: Maybe<VehicleTypesConnection>;
  /** Reads and enables pagination through a set of `Vehicle`. (live) */
  vehicles?: Maybe<VehiclesConnection>;
  /** Reads and enables pagination through a set of `VehiclesOffline`. (live) */
  vehiclesOfflines?: Maybe<VehiclesOfflinesConnection>;
  /** Reads and enables pagination through a set of `VehiclesOnline`. (live) */
  vehiclesOnlines?: Maybe<VehiclesOnlinesConnection>;
  /** Reads and enables pagination through a set of `TopicCategory`. (live) */
  topicCategories?: Maybe<TopicCategoriesConnection>;
  /** Reads and enables pagination through a set of `TopicType`. (live) */
  topicTypes?: Maybe<TopicTypesConnection>;
  /** Reads and enables pagination through a set of `Topic`. (live) */
  topics?: Maybe<TopicsConnection>;
  /** Reads and enables pagination through a set of `Test`. (live) */
  tests?: Maybe<TestsConnection>;
  /** Reads and enables pagination through a set of `VehicleLogMessageStamp`. (live) */
  vehicleLogMessageStamps?: Maybe<VehicleLogMessageStampsConnection>;
  /** Reads and enables pagination through a set of `VehicleLogMessage`. (live) */
  vehicleLogMessages?: Maybe<VehicleLogMessagesConnection>;
  /** Reads and enables pagination through a set of `VehicleLogNodeType`. (live) */
  vehicleLogNodeTypes?: Maybe<VehicleLogNodeTypesConnection>;
  /** Reads and enables pagination through a set of `VehicleLog`. (live) */
  vehicleLogs?: Maybe<VehicleLogsConnection>;
  /** Reads and enables pagination through a set of `Starfire`. (live) */
  starfires?: Maybe<StarfiresConnection>;
  /** Reads and enables pagination through a set of `StarfireHeader`. (live) */
  starfireHeaders?: Maybe<StarfireHeadersConnection>;
  /** Reads and enables pagination through a set of `StarfireMessage`. (live) */
  starfireMessages?: Maybe<StarfireMessagesConnection>;
  /** Reads and enables pagination through a set of `Camera`. (live) */
  cameras?: Maybe<CamerasConnection>;
  /** Reads and enables pagination through a set of `CameraHistogram`. (live) */
  cameraHistograms?: Maybe<CameraHistogramsConnection>;
  /** Reads and enables pagination through a set of `CameraMessage`. (live) */
  cameraMessages?: Maybe<CameraMessagesConnection>;
  /** Reads and enables pagination through a set of `CameraMessageHeader`. (live) */
  cameraMessageHeaders?: Maybe<CameraMessageHeadersConnection>;
  /** Reads and enables pagination through a set of `CameraMeta`. (live) */
  cameraMetas?: Maybe<CameraMetasConnection>;
  /** Reads and enables pagination through a set of `CameraMetaE`. (live) */
  cameraMetaEs?: Maybe<CameraMetaEsConnection>;
  /** Reads and enables pagination through a set of `CameraMetaF`. (live) */
  cameraMetaFs?: Maybe<CameraMetaFsConnection>;
  /** Reads and enables pagination through a set of `CameraMetaP1`. (live) */
  cameraMetaP1s?: Maybe<CameraMetaP1sConnection>;
  /** Reads and enables pagination through a set of `CameraMetaP2`. (live) */
  cameraMetaP2s?: Maybe<CameraMetaP2sConnection>;
  /** Reads and enables pagination through a set of `CameraMetaQ`. (live) */
  cameraMetaQs?: Maybe<CameraMetaQsConnection>;
  /** Reads and enables pagination through a set of `CameraMetaR1`. (live) */
  cameraMetaR1s?: Maybe<CameraMetaR1sConnection>;
  /** Reads and enables pagination through a set of `CameraMetaR2`. (live) */
  cameraMetaR2s?: Maybe<CameraMetaR2sConnection>;
  /** Reads and enables pagination through a set of `CameraPair`. (live) */
  cameraPairs?: Maybe<CameraPairsConnection>;
  /** Reads and enables pagination through a set of `CameraPairMessage`. (live) */
  cameraPairMessages?: Maybe<CameraPairMessagesConnection>;
  /** Reads and enables pagination through a set of `CameraRoi`. (live) */
  cameraRois?: Maybe<CameraRoisConnection>;
  /** Reads and enables pagination through a set of `FullHistogram`. (live) */
  fullHistograms?: Maybe<FullHistogramsConnection>;
  /** Reads and enables pagination through a set of `ImageDatum`. (live) */
  imageData?: Maybe<ImageDataConnection>;
  /** Reads and enables pagination through a set of `ImageHeader`. (live) */
  imageHeaders?: Maybe<ImageHeadersConnection>;
  /** Reads and enables pagination through a set of `ImageHeaderStamp`. (live) */
  imageHeaderStamps?: Maybe<ImageHeaderStampsConnection>;
  /** Reads and enables pagination through a set of `Image`. (live) */
  images?: Maybe<ImagesConnection>;
  /** Reads and enables pagination through a set of `SegmentationMap`. (live) */
  segmentationMaps?: Maybe<SegmentationMapsConnection>;
  /** Reads and enables pagination through a set of `SideIntrinsic`. (live) */
  sideIntrinsics?: Maybe<SideIntrinsicsConnection>;
  /** Reads and enables pagination through a set of `SideIntrinsicsD`. (live) */
  sideIntrinsicsDs?: Maybe<SideIntrinsicsDsConnection>;
  /** Reads and enables pagination through a set of `SideIntrinsicsK`. (live) */
  sideIntrinsicsKs?: Maybe<SideIntrinsicsKsConnection>;
  /** Reads and enables pagination through a set of `SmallHistogram`. (live) */
  smallHistograms?: Maybe<SmallHistogramsConnection>;
  /** Reads and enables pagination through a set of `StereoExtrinsic`. (live) */
  stereoExtrinsics?: Maybe<StereoExtrinsicsConnection>;
  /** Reads and enables pagination through a set of `StereoExtrinsicsR`. (live) */
  stereoExtrinsicsRs?: Maybe<StereoExtrinsicsRsConnection>;
  /** Reads and enables pagination through a set of `StereoExtrinsicsRRodrigue`. (live) */
  stereoExtrinsicsRRodrigues?: Maybe<StereoExtrinsicsRRodriguesConnection>;
  /** Reads and enables pagination through a set of `StereoExtrinsicsT`. (live) */
  stereoExtrinsicsTs?: Maybe<StereoExtrinsicsTsConnection>;
  /** Reads and enables pagination through a set of `TractorExtrinsic`. (live) */
  tractorExtrinsics?: Maybe<TractorExtrinsicsConnection>;
  /** Reads and enables pagination through a set of `TractorExtrinsicsR`. (live) */
  tractorExtrinsicsRs?: Maybe<TractorExtrinsicsRsConnection>;
  /** Reads and enables pagination through a set of `TractorExtrinsicsRRodrigue`. (live) */
  tractorExtrinsicsRRodrigues?: Maybe<TractorExtrinsicsRRodriguesConnection>;
  /** Reads and enables pagination through a set of `TractorExtrinsicsT`. (live) */
  tractorExtrinsicsTs?: Maybe<TractorExtrinsicsTsConnection>;
  /** Reads and enables pagination through a set of `AlertType`. (live) */
  alertTypes?: Maybe<AlertTypesConnection>;
  /** Reads and enables pagination through a set of `Alert`. (live) */
  alerts?: Maybe<AlertsConnection>;
  /** Reads and enables pagination through a set of `StatusMessage`. (live) */
  statusMessages?: Maybe<StatusMessagesConnection>;
  /** Reads and enables pagination through a set of `StatusMessageHeader`. (live) */
  statusMessageHeaders?: Maybe<StatusMessageHeadersConnection>;
  /** Reads and enables pagination through a set of `StatusMessageMissionStat`. (live) */
  statusMessageMissionStats?: Maybe<StatusMessageMissionStatsConnection>;
  /** Reads and enables pagination through a set of `VehicleStateReason`. (live) */
  vehicleStateReasons?: Maybe<VehicleStateReasonsConnection>;
  /** Reads and enables pagination through a set of `VehicleState`. (live) */
  vehicleStates?: Maybe<VehicleStatesConnection>;
  /** Reads and enables pagination through a set of `VehicleStatus`. (live) */
  vehicleStatuses?: Maybe<VehicleStatusesConnection>;
  /** Reads and enables pagination through a set of `VehicleStatusDetail`. (live) */
  vehicleStatusDetails?: Maybe<VehicleStatusDetailsConnection>;
  /** Reads and enables pagination through a set of `ObjectDetectionImage`. (live) */
  objectDetectionImages?: Maybe<ObjectDetectionImagesConnection>;
  /** Reads and enables pagination through a set of `ObjectMessage`. (live) */
  objectMessages?: Maybe<ObjectMessagesConnection>;
  /** Reads and enables pagination through a set of `ObjectMessageCentroidLocation`. (live) */
  objectMessageCentroidLocations?: Maybe<ObjectMessageCentroidLocationsConnection>;
  /** Reads and enables pagination through a set of `ObjectMessageCentroidRpy`. (live) */
  objectMessageCentroidRpies?: Maybe<ObjectMessageCentroidRpiesConnection>;
  /** Reads and enables pagination through a set of `ObjectMessageCircleCenter`. (live) */
  objectMessageCircleCenters?: Maybe<ObjectMessageCircleCentersConnection>;
  /** Reads and enables pagination through a set of `ObjectMessageDetection`. (live) */
  objectMessageDetections?: Maybe<ObjectMessageDetectionsConnection>;
  /** Reads and enables pagination through a set of `ObjectMessageDetectionCuboid`. (live) */
  objectMessageDetectionCuboids?: Maybe<ObjectMessageDetectionCuboidsConnection>;
  /** Reads and enables pagination through a set of `ObjectMessageDetectionCuboidCentroid`. (live) */
  objectMessageDetectionCuboidCentroids?: Maybe<ObjectMessageDetectionCuboidCentroidsConnection>;
  /** Reads and enables pagination through a set of `ObjectMessageDetectionCuboidDimension`. (live) */
  objectMessageDetectionCuboidDimensions?: Maybe<ObjectMessageDetectionCuboidDimensionsConnection>;
  /** Reads and enables pagination through a set of `ObjectMessageDetectionCuboidOrientation`. (live) */
  objectMessageDetectionCuboidOrientations?: Maybe<ObjectMessageDetectionCuboidOrientationsConnection>;
  /** Reads and enables pagination through a set of `ObjectMessageDetectionHeader`. (live) */
  objectMessageDetectionHeaders?: Maybe<ObjectMessageDetectionHeadersConnection>;
  /** Reads and enables pagination through a set of `ObjectMessageDetectionRoi`. (live) */
  objectMessageDetectionRois?: Maybe<ObjectMessageDetectionRoisConnection>;
  /** Reads and enables pagination through a set of `ObjectMessageEcef`. (live) */
  objectMessageEcefs?: Maybe<ObjectMessageEcefsConnection>;
  /** Reads and enables pagination through a set of `ObjectMessageEnu`. (live) */
  objectMessageEnus?: Maybe<ObjectMessageEnusConnection>;
  /** Reads and enables pagination through a set of `ObjectMessageFieldOrigin`. (live) */
  objectMessageFieldOrigins?: Maybe<ObjectMessageFieldOriginsConnection>;
  /** Reads and enables pagination through a set of `ObjectMessageHeader`. (live) */
  objectMessageHeaders?: Maybe<ObjectMessageHeadersConnection>;
  /** Reads and enables pagination through a set of `ObjectMessageLla`. (live) */
  objectMessageLlas?: Maybe<ObjectMessageLlasConnection>;
  /** Reads and enables pagination through a set of `ObjectMessageVertex`. (live) */
  objectMessageVertices?: Maybe<ObjectMessageVerticesConnection>;
  /** Reads and enables pagination through a set of `ObjectMessageXyzCamera`. (live) */
  objectMessageXyzCameras?: Maybe<ObjectMessageXyzCamerasConnection>;
  /** Reads and enables pagination through a set of `ObjectMessageXyzStarfire`. (live) */
  objectMessageXyzStarfires?: Maybe<ObjectMessageXyzStarfiresConnection>;
  /** Reads and enables pagination through a set of `Object`. (live) */
  objects?: Maybe<ObjectsConnection>;
  /**  (live) */
  vehicleTopic?: Maybe<VehicleTopic>;
  /**  (live) */
  vehicleType?: Maybe<VehicleType>;
  /**  (live) */
  vehicleTypeByType?: Maybe<VehicleType>;
  /**  (live) */
  vehicle?: Maybe<Vehicle>;
  /**  (live) */
  vehicleByDeviceId?: Maybe<Vehicle>;
  /**  (live) */
  vehiclesOnline?: Maybe<VehiclesOnline>;
  /**  (live) */
  vehiclesOnlineByVehicleId?: Maybe<VehiclesOnline>;
  /**  (live) */
  topicCategory?: Maybe<TopicCategory>;
  /**  (live) */
  topicType?: Maybe<TopicType>;
  /**  (live) */
  topicTypeByModule?: Maybe<TopicType>;
  /**  (live) */
  topic?: Maybe<Topic>;
  /**  (live) */
  topicByName?: Maybe<Topic>;
  /**  (live) */
  test?: Maybe<Test>;
  /**  (live) */
  vehicleLogMessageStamp?: Maybe<VehicleLogMessageStamp>;
  /**  (live) */
  vehicleLogMessage?: Maybe<VehicleLogMessage>;
  /**  (live) */
  vehicleLog?: Maybe<VehicleLog>;
  /**  (live) */
  starfire?: Maybe<Starfire>;
  /**  (live) */
  starfireHeader?: Maybe<StarfireHeader>;
  /**  (live) */
  starfireMessage?: Maybe<StarfireMessage>;
  /**  (live) */
  camera?: Maybe<Camera>;
  /**  (live) */
  cameraHistogram?: Maybe<CameraHistogram>;
  /**  (live) */
  cameraMessage?: Maybe<CameraMessage>;
  /**  (live) */
  cameraMessageHeader?: Maybe<CameraMessageHeader>;
  /**  (live) */
  cameraMeta?: Maybe<CameraMeta>;
  /**  (live) */
  cameraMetaE?: Maybe<CameraMetaE>;
  /**  (live) */
  cameraMetaF?: Maybe<CameraMetaF>;
  /**  (live) */
  cameraMetaP1?: Maybe<CameraMetaP1>;
  /**  (live) */
  cameraMetaP2?: Maybe<CameraMetaP2>;
  /**  (live) */
  cameraMetaQ?: Maybe<CameraMetaQ>;
  /**  (live) */
  cameraMetaR1?: Maybe<CameraMetaR1>;
  /**  (live) */
  cameraMetaR2?: Maybe<CameraMetaR2>;
  /**  (live) */
  cameraPair?: Maybe<CameraPair>;
  /**  (live) */
  cameraPairMessage?: Maybe<CameraPairMessage>;
  /**  (live) */
  cameraRoi?: Maybe<CameraRoi>;
  /**  (live) */
  fullHistogram?: Maybe<FullHistogram>;
  /**  (live) */
  imageDatum?: Maybe<ImageDatum>;
  /**  (live) */
  imageHeader?: Maybe<ImageHeader>;
  /**  (live) */
  imageHeaderStamp?: Maybe<ImageHeaderStamp>;
  /**  (live) */
  image?: Maybe<Image>;
  /**  (live) */
  segmentationMap?: Maybe<SegmentationMap>;
  /**  (live) */
  sideIntrinsic?: Maybe<SideIntrinsic>;
  /**  (live) */
  sideIntrinsicsD?: Maybe<SideIntrinsicsD>;
  /**  (live) */
  sideIntrinsicsK?: Maybe<SideIntrinsicsK>;
  /**  (live) */
  smallHistogram?: Maybe<SmallHistogram>;
  /**  (live) */
  stereoExtrinsic?: Maybe<StereoExtrinsic>;
  /**  (live) */
  stereoExtrinsicsR?: Maybe<StereoExtrinsicsR>;
  /**  (live) */
  stereoExtrinsicsRRodrigue?: Maybe<StereoExtrinsicsRRodrigue>;
  /**  (live) */
  stereoExtrinsicsT?: Maybe<StereoExtrinsicsT>;
  /**  (live) */
  tractorExtrinsic?: Maybe<TractorExtrinsic>;
  /**  (live) */
  tractorExtrinsicsR?: Maybe<TractorExtrinsicsR>;
  /**  (live) */
  tractorExtrinsicsRRodrigue?: Maybe<TractorExtrinsicsRRodrigue>;
  /**  (live) */
  tractorExtrinsicsT?: Maybe<TractorExtrinsicsT>;
  /**  (live) */
  alertType?: Maybe<AlertType>;
  /**  (live) */
  alert?: Maybe<Alert>;
  /**  (live) */
  statusMessage?: Maybe<StatusMessage>;
  /**  (live) */
  statusMessageHeader?: Maybe<StatusMessageHeader>;
  /**  (live) */
  statusMessageMissionStat?: Maybe<StatusMessageMissionStat>;
  /**  (live) */
  vehicleStateReason?: Maybe<VehicleStateReason>;
  /**  (live) */
  vehicleState?: Maybe<VehicleState>;
  /**  (live) */
  vehicleStateByName?: Maybe<VehicleState>;
  /**  (live) */
  vehicleStateByCode?: Maybe<VehicleState>;
  /**  (live) */
  vehicleStatus?: Maybe<VehicleStatus>;
  /**  (live) */
  vehicleStatusDetail?: Maybe<VehicleStatusDetail>;
  /**  (live) */
  objectMessage?: Maybe<ObjectMessage>;
  /**  (live) */
  objectMessageCentroidLocation?: Maybe<ObjectMessageCentroidLocation>;
  /**  (live) */
  objectMessageCentroidRpy?: Maybe<ObjectMessageCentroidRpy>;
  /**  (live) */
  objectMessageCircleCenter?: Maybe<ObjectMessageCircleCenter>;
  /**  (live) */
  objectMessageDetection?: Maybe<ObjectMessageDetection>;
  /**  (live) */
  objectMessageDetectionCuboid?: Maybe<ObjectMessageDetectionCuboid>;
  /**  (live) */
  objectMessageDetectionCuboidCentroid?: Maybe<ObjectMessageDetectionCuboidCentroid>;
  /**  (live) */
  objectMessageDetectionCuboidDimension?: Maybe<ObjectMessageDetectionCuboidDimension>;
  /**  (live) */
  objectMessageDetectionCuboidOrientation?: Maybe<ObjectMessageDetectionCuboidOrientation>;
  /**  (live) */
  objectMessageDetectionHeader?: Maybe<ObjectMessageDetectionHeader>;
  /**  (live) */
  objectMessageDetectionRoi?: Maybe<ObjectMessageDetectionRoi>;
  /**  (live) */
  objectMessageEcef?: Maybe<ObjectMessageEcef>;
  /**  (live) */
  objectMessageEnu?: Maybe<ObjectMessageEnu>;
  /**  (live) */
  objectMessageFieldOrigin?: Maybe<ObjectMessageFieldOrigin>;
  /**  (live) */
  objectMessageHeader?: Maybe<ObjectMessageHeader>;
  /**  (live) */
  objectMessageLla?: Maybe<ObjectMessageLla>;
  /**  (live) */
  objectMessageVertex?: Maybe<ObjectMessageVertex>;
  /**  (live) */
  objectMessageXyzCamera?: Maybe<ObjectMessageXyzCamera>;
  /**  (live) */
  objectMessageXyzStarfire?: Maybe<ObjectMessageXyzStarfire>;
  /**  (live) */
  object?: Maybe<Object>;
  /** Reads a single `VehicleTopic` using its globally unique `ID`. (live) */
  vehicleTopicByNodeId?: Maybe<VehicleTopic>;
  /** Reads a single `VehicleType` using its globally unique `ID`. (live) */
  vehicleTypeByNodeId?: Maybe<VehicleType>;
  /** Reads a single `Vehicle` using its globally unique `ID`. (live) */
  vehicleByNodeId?: Maybe<Vehicle>;
  /** Reads a single `VehiclesOnline` using its globally unique `ID`. (live) */
  vehiclesOnlineByNodeId?: Maybe<VehiclesOnline>;
  /** Reads a single `TopicCategory` using its globally unique `ID`. (live) */
  topicCategoryByNodeId?: Maybe<TopicCategory>;
  /** Reads a single `TopicType` using its globally unique `ID`. (live) */
  topicTypeByNodeId?: Maybe<TopicType>;
  /** Reads a single `Topic` using its globally unique `ID`. (live) */
  topicByNodeId?: Maybe<Topic>;
  /** Reads a single `Test` using its globally unique `ID`. (live) */
  testByNodeId?: Maybe<Test>;
  /** Reads a single `VehicleLogMessageStamp` using its globally unique `ID`. (live) */
  vehicleLogMessageStampByNodeId?: Maybe<VehicleLogMessageStamp>;
  /** Reads a single `VehicleLogMessage` using its globally unique `ID`. (live) */
  vehicleLogMessageByNodeId?: Maybe<VehicleLogMessage>;
  /** Reads a single `VehicleLog` using its globally unique `ID`. (live) */
  vehicleLogByNodeId?: Maybe<VehicleLog>;
  /** Reads a single `Starfire` using its globally unique `ID`. (live) */
  starfireByNodeId?: Maybe<Starfire>;
  /** Reads a single `StarfireHeader` using its globally unique `ID`. (live) */
  starfireHeaderByNodeId?: Maybe<StarfireHeader>;
  /** Reads a single `StarfireMessage` using its globally unique `ID`. (live) */
  starfireMessageByNodeId?: Maybe<StarfireMessage>;
  /** Reads a single `Camera` using its globally unique `ID`. (live) */
  cameraByNodeId?: Maybe<Camera>;
  /** Reads a single `CameraHistogram` using its globally unique `ID`. (live) */
  cameraHistogramByNodeId?: Maybe<CameraHistogram>;
  /** Reads a single `CameraMessage` using its globally unique `ID`. (live) */
  cameraMessageByNodeId?: Maybe<CameraMessage>;
  /** Reads a single `CameraMessageHeader` using its globally unique `ID`. (live) */
  cameraMessageHeaderByNodeId?: Maybe<CameraMessageHeader>;
  /** Reads a single `CameraMeta` using its globally unique `ID`. (live) */
  cameraMetaByNodeId?: Maybe<CameraMeta>;
  /** Reads a single `CameraMetaE` using its globally unique `ID`. (live) */
  cameraMetaEByNodeId?: Maybe<CameraMetaE>;
  /** Reads a single `CameraMetaF` using its globally unique `ID`. (live) */
  cameraMetaFByNodeId?: Maybe<CameraMetaF>;
  /** Reads a single `CameraMetaP1` using its globally unique `ID`. (live) */
  cameraMetaP1ByNodeId?: Maybe<CameraMetaP1>;
  /** Reads a single `CameraMetaP2` using its globally unique `ID`. (live) */
  cameraMetaP2ByNodeId?: Maybe<CameraMetaP2>;
  /** Reads a single `CameraMetaQ` using its globally unique `ID`. (live) */
  cameraMetaQByNodeId?: Maybe<CameraMetaQ>;
  /** Reads a single `CameraMetaR1` using its globally unique `ID`. (live) */
  cameraMetaR1ByNodeId?: Maybe<CameraMetaR1>;
  /** Reads a single `CameraMetaR2` using its globally unique `ID`. (live) */
  cameraMetaR2ByNodeId?: Maybe<CameraMetaR2>;
  /** Reads a single `CameraPair` using its globally unique `ID`. (live) */
  cameraPairByNodeId?: Maybe<CameraPair>;
  /** Reads a single `CameraPairMessage` using its globally unique `ID`. (live) */
  cameraPairMessageByNodeId?: Maybe<CameraPairMessage>;
  /** Reads a single `CameraRoi` using its globally unique `ID`. (live) */
  cameraRoiByNodeId?: Maybe<CameraRoi>;
  /** Reads a single `FullHistogram` using its globally unique `ID`. (live) */
  fullHistogramByNodeId?: Maybe<FullHistogram>;
  /** Reads a single `ImageDatum` using its globally unique `ID`. (live) */
  imageDatumByNodeId?: Maybe<ImageDatum>;
  /** Reads a single `ImageHeader` using its globally unique `ID`. (live) */
  imageHeaderByNodeId?: Maybe<ImageHeader>;
  /** Reads a single `ImageHeaderStamp` using its globally unique `ID`. (live) */
  imageHeaderStampByNodeId?: Maybe<ImageHeaderStamp>;
  /** Reads a single `Image` using its globally unique `ID`. (live) */
  imageByNodeId?: Maybe<Image>;
  /** Reads a single `SegmentationMap` using its globally unique `ID`. (live) */
  segmentationMapByNodeId?: Maybe<SegmentationMap>;
  /** Reads a single `SideIntrinsic` using its globally unique `ID`. (live) */
  sideIntrinsicByNodeId?: Maybe<SideIntrinsic>;
  /** Reads a single `SideIntrinsicsD` using its globally unique `ID`. (live) */
  sideIntrinsicsDByNodeId?: Maybe<SideIntrinsicsD>;
  /** Reads a single `SideIntrinsicsK` using its globally unique `ID`. (live) */
  sideIntrinsicsKByNodeId?: Maybe<SideIntrinsicsK>;
  /** Reads a single `SmallHistogram` using its globally unique `ID`. (live) */
  smallHistogramByNodeId?: Maybe<SmallHistogram>;
  /** Reads a single `StereoExtrinsic` using its globally unique `ID`. (live) */
  stereoExtrinsicByNodeId?: Maybe<StereoExtrinsic>;
  /** Reads a single `StereoExtrinsicsR` using its globally unique `ID`. (live) */
  stereoExtrinsicsRByNodeId?: Maybe<StereoExtrinsicsR>;
  /** Reads a single `StereoExtrinsicsRRodrigue` using its globally unique `ID`. (live) */
  stereoExtrinsicsRRodrigueByNodeId?: Maybe<StereoExtrinsicsRRodrigue>;
  /** Reads a single `StereoExtrinsicsT` using its globally unique `ID`. (live) */
  stereoExtrinsicsTByNodeId?: Maybe<StereoExtrinsicsT>;
  /** Reads a single `TractorExtrinsic` using its globally unique `ID`. (live) */
  tractorExtrinsicByNodeId?: Maybe<TractorExtrinsic>;
  /** Reads a single `TractorExtrinsicsR` using its globally unique `ID`. (live) */
  tractorExtrinsicsRByNodeId?: Maybe<TractorExtrinsicsR>;
  /** Reads a single `TractorExtrinsicsRRodrigue` using its globally unique `ID`. (live) */
  tractorExtrinsicsRRodrigueByNodeId?: Maybe<TractorExtrinsicsRRodrigue>;
  /** Reads a single `TractorExtrinsicsT` using its globally unique `ID`. (live) */
  tractorExtrinsicsTByNodeId?: Maybe<TractorExtrinsicsT>;
  /** Reads a single `AlertType` using its globally unique `ID`. (live) */
  alertTypeByNodeId?: Maybe<AlertType>;
  /** Reads a single `Alert` using its globally unique `ID`. (live) */
  alertByNodeId?: Maybe<Alert>;
  /** Reads a single `StatusMessage` using its globally unique `ID`. (live) */
  statusMessageByNodeId?: Maybe<StatusMessage>;
  /** Reads a single `StatusMessageHeader` using its globally unique `ID`. (live) */
  statusMessageHeaderByNodeId?: Maybe<StatusMessageHeader>;
  /** Reads a single `StatusMessageMissionStat` using its globally unique `ID`. (live) */
  statusMessageMissionStatByNodeId?: Maybe<StatusMessageMissionStat>;
  /** Reads a single `VehicleStateReason` using its globally unique `ID`. (live) */
  vehicleStateReasonByNodeId?: Maybe<VehicleStateReason>;
  /** Reads a single `VehicleState` using its globally unique `ID`. (live) */
  vehicleStateByNodeId?: Maybe<VehicleState>;
  /** Reads a single `VehicleStatus` using its globally unique `ID`. (live) */
  vehicleStatusByNodeId?: Maybe<VehicleStatus>;
  /** Reads a single `VehicleStatusDetail` using its globally unique `ID`. (live) */
  vehicleStatusDetailByNodeId?: Maybe<VehicleStatusDetail>;
  /** Reads a single `ObjectMessage` using its globally unique `ID`. (live) */
  objectMessageByNodeId?: Maybe<ObjectMessage>;
  /** Reads a single `ObjectMessageCentroidLocation` using its globally unique `ID`. (live) */
  objectMessageCentroidLocationByNodeId?: Maybe<ObjectMessageCentroidLocation>;
  /** Reads a single `ObjectMessageCentroidRpy` using its globally unique `ID`. (live) */
  objectMessageCentroidRpyByNodeId?: Maybe<ObjectMessageCentroidRpy>;
  /** Reads a single `ObjectMessageCircleCenter` using its globally unique `ID`. (live) */
  objectMessageCircleCenterByNodeId?: Maybe<ObjectMessageCircleCenter>;
  /** Reads a single `ObjectMessageDetection` using its globally unique `ID`. (live) */
  objectMessageDetectionByNodeId?: Maybe<ObjectMessageDetection>;
  /** Reads a single `ObjectMessageDetectionCuboid` using its globally unique `ID`. (live) */
  objectMessageDetectionCuboidByNodeId?: Maybe<ObjectMessageDetectionCuboid>;
  /** Reads a single `ObjectMessageDetectionCuboidCentroid` using its globally unique `ID`. (live) */
  objectMessageDetectionCuboidCentroidByNodeId?: Maybe<ObjectMessageDetectionCuboidCentroid>;
  /** Reads a single `ObjectMessageDetectionCuboidDimension` using its globally unique `ID`. (live) */
  objectMessageDetectionCuboidDimensionByNodeId?: Maybe<ObjectMessageDetectionCuboidDimension>;
  /** Reads a single `ObjectMessageDetectionCuboidOrientation` using its globally unique `ID`. (live) */
  objectMessageDetectionCuboidOrientationByNodeId?: Maybe<ObjectMessageDetectionCuboidOrientation>;
  /** Reads a single `ObjectMessageDetectionHeader` using its globally unique `ID`. (live) */
  objectMessageDetectionHeaderByNodeId?: Maybe<ObjectMessageDetectionHeader>;
  /** Reads a single `ObjectMessageDetectionRoi` using its globally unique `ID`. (live) */
  objectMessageDetectionRoiByNodeId?: Maybe<ObjectMessageDetectionRoi>;
  /** Reads a single `ObjectMessageEcef` using its globally unique `ID`. (live) */
  objectMessageEcefByNodeId?: Maybe<ObjectMessageEcef>;
  /** Reads a single `ObjectMessageEnu` using its globally unique `ID`. (live) */
  objectMessageEnuByNodeId?: Maybe<ObjectMessageEnu>;
  /** Reads a single `ObjectMessageFieldOrigin` using its globally unique `ID`. (live) */
  objectMessageFieldOriginByNodeId?: Maybe<ObjectMessageFieldOrigin>;
  /** Reads a single `ObjectMessageHeader` using its globally unique `ID`. (live) */
  objectMessageHeaderByNodeId?: Maybe<ObjectMessageHeader>;
  /** Reads a single `ObjectMessageLla` using its globally unique `ID`. (live) */
  objectMessageLlaByNodeId?: Maybe<ObjectMessageLla>;
  /** Reads a single `ObjectMessageVertex` using its globally unique `ID`. (live) */
  objectMessageVertexByNodeId?: Maybe<ObjectMessageVertex>;
  /** Reads a single `ObjectMessageXyzCamera` using its globally unique `ID`. (live) */
  objectMessageXyzCameraByNodeId?: Maybe<ObjectMessageXyzCamera>;
  /** Reads a single `ObjectMessageXyzStarfire` using its globally unique `ID`. (live) */
  objectMessageXyzStarfireByNodeId?: Maybe<ObjectMessageXyzStarfire>;
  /** Reads a single `Object` using its globally unique `ID`. (live) */
  objectByNodeId?: Maybe<Object>;
  sqlStarfire?: Maybe<SqlStarfirePayload>;
  sqlVehicle?: Maybe<SqlVehiclePayload>;
  sqlVehicleStatus?: Maybe<SqlVehicleStatusPayload>;
  sqlAlerts?: Maybe<SqlAlertsPayload>;
  sqlVehiclesOnline?: Maybe<SqlVehiclesOnlinePayload>;
  sqlCamera?: Maybe<SqlCameraPayload>;
  sqlObjectDetection?: Maybe<SqlObjectDetectionPayload>;
  sqlVehicleLogging?: Maybe<SqlVehicleLoggingPayload>;
  listen: ListenPayload;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionNodeArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionVehicleTopicsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<VehicleTopicsOrderBy>>;
  condition?: Maybe<VehicleTopicCondition>;
  filter?: Maybe<VehicleTopicFilter>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionVehicleTypesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<VehicleTypesOrderBy>>;
  condition?: Maybe<VehicleTypeCondition>;
  filter?: Maybe<VehicleTypeFilter>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionVehiclesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<VehiclesOrderBy>>;
  condition?: Maybe<VehicleCondition>;
  filter?: Maybe<VehicleFilter>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionVehiclesOfflinesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<VehiclesOfflinesOrderBy>>;
  condition?: Maybe<VehiclesOfflineCondition>;
  filter?: Maybe<VehiclesOfflineFilter>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionVehiclesOnlinesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<VehiclesOnlinesOrderBy>>;
  condition?: Maybe<VehiclesOnlineCondition>;
  filter?: Maybe<VehiclesOnlineFilter>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionTopicCategoriesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<TopicCategoriesOrderBy>>;
  condition?: Maybe<TopicCategoryCondition>;
  filter?: Maybe<TopicCategoryFilter>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionTopicTypesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<TopicTypesOrderBy>>;
  condition?: Maybe<TopicTypeCondition>;
  filter?: Maybe<TopicTypeFilter>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionTopicsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<TopicsOrderBy>>;
  condition?: Maybe<TopicCondition>;
  filter?: Maybe<TopicFilter>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionTestsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<TestsOrderBy>>;
  condition?: Maybe<TestCondition>;
  filter?: Maybe<TestFilter>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionVehicleLogMessageStampsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<VehicleLogMessageStampsOrderBy>>;
  condition?: Maybe<VehicleLogMessageStampCondition>;
  filter?: Maybe<VehicleLogMessageStampFilter>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionVehicleLogMessagesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<VehicleLogMessagesOrderBy>>;
  condition?: Maybe<VehicleLogMessageCondition>;
  filter?: Maybe<VehicleLogMessageFilter>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionVehicleLogNodeTypesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<VehicleLogNodeTypesOrderBy>>;
  condition?: Maybe<VehicleLogNodeTypeCondition>;
  filter?: Maybe<VehicleLogNodeTypeFilter>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionVehicleLogsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<VehicleLogsOrderBy>>;
  condition?: Maybe<VehicleLogCondition>;
  filter?: Maybe<VehicleLogFilter>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionStarfiresArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<StarfiresOrderBy>>;
  condition?: Maybe<StarfireCondition>;
  filter?: Maybe<StarfireFilter>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionStarfireHeadersArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<StarfireHeadersOrderBy>>;
  condition?: Maybe<StarfireHeaderCondition>;
  filter?: Maybe<StarfireHeaderFilter>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionStarfireMessagesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<StarfireMessagesOrderBy>>;
  condition?: Maybe<StarfireMessageCondition>;
  filter?: Maybe<StarfireMessageFilter>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionCamerasArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CamerasOrderBy>>;
  condition?: Maybe<CameraCondition>;
  filter?: Maybe<CameraFilter>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionCameraHistogramsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CameraHistogramsOrderBy>>;
  condition?: Maybe<CameraHistogramCondition>;
  filter?: Maybe<CameraHistogramFilter>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionCameraMessagesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CameraMessagesOrderBy>>;
  condition?: Maybe<CameraMessageCondition>;
  filter?: Maybe<CameraMessageFilter>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionCameraMessageHeadersArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CameraMessageHeadersOrderBy>>;
  condition?: Maybe<CameraMessageHeaderCondition>;
  filter?: Maybe<CameraMessageHeaderFilter>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionCameraMetasArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CameraMetasOrderBy>>;
  condition?: Maybe<CameraMetaCondition>;
  filter?: Maybe<CameraMetaFilter>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionCameraMetaEsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CameraMetaEsOrderBy>>;
  condition?: Maybe<CameraMetaECondition>;
  filter?: Maybe<CameraMetaEFilter>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionCameraMetaFsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CameraMetaFsOrderBy>>;
  condition?: Maybe<CameraMetaFCondition>;
  filter?: Maybe<CameraMetaFFilter>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionCameraMetaP1sArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CameraMetaP1sOrderBy>>;
  condition?: Maybe<CameraMetaP1Condition>;
  filter?: Maybe<CameraMetaP1Filter>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionCameraMetaP2sArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CameraMetaP2sOrderBy>>;
  condition?: Maybe<CameraMetaP2Condition>;
  filter?: Maybe<CameraMetaP2Filter>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionCameraMetaQsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CameraMetaQsOrderBy>>;
  condition?: Maybe<CameraMetaQCondition>;
  filter?: Maybe<CameraMetaQFilter>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionCameraMetaR1sArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CameraMetaR1sOrderBy>>;
  condition?: Maybe<CameraMetaR1Condition>;
  filter?: Maybe<CameraMetaR1Filter>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionCameraMetaR2sArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CameraMetaR2sOrderBy>>;
  condition?: Maybe<CameraMetaR2Condition>;
  filter?: Maybe<CameraMetaR2Filter>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionCameraPairsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CameraPairsOrderBy>>;
  condition?: Maybe<CameraPairCondition>;
  filter?: Maybe<CameraPairFilter>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionCameraPairMessagesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CameraPairMessagesOrderBy>>;
  condition?: Maybe<CameraPairMessageCondition>;
  filter?: Maybe<CameraPairMessageFilter>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionCameraRoisArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CameraRoisOrderBy>>;
  condition?: Maybe<CameraRoiCondition>;
  filter?: Maybe<CameraRoiFilter>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionFullHistogramsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<FullHistogramsOrderBy>>;
  condition?: Maybe<FullHistogramCondition>;
  filter?: Maybe<FullHistogramFilter>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionImageDataArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ImageDataOrderBy>>;
  condition?: Maybe<ImageDatumCondition>;
  filter?: Maybe<ImageDatumFilter>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionImageHeadersArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ImageHeadersOrderBy>>;
  condition?: Maybe<ImageHeaderCondition>;
  filter?: Maybe<ImageHeaderFilter>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionImageHeaderStampsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ImageHeaderStampsOrderBy>>;
  condition?: Maybe<ImageHeaderStampCondition>;
  filter?: Maybe<ImageHeaderStampFilter>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionImagesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ImagesOrderBy>>;
  condition?: Maybe<ImageCondition>;
  filter?: Maybe<ImageFilter>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionSegmentationMapsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<SegmentationMapsOrderBy>>;
  condition?: Maybe<SegmentationMapCondition>;
  filter?: Maybe<SegmentationMapFilter>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionSideIntrinsicsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<SideIntrinsicsOrderBy>>;
  condition?: Maybe<SideIntrinsicCondition>;
  filter?: Maybe<SideIntrinsicFilter>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionSideIntrinsicsDsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<SideIntrinsicsDsOrderBy>>;
  condition?: Maybe<SideIntrinsicsDCondition>;
  filter?: Maybe<SideIntrinsicsDFilter>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionSideIntrinsicsKsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<SideIntrinsicsKsOrderBy>>;
  condition?: Maybe<SideIntrinsicsKCondition>;
  filter?: Maybe<SideIntrinsicsKFilter>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionSmallHistogramsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<SmallHistogramsOrderBy>>;
  condition?: Maybe<SmallHistogramCondition>;
  filter?: Maybe<SmallHistogramFilter>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionStereoExtrinsicsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<StereoExtrinsicsOrderBy>>;
  condition?: Maybe<StereoExtrinsicCondition>;
  filter?: Maybe<StereoExtrinsicFilter>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionStereoExtrinsicsRsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<StereoExtrinsicsRsOrderBy>>;
  condition?: Maybe<StereoExtrinsicsRCondition>;
  filter?: Maybe<StereoExtrinsicsRFilter>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionStereoExtrinsicsRRodriguesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<StereoExtrinsicsRRodriguesOrderBy>>;
  condition?: Maybe<StereoExtrinsicsRRodrigueCondition>;
  filter?: Maybe<StereoExtrinsicsRRodrigueFilter>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionStereoExtrinsicsTsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<StereoExtrinsicsTsOrderBy>>;
  condition?: Maybe<StereoExtrinsicsTCondition>;
  filter?: Maybe<StereoExtrinsicsTFilter>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionTractorExtrinsicsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<TractorExtrinsicsOrderBy>>;
  condition?: Maybe<TractorExtrinsicCondition>;
  filter?: Maybe<TractorExtrinsicFilter>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionTractorExtrinsicsRsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<TractorExtrinsicsRsOrderBy>>;
  condition?: Maybe<TractorExtrinsicsRCondition>;
  filter?: Maybe<TractorExtrinsicsRFilter>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionTractorExtrinsicsRRodriguesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<TractorExtrinsicsRRodriguesOrderBy>>;
  condition?: Maybe<TractorExtrinsicsRRodrigueCondition>;
  filter?: Maybe<TractorExtrinsicsRRodrigueFilter>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionTractorExtrinsicsTsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<TractorExtrinsicsTsOrderBy>>;
  condition?: Maybe<TractorExtrinsicsTCondition>;
  filter?: Maybe<TractorExtrinsicsTFilter>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionAlertTypesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<AlertTypesOrderBy>>;
  condition?: Maybe<AlertTypeCondition>;
  filter?: Maybe<AlertTypeFilter>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionAlertsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<AlertsOrderBy>>;
  condition?: Maybe<AlertCondition>;
  filter?: Maybe<AlertFilter>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionStatusMessagesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<StatusMessagesOrderBy>>;
  condition?: Maybe<StatusMessageCondition>;
  filter?: Maybe<StatusMessageFilter>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionStatusMessageHeadersArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<StatusMessageHeadersOrderBy>>;
  condition?: Maybe<StatusMessageHeaderCondition>;
  filter?: Maybe<StatusMessageHeaderFilter>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionStatusMessageMissionStatsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<StatusMessageMissionStatsOrderBy>>;
  condition?: Maybe<StatusMessageMissionStatCondition>;
  filter?: Maybe<StatusMessageMissionStatFilter>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionVehicleStateReasonsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<VehicleStateReasonsOrderBy>>;
  condition?: Maybe<VehicleStateReasonCondition>;
  filter?: Maybe<VehicleStateReasonFilter>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionVehicleStatesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<VehicleStatesOrderBy>>;
  condition?: Maybe<VehicleStateCondition>;
  filter?: Maybe<VehicleStateFilter>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionVehicleStatusesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<VehicleStatusesOrderBy>>;
  condition?: Maybe<VehicleStatusCondition>;
  filter?: Maybe<VehicleStatusFilter>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionVehicleStatusDetailsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<VehicleStatusDetailsOrderBy>>;
  condition?: Maybe<VehicleStatusDetailCondition>;
  filter?: Maybe<VehicleStatusDetailFilter>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionObjectDetectionImagesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ObjectDetectionImagesOrderBy>>;
  condition?: Maybe<ObjectDetectionImageCondition>;
  filter?: Maybe<ObjectDetectionImageFilter>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionObjectMessagesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ObjectMessagesOrderBy>>;
  condition?: Maybe<ObjectMessageCondition>;
  filter?: Maybe<ObjectMessageFilter>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionObjectMessageCentroidLocationsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ObjectMessageCentroidLocationsOrderBy>>;
  condition?: Maybe<ObjectMessageCentroidLocationCondition>;
  filter?: Maybe<ObjectMessageCentroidLocationFilter>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionObjectMessageCentroidRpiesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ObjectMessageCentroidRpiesOrderBy>>;
  condition?: Maybe<ObjectMessageCentroidRpyCondition>;
  filter?: Maybe<ObjectMessageCentroidRpyFilter>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionObjectMessageCircleCentersArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ObjectMessageCircleCentersOrderBy>>;
  condition?: Maybe<ObjectMessageCircleCenterCondition>;
  filter?: Maybe<ObjectMessageCircleCenterFilter>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionObjectMessageDetectionsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ObjectMessageDetectionsOrderBy>>;
  condition?: Maybe<ObjectMessageDetectionCondition>;
  filter?: Maybe<ObjectMessageDetectionFilter>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionObjectMessageDetectionCuboidsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ObjectMessageDetectionCuboidsOrderBy>>;
  condition?: Maybe<ObjectMessageDetectionCuboidCondition>;
  filter?: Maybe<ObjectMessageDetectionCuboidFilter>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionObjectMessageDetectionCuboidCentroidsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ObjectMessageDetectionCuboidCentroidsOrderBy>>;
  condition?: Maybe<ObjectMessageDetectionCuboidCentroidCondition>;
  filter?: Maybe<ObjectMessageDetectionCuboidCentroidFilter>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionObjectMessageDetectionCuboidDimensionsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ObjectMessageDetectionCuboidDimensionsOrderBy>>;
  condition?: Maybe<ObjectMessageDetectionCuboidDimensionCondition>;
  filter?: Maybe<ObjectMessageDetectionCuboidDimensionFilter>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionObjectMessageDetectionCuboidOrientationsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ObjectMessageDetectionCuboidOrientationsOrderBy>>;
  condition?: Maybe<ObjectMessageDetectionCuboidOrientationCondition>;
  filter?: Maybe<ObjectMessageDetectionCuboidOrientationFilter>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionObjectMessageDetectionHeadersArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ObjectMessageDetectionHeadersOrderBy>>;
  condition?: Maybe<ObjectMessageDetectionHeaderCondition>;
  filter?: Maybe<ObjectMessageDetectionHeaderFilter>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionObjectMessageDetectionRoisArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ObjectMessageDetectionRoisOrderBy>>;
  condition?: Maybe<ObjectMessageDetectionRoiCondition>;
  filter?: Maybe<ObjectMessageDetectionRoiFilter>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionObjectMessageEcefsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ObjectMessageEcefsOrderBy>>;
  condition?: Maybe<ObjectMessageEcefCondition>;
  filter?: Maybe<ObjectMessageEcefFilter>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionObjectMessageEnusArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ObjectMessageEnusOrderBy>>;
  condition?: Maybe<ObjectMessageEnuCondition>;
  filter?: Maybe<ObjectMessageEnuFilter>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionObjectMessageFieldOriginsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ObjectMessageFieldOriginsOrderBy>>;
  condition?: Maybe<ObjectMessageFieldOriginCondition>;
  filter?: Maybe<ObjectMessageFieldOriginFilter>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionObjectMessageHeadersArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ObjectMessageHeadersOrderBy>>;
  condition?: Maybe<ObjectMessageHeaderCondition>;
  filter?: Maybe<ObjectMessageHeaderFilter>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionObjectMessageLlasArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ObjectMessageLlasOrderBy>>;
  condition?: Maybe<ObjectMessageLlaCondition>;
  filter?: Maybe<ObjectMessageLlaFilter>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionObjectMessageVerticesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ObjectMessageVerticesOrderBy>>;
  condition?: Maybe<ObjectMessageVertexCondition>;
  filter?: Maybe<ObjectMessageVertexFilter>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionObjectMessageXyzCamerasArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ObjectMessageXyzCamerasOrderBy>>;
  condition?: Maybe<ObjectMessageXyzCameraCondition>;
  filter?: Maybe<ObjectMessageXyzCameraFilter>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionObjectMessageXyzStarfiresArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ObjectMessageXyzStarfiresOrderBy>>;
  condition?: Maybe<ObjectMessageXyzStarfireCondition>;
  filter?: Maybe<ObjectMessageXyzStarfireFilter>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionObjectsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ObjectsOrderBy>>;
  condition?: Maybe<ObjectCondition>;
  filter?: Maybe<ObjectFilter>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionVehicleTopicArgs = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionVehicleTypeArgs = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionVehicleTypeByTypeArgs = {
  type: Scalars['String'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionVehicleArgs = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionVehicleByDeviceIdArgs = {
  deviceId: Scalars['String'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionVehiclesOnlineArgs = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionVehiclesOnlineByVehicleIdArgs = {
  vehicleId: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionTopicCategoryArgs = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionTopicTypeArgs = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionTopicTypeByModuleArgs = {
  module: Scalars['String'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionTopicArgs = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionTopicByNameArgs = {
  name: Scalars['String'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionTestArgs = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionVehicleLogMessageStampArgs = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionVehicleLogMessageArgs = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionVehicleLogArgs = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionStarfireArgs = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionStarfireHeaderArgs = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionStarfireMessageArgs = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionCameraArgs = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionCameraHistogramArgs = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionCameraMessageArgs = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionCameraMessageHeaderArgs = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionCameraMetaArgs = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionCameraMetaEArgs = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionCameraMetaFArgs = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionCameraMetaP1Args = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionCameraMetaP2Args = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionCameraMetaQArgs = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionCameraMetaR1Args = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionCameraMetaR2Args = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionCameraPairArgs = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionCameraPairMessageArgs = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionCameraRoiArgs = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionFullHistogramArgs = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionImageDatumArgs = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionImageHeaderArgs = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionImageHeaderStampArgs = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionImageArgs = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionSegmentationMapArgs = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionSideIntrinsicArgs = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionSideIntrinsicsDArgs = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionSideIntrinsicsKArgs = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionSmallHistogramArgs = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionStereoExtrinsicArgs = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionStereoExtrinsicsRArgs = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionStereoExtrinsicsRRodrigueArgs = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionStereoExtrinsicsTArgs = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionTractorExtrinsicArgs = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionTractorExtrinsicsRArgs = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionTractorExtrinsicsRRodrigueArgs = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionTractorExtrinsicsTArgs = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionAlertTypeArgs = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionAlertArgs = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionStatusMessageArgs = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionStatusMessageHeaderArgs = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionStatusMessageMissionStatArgs = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionVehicleStateReasonArgs = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionVehicleStateArgs = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionVehicleStateByNameArgs = {
  name: Scalars['String'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionVehicleStateByCodeArgs = {
  code: Scalars['Int'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionVehicleStatusArgs = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionVehicleStatusDetailArgs = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionObjectMessageArgs = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionObjectMessageCentroidLocationArgs = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionObjectMessageCentroidRpyArgs = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionObjectMessageCircleCenterArgs = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionObjectMessageDetectionArgs = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionObjectMessageDetectionCuboidArgs = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionObjectMessageDetectionCuboidCentroidArgs = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionObjectMessageDetectionCuboidDimensionArgs = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionObjectMessageDetectionCuboidOrientationArgs = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionObjectMessageDetectionHeaderArgs = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionObjectMessageDetectionRoiArgs = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionObjectMessageEcefArgs = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionObjectMessageEnuArgs = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionObjectMessageFieldOriginArgs = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionObjectMessageHeaderArgs = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionObjectMessageLlaArgs = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionObjectMessageVertexArgs = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionObjectMessageXyzCameraArgs = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionObjectMessageXyzStarfireArgs = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionObjectArgs = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionVehicleTopicByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionVehicleTypeByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionVehicleByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionVehiclesOnlineByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionTopicCategoryByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionTopicTypeByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionTopicByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionTestByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionVehicleLogMessageStampByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionVehicleLogMessageByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionVehicleLogByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionStarfireByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionStarfireHeaderByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionStarfireMessageByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionCameraByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionCameraHistogramByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionCameraMessageByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionCameraMessageHeaderByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionCameraMetaByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionCameraMetaEByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionCameraMetaFByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionCameraMetaP1ByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionCameraMetaP2ByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionCameraMetaQByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionCameraMetaR1ByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionCameraMetaR2ByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionCameraPairByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionCameraPairMessageByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionCameraRoiByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionFullHistogramByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionImageDatumByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionImageHeaderByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionImageHeaderStampByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionImageByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionSegmentationMapByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionSideIntrinsicByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionSideIntrinsicsDByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionSideIntrinsicsKByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionSmallHistogramByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionStereoExtrinsicByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionStereoExtrinsicsRByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionStereoExtrinsicsRRodrigueByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionStereoExtrinsicsTByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionTractorExtrinsicByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionTractorExtrinsicsRByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionTractorExtrinsicsRRodrigueByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionTractorExtrinsicsTByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionAlertTypeByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionAlertByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionStatusMessageByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionStatusMessageHeaderByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionStatusMessageMissionStatByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionVehicleStateReasonByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionVehicleStateByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionVehicleStatusByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionVehicleStatusDetailByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionObjectMessageByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionObjectMessageCentroidLocationByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionObjectMessageCentroidRpyByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionObjectMessageCircleCenterByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionObjectMessageDetectionByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionObjectMessageDetectionCuboidByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionObjectMessageDetectionCuboidCentroidByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionObjectMessageDetectionCuboidDimensionByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionObjectMessageDetectionCuboidOrientationByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionObjectMessageDetectionHeaderByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionObjectMessageDetectionRoiByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionObjectMessageEcefByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionObjectMessageEnuByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionObjectMessageFieldOriginByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionObjectMessageHeaderByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionObjectMessageLlaByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionObjectMessageVertexByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionObjectMessageXyzCameraByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionObjectMessageXyzStarfireByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionObjectByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionListenArgs = {
  topic: Scalars['String'];
};

export type Test = Node & {
  __typename?: 'Test';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  test?: Maybe<Scalars['String']>;
};

/** A condition to be used against `Test` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type TestCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `test` field. */
  test?: Maybe<Scalars['String']>;
};

/** A filter to be used against `Test` object types. All fields are combined with a logical ‘and.’ */
export type TestFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `test` field. */
  test?: Maybe<StringFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<TestFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<TestFilter>>;
  /** Negates the expression. */
  not?: Maybe<TestFilter>;
};

/** An input for mutations affecting `Test` */
export type TestInput = {
  id?: Maybe<Scalars['BigInt']>;
  test?: Maybe<Scalars['String']>;
};

/** Represents an update to a `Test`. Fields that are set will be updated. */
export type TestPatch = {
  id?: Maybe<Scalars['BigInt']>;
  test?: Maybe<Scalars['String']>;
};

/** A connection to a list of `Test` values. */
export type TestsConnection = {
  __typename?: 'TestsConnection';
  /** A list of `Test` objects. */
  nodes: Array<Maybe<Test>>;
  /** A list of edges which contains the `Test` and cursor to aid in pagination. */
  edges: Array<TestsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Test` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `Test` edge in the connection. */
export type TestsEdge = {
  __typename?: 'TestsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Test` at the end of the edge. */
  node?: Maybe<Test>;
};

/** Methods to use when ordering `Test`. */
export enum TestsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  TestAsc = 'TEST_ASC',
  TestDesc = 'TEST_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/** This is the topics table, which is related a topics passed from the vehicle */
export type Topic = Node & {
  __typename?: 'Topic';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  /** The ID of topic assigned by the database */
  id: Scalars['BigInt'];
  /** The description of topic */
  description?: Maybe<Scalars['String']>;
  /** The timestamp of topic added by the database */
  createdAt: Scalars['Datetime'];
  /** The timestamp of topic updated on the database */
  updatedAt: Scalars['Datetime'];
  /** The type of topic */
  typeId: Scalars['BigInt'];
  /** The name of topic */
  name: Scalars['String'];
  topicCategoryId: Scalars['BigInt'];
  /** Reads a single `TopicType` that is related to this `Topic`. */
  type?: Maybe<TopicType>;
  /** Reads a single `TopicCategory` that is related to this `Topic`. */
  topicCategory?: Maybe<TopicCategory>;
  /** Reads and enables pagination through a set of `CameraPair`. */
  cameraPairs: CameraPairsConnection;
  /** Reads and enables pagination through a set of `Starfire`. */
  starfires: StarfiresConnection;
  /** Reads and enables pagination through a set of `Camera`. */
  cameras: CamerasConnection;
  /** Reads and enables pagination through a set of `VehicleTopic`. */
  vehicleTopics: VehicleTopicsConnection;
  /** Reads and enables pagination through a set of `SegmentationMap`. */
  segmentationMaps: SegmentationMapsConnection;
  /** Reads and enables pagination through a set of `VehicleStatus`. */
  vehicleStatuses: VehicleStatusesConnection;
  /** Reads and enables pagination through a set of `Object`. */
  objects: ObjectsConnection;
  /** Reads and enables pagination through a set of `VehicleLog`. */
  vehicleLogs: VehicleLogsConnection;
};


/** This is the topics table, which is related a topics passed from the vehicle */
export type TopicCameraPairsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CameraPairsOrderBy>>;
  condition?: Maybe<CameraPairCondition>;
  filter?: Maybe<CameraPairFilter>;
};


/** This is the topics table, which is related a topics passed from the vehicle */
export type TopicStarfiresArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<StarfiresOrderBy>>;
  condition?: Maybe<StarfireCondition>;
  filter?: Maybe<StarfireFilter>;
};


/** This is the topics table, which is related a topics passed from the vehicle */
export type TopicCamerasArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CamerasOrderBy>>;
  condition?: Maybe<CameraCondition>;
  filter?: Maybe<CameraFilter>;
};


/** This is the topics table, which is related a topics passed from the vehicle */
export type TopicVehicleTopicsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<VehicleTopicsOrderBy>>;
  condition?: Maybe<VehicleTopicCondition>;
  filter?: Maybe<VehicleTopicFilter>;
};


/** This is the topics table, which is related a topics passed from the vehicle */
export type TopicSegmentationMapsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<SegmentationMapsOrderBy>>;
  condition?: Maybe<SegmentationMapCondition>;
  filter?: Maybe<SegmentationMapFilter>;
};


/** This is the topics table, which is related a topics passed from the vehicle */
export type TopicVehicleStatusesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<VehicleStatusesOrderBy>>;
  condition?: Maybe<VehicleStatusCondition>;
  filter?: Maybe<VehicleStatusFilter>;
};


/** This is the topics table, which is related a topics passed from the vehicle */
export type TopicObjectsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ObjectsOrderBy>>;
  condition?: Maybe<ObjectCondition>;
  filter?: Maybe<ObjectFilter>;
};


/** This is the topics table, which is related a topics passed from the vehicle */
export type TopicVehicleLogsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<VehicleLogsOrderBy>>;
  condition?: Maybe<VehicleLogCondition>;
  filter?: Maybe<VehicleLogFilter>;
};

/** A connection to a list of `TopicCategory` values. */
export type TopicCategoriesConnection = {
  __typename?: 'TopicCategoriesConnection';
  /** A list of `TopicCategory` objects. */
  nodes: Array<Maybe<TopicCategory>>;
  /** A list of edges which contains the `TopicCategory` and cursor to aid in pagination. */
  edges: Array<TopicCategoriesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `TopicCategory` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `TopicCategory` edge in the connection. */
export type TopicCategoriesEdge = {
  __typename?: 'TopicCategoriesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `TopicCategory` at the end of the edge. */
  node?: Maybe<TopicCategory>;
};

/** Methods to use when ordering `TopicCategory`. */
export enum TopicCategoriesOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/** Table consists of the categories each topic belongs to. */
export type TopicCategory = Node & {
  __typename?: 'TopicCategory';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  /** Autoincremented id of the category */
  id: Scalars['BigInt'];
  /** The name of the category */
  name: Scalars['String'];
  /** Reads and enables pagination through a set of `Topic`. */
  topics: TopicsConnection;
};


/** Table consists of the categories each topic belongs to. */
export type TopicCategoryTopicsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<TopicsOrderBy>>;
  condition?: Maybe<TopicCondition>;
  filter?: Maybe<TopicFilter>;
};

/**
 * A condition to be used against `TopicCategory` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type TopicCategoryCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `name` field. */
  name?: Maybe<Scalars['String']>;
};

/** A filter to be used against `TopicCategory` object types. All fields are combined with a logical ‘and.’ */
export type TopicCategoryFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `name` field. */
  name?: Maybe<StringFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<TopicCategoryFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<TopicCategoryFilter>>;
  /** Negates the expression. */
  not?: Maybe<TopicCategoryFilter>;
};

/** A condition to be used against `Topic` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type TopicCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `description` field. */
  description?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `typeId` field. */
  typeId?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `name` field. */
  name?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `topicCategoryId` field. */
  topicCategoryId?: Maybe<Scalars['BigInt']>;
};

/** A filter to be used against `Topic` object types. All fields are combined with a logical ‘and.’ */
export type TopicFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `description` field. */
  description?: Maybe<StringFilter>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `typeId` field. */
  typeId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `name` field. */
  name?: Maybe<StringFilter>;
  /** Filter by the object’s `topicCategoryId` field. */
  topicCategoryId?: Maybe<BigIntFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<TopicFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<TopicFilter>>;
  /** Negates the expression. */
  not?: Maybe<TopicFilter>;
};

/** An input for mutations affecting `Topic` */
export type TopicInput = {
  /** The description of topic */
  description?: Maybe<Scalars['String']>;
  /** The timestamp of topic updated on the database */
  updatedAt?: Maybe<Scalars['Datetime']>;
  /** The type of topic */
  typeId: Scalars['BigInt'];
  /** The name of topic */
  name: Scalars['String'];
  topicCategoryId: Scalars['BigInt'];
};

/** Represents an update to a `Topic`. Fields that are set will be updated. */
export type TopicPatch = {
  /** The description of topic */
  description?: Maybe<Scalars['String']>;
  /** The timestamp of topic updated on the database */
  updatedAt?: Maybe<Scalars['Datetime']>;
  /** The type of topic */
  typeId?: Maybe<Scalars['BigInt']>;
  /** The name of topic */
  name?: Maybe<Scalars['String']>;
  topicCategoryId?: Maybe<Scalars['BigInt']>;
};

/** This is the topics types table, which is related a topics type object passed from the vehicle */
export type TopicType = Node & {
  __typename?: 'TopicType';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  /** The ID of topic type assigned by the database */
  id: Scalars['BigInt'];
  /** The module of topic type */
  module: Scalars['String'];
  /** The class of topic type */
  class: Scalars['String'];
  /** Reads and enables pagination through a set of `Topic`. */
  topicsByTypeId: TopicsConnection;
  /** Reads and enables pagination through a set of `CameraPair`. */
  cameraPairs: CameraPairsConnection;
};


/** This is the topics types table, which is related a topics type object passed from the vehicle */
export type TopicTypeTopicsByTypeIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<TopicsOrderBy>>;
  condition?: Maybe<TopicCondition>;
  filter?: Maybe<TopicFilter>;
};


/** This is the topics types table, which is related a topics type object passed from the vehicle */
export type TopicTypeCameraPairsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CameraPairsOrderBy>>;
  condition?: Maybe<CameraPairCondition>;
  filter?: Maybe<CameraPairFilter>;
};

/**
 * A condition to be used against `TopicType` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type TopicTypeCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `module` field. */
  module?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `class` field. */
  class?: Maybe<Scalars['String']>;
};

/** A filter to be used against `TopicType` object types. All fields are combined with a logical ‘and.’ */
export type TopicTypeFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `module` field. */
  module?: Maybe<StringFilter>;
  /** Filter by the object’s `class` field. */
  class?: Maybe<StringFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<TopicTypeFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<TopicTypeFilter>>;
  /** Negates the expression. */
  not?: Maybe<TopicTypeFilter>;
};

/** An input for mutations affecting `TopicType` */
export type TopicTypeInput = {
  /** The module of topic type */
  module: Scalars['String'];
  /** The class of topic type */
  class: Scalars['String'];
};

/** Represents an update to a `TopicType`. Fields that are set will be updated. */
export type TopicTypePatch = {
  /** The module of topic type */
  module?: Maybe<Scalars['String']>;
  /** The class of topic type */
  class?: Maybe<Scalars['String']>;
};

/** A connection to a list of `TopicType` values. */
export type TopicTypesConnection = {
  __typename?: 'TopicTypesConnection';
  /** A list of `TopicType` objects. */
  nodes: Array<Maybe<TopicType>>;
  /** A list of edges which contains the `TopicType` and cursor to aid in pagination. */
  edges: Array<TopicTypesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `TopicType` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `TopicType` edge in the connection. */
export type TopicTypesEdge = {
  __typename?: 'TopicTypesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `TopicType` at the end of the edge. */
  node?: Maybe<TopicType>;
};

/** Methods to use when ordering `TopicType`. */
export enum TopicTypesOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  ModuleAsc = 'MODULE_ASC',
  ModuleDesc = 'MODULE_DESC',
  ClassAsc = 'CLASS_ASC',
  ClassDesc = 'CLASS_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/** A connection to a list of `Topic` values. */
export type TopicsConnection = {
  __typename?: 'TopicsConnection';
  /** A list of `Topic` objects. */
  nodes: Array<Maybe<Topic>>;
  /** A list of edges which contains the `Topic` and cursor to aid in pagination. */
  edges: Array<TopicsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Topic` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `Topic` edge in the connection. */
export type TopicsEdge = {
  __typename?: 'TopicsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Topic` at the end of the edge. */
  node?: Maybe<Topic>;
};

/** Methods to use when ordering `Topic`. */
export enum TopicsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  DescriptionAsc = 'DESCRIPTION_ASC',
  DescriptionDesc = 'DESCRIPTION_DESC',
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC',
  TypeIdAsc = 'TYPE_ID_ASC',
  TypeIdDesc = 'TYPE_ID_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  TopicCategoryIdAsc = 'TOPIC_CATEGORY_ID_ASC',
  TopicCategoryIdDesc = 'TOPIC_CATEGORY_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/** Table tractor extrinsics from camera */
export type TractorExtrinsic = Node & {
  __typename?: 'TractorExtrinsic';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  /** Id generated by database, auto incremented */
  id: Scalars['BigInt'];
  /** t id for  tractor extrinsics */
  tId: Scalars['BigInt'];
  /** r id for  tractor extrinsics */
  rId: Scalars['BigInt'];
  /** r rodrigues id for  tractor extrinsics */
  rRodriguesId: Scalars['BigInt'];
  /** Reads a single `TractorExtrinsicsT` that is related to this `TractorExtrinsic`. */
  t?: Maybe<TractorExtrinsicsT>;
  /** Reads a single `TractorExtrinsicsR` that is related to this `TractorExtrinsic`. */
  r?: Maybe<TractorExtrinsicsR>;
  /** Reads a single `TractorExtrinsicsRRodrigue` that is related to this `TractorExtrinsic`. */
  rRodrigues?: Maybe<TractorExtrinsicsRRodrigue>;
  /** Reads and enables pagination through a set of `CameraMeta`. */
  cameraMetasByTractorExtrinsicsId: CameraMetasConnection;
};


/** Table tractor extrinsics from camera */
export type TractorExtrinsicCameraMetasByTractorExtrinsicsIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CameraMetasOrderBy>>;
  condition?: Maybe<CameraMetaCondition>;
  filter?: Maybe<CameraMetaFilter>;
};

/**
 * A condition to be used against `TractorExtrinsic` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type TractorExtrinsicCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `tId` field. */
  tId?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `rId` field. */
  rId?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `rRodriguesId` field. */
  rRodriguesId?: Maybe<Scalars['BigInt']>;
};

/** A filter to be used against `TractorExtrinsic` object types. All fields are combined with a logical ‘and.’ */
export type TractorExtrinsicFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `tId` field. */
  tId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `rId` field. */
  rId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `rRodriguesId` field. */
  rRodriguesId?: Maybe<BigIntFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<TractorExtrinsicFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<TractorExtrinsicFilter>>;
  /** Negates the expression. */
  not?: Maybe<TractorExtrinsicFilter>;
};

/** A connection to a list of `TractorExtrinsic` values. */
export type TractorExtrinsicsConnection = {
  __typename?: 'TractorExtrinsicsConnection';
  /** A list of `TractorExtrinsic` objects. */
  nodes: Array<Maybe<TractorExtrinsic>>;
  /** A list of edges which contains the `TractorExtrinsic` and cursor to aid in pagination. */
  edges: Array<TractorExtrinsicsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `TractorExtrinsic` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `TractorExtrinsic` edge in the connection. */
export type TractorExtrinsicsEdge = {
  __typename?: 'TractorExtrinsicsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `TractorExtrinsic` at the end of the edge. */
  node?: Maybe<TractorExtrinsic>;
};

/** Methods to use when ordering `TractorExtrinsic`. */
export enum TractorExtrinsicsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  TIdAsc = 'T_ID_ASC',
  TIdDesc = 'T_ID_DESC',
  RIdAsc = 'R_ID_ASC',
  RIdDesc = 'R_ID_DESC',
  RRodriguesIdAsc = 'R_RODRIGUES_ID_ASC',
  RRodriguesIdDesc = 'R_RODRIGUES_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/** Table tractor extrinsics r from camera */
export type TractorExtrinsicsR = Node & {
  __typename?: 'TractorExtrinsicsR';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  /** Id generated by database, auto incremented */
  id: Scalars['BigInt'];
  /** data for tractor extrinsics r */
  data: Scalars['String'];
  /** Reads and enables pagination through a set of `TractorExtrinsic`. */
  tractorExtrinsicsByRId: TractorExtrinsicsConnection;
};


/** Table tractor extrinsics r from camera */
export type TractorExtrinsicsRTractorExtrinsicsByRIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<TractorExtrinsicsOrderBy>>;
  condition?: Maybe<TractorExtrinsicCondition>;
  filter?: Maybe<TractorExtrinsicFilter>;
};

/**
 * A condition to be used against `TractorExtrinsicsR` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type TractorExtrinsicsRCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `data` field. */
  data?: Maybe<Scalars['String']>;
};

/** A filter to be used against `TractorExtrinsicsR` object types. All fields are combined with a logical ‘and.’ */
export type TractorExtrinsicsRFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `data` field. */
  data?: Maybe<StringFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<TractorExtrinsicsRFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<TractorExtrinsicsRFilter>>;
  /** Negates the expression. */
  not?: Maybe<TractorExtrinsicsRFilter>;
};

/** Table tractor extrinsics r from camera */
export type TractorExtrinsicsRRodrigue = Node & {
  __typename?: 'TractorExtrinsicsRRodrigue';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  /** Id generated by database, auto incremented */
  id: Scalars['BigInt'];
  /** data for tractor extrinsics r rodrigues */
  data: Scalars['String'];
  /** Reads and enables pagination through a set of `TractorExtrinsic`. */
  tractorExtrinsicsByRRodriguesId: TractorExtrinsicsConnection;
};


/** Table tractor extrinsics r from camera */
export type TractorExtrinsicsRRodrigueTractorExtrinsicsByRRodriguesIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<TractorExtrinsicsOrderBy>>;
  condition?: Maybe<TractorExtrinsicCondition>;
  filter?: Maybe<TractorExtrinsicFilter>;
};

/**
 * A condition to be used against `TractorExtrinsicsRRodrigue` object types. All
 * fields are tested for equality and combined with a logical ‘and.’
 */
export type TractorExtrinsicsRRodrigueCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `data` field. */
  data?: Maybe<Scalars['String']>;
};

/** A filter to be used against `TractorExtrinsicsRRodrigue` object types. All fields are combined with a logical ‘and.’ */
export type TractorExtrinsicsRRodrigueFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `data` field. */
  data?: Maybe<StringFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<TractorExtrinsicsRRodrigueFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<TractorExtrinsicsRRodrigueFilter>>;
  /** Negates the expression. */
  not?: Maybe<TractorExtrinsicsRRodrigueFilter>;
};

/** A connection to a list of `TractorExtrinsicsRRodrigue` values. */
export type TractorExtrinsicsRRodriguesConnection = {
  __typename?: 'TractorExtrinsicsRRodriguesConnection';
  /** A list of `TractorExtrinsicsRRodrigue` objects. */
  nodes: Array<Maybe<TractorExtrinsicsRRodrigue>>;
  /** A list of edges which contains the `TractorExtrinsicsRRodrigue` and cursor to aid in pagination. */
  edges: Array<TractorExtrinsicsRRodriguesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `TractorExtrinsicsRRodrigue` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `TractorExtrinsicsRRodrigue` edge in the connection. */
export type TractorExtrinsicsRRodriguesEdge = {
  __typename?: 'TractorExtrinsicsRRodriguesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `TractorExtrinsicsRRodrigue` at the end of the edge. */
  node?: Maybe<TractorExtrinsicsRRodrigue>;
};

/** Methods to use when ordering `TractorExtrinsicsRRodrigue`. */
export enum TractorExtrinsicsRRodriguesOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  DataAsc = 'DATA_ASC',
  DataDesc = 'DATA_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/** A connection to a list of `TractorExtrinsicsR` values. */
export type TractorExtrinsicsRsConnection = {
  __typename?: 'TractorExtrinsicsRsConnection';
  /** A list of `TractorExtrinsicsR` objects. */
  nodes: Array<Maybe<TractorExtrinsicsR>>;
  /** A list of edges which contains the `TractorExtrinsicsR` and cursor to aid in pagination. */
  edges: Array<TractorExtrinsicsRsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `TractorExtrinsicsR` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `TractorExtrinsicsR` edge in the connection. */
export type TractorExtrinsicsRsEdge = {
  __typename?: 'TractorExtrinsicsRsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `TractorExtrinsicsR` at the end of the edge. */
  node?: Maybe<TractorExtrinsicsR>;
};

/** Methods to use when ordering `TractorExtrinsicsR`. */
export enum TractorExtrinsicsRsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  DataAsc = 'DATA_ASC',
  DataDesc = 'DATA_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/** Table tractor extrinsics t from camera */
export type TractorExtrinsicsT = Node & {
  __typename?: 'TractorExtrinsicsT';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  /** Id generated by database, auto incremented */
  id: Scalars['BigInt'];
  /** data for tractor extrinsics t  */
  data: Scalars['String'];
  /** Reads and enables pagination through a set of `TractorExtrinsic`. */
  tractorExtrinsicsByTId: TractorExtrinsicsConnection;
};


/** Table tractor extrinsics t from camera */
export type TractorExtrinsicsTTractorExtrinsicsByTIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<TractorExtrinsicsOrderBy>>;
  condition?: Maybe<TractorExtrinsicCondition>;
  filter?: Maybe<TractorExtrinsicFilter>;
};

/**
 * A condition to be used against `TractorExtrinsicsT` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type TractorExtrinsicsTCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `data` field. */
  data?: Maybe<Scalars['String']>;
};

/** A filter to be used against `TractorExtrinsicsT` object types. All fields are combined with a logical ‘and.’ */
export type TractorExtrinsicsTFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `data` field. */
  data?: Maybe<StringFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<TractorExtrinsicsTFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<TractorExtrinsicsTFilter>>;
  /** Negates the expression. */
  not?: Maybe<TractorExtrinsicsTFilter>;
};

/** A connection to a list of `TractorExtrinsicsT` values. */
export type TractorExtrinsicsTsConnection = {
  __typename?: 'TractorExtrinsicsTsConnection';
  /** A list of `TractorExtrinsicsT` objects. */
  nodes: Array<Maybe<TractorExtrinsicsT>>;
  /** A list of edges which contains the `TractorExtrinsicsT` and cursor to aid in pagination. */
  edges: Array<TractorExtrinsicsTsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `TractorExtrinsicsT` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `TractorExtrinsicsT` edge in the connection. */
export type TractorExtrinsicsTsEdge = {
  __typename?: 'TractorExtrinsicsTsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `TractorExtrinsicsT` at the end of the edge. */
  node?: Maybe<TractorExtrinsicsT>;
};

/** Methods to use when ordering `TractorExtrinsicsT`. */
export enum TractorExtrinsicsTsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  DataAsc = 'DATA_ASC',
  DataDesc = 'DATA_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/** All input for the `updateAlertByNodeId` mutation. */
export type UpdateAlertByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Alert` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Alert` being updated. */
  patch: AlertPatch;
};

/** All input for the `updateAlert` mutation. */
export type UpdateAlertInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Alert` being updated. */
  patch: AlertPatch;
  /** Id for the alert assigned by database */
  id: Scalars['BigInt'];
};

/** The output of our update `Alert` mutation. */
export type UpdateAlertPayload = {
  __typename?: 'UpdateAlertPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Alert` that was updated by this mutation. */
  alert?: Maybe<Alert>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `AlertType` that is related to this `Alert`. */
  alertType?: Maybe<AlertType>;
  /** Reads a single `VehicleStatus` that is related to this `Alert`. */
  vehicleStatus?: Maybe<VehicleStatus>;
  /** An edge for our `Alert`. May be used by Relay 1. */
  alertEdge?: Maybe<AlertsEdge>;
};


/** The output of our update `Alert` mutation. */
export type UpdateAlertPayloadAlertEdgeArgs = {
  orderBy?: Maybe<Array<AlertsOrderBy>>;
};

/** All input for the `updateAlertTypeByNodeId` mutation. */
export type UpdateAlertTypeByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `AlertType` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `AlertType` being updated. */
  patch: AlertTypePatch;
};

/** All input for the `updateAlertType` mutation. */
export type UpdateAlertTypeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `AlertType` being updated. */
  patch: AlertTypePatch;
  /** Id for the alert type assigned by database */
  id: Scalars['BigInt'];
};

/** The output of our update `AlertType` mutation. */
export type UpdateAlertTypePayload = {
  __typename?: 'UpdateAlertTypePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `AlertType` that was updated by this mutation. */
  alertType?: Maybe<AlertType>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `AlertType`. May be used by Relay 1. */
  alertTypeEdge?: Maybe<AlertTypesEdge>;
};


/** The output of our update `AlertType` mutation. */
export type UpdateAlertTypePayloadAlertTypeEdgeArgs = {
  orderBy?: Maybe<Array<AlertTypesOrderBy>>;
};

/** All input for the `updateCameraByNodeId` mutation. */
export type UpdateCameraByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Camera` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Camera` being updated. */
  patch: CameraPatch;
};

/** All input for the `updateCamera` mutation. */
export type UpdateCameraInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Camera` being updated. */
  patch: CameraPatch;
  /** id auto-incremented by database */
  id: Scalars['BigInt'];
};

/** All input for the `updateCameraMessageByNodeId` mutation. */
export type UpdateCameraMessageByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `CameraMessage` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `CameraMessage` being updated. */
  patch: CameraMessagePatch;
};

/** All input for the `updateCameraMessage` mutation. */
export type UpdateCameraMessageInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `CameraMessage` being updated. */
  patch: CameraMessagePatch;
  /** id auto-incremented by database */
  id: Scalars['BigInt'];
};

/** The output of our update `CameraMessage` mutation. */
export type UpdateCameraMessagePayload = {
  __typename?: 'UpdateCameraMessagePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CameraMessage` that was updated by this mutation. */
  cameraMessage?: Maybe<CameraMessage>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `CameraMessageHeader` that is related to this `CameraMessage`. */
  header?: Maybe<CameraMessageHeader>;
  /** Reads a single `Image` that is related to this `CameraMessage`. */
  image?: Maybe<Image>;
  /** Reads a single `CameraMeta` that is related to this `CameraMessage`. */
  cameraMeta?: Maybe<CameraMeta>;
  /** An edge for our `CameraMessage`. May be used by Relay 1. */
  cameraMessageEdge?: Maybe<CameraMessagesEdge>;
};


/** The output of our update `CameraMessage` mutation. */
export type UpdateCameraMessagePayloadCameraMessageEdgeArgs = {
  orderBy?: Maybe<Array<CameraMessagesOrderBy>>;
};

/** All input for the `updateCameraMetaByNodeId` mutation. */
export type UpdateCameraMetaByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `CameraMeta` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `CameraMeta` being updated. */
  patch: CameraMetaPatch;
};

/** All input for the `updateCameraMeta` mutation. */
export type UpdateCameraMetaInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `CameraMeta` being updated. */
  patch: CameraMetaPatch;
  /** id auto-incremented by database */
  id: Scalars['BigInt'];
};

/** The output of our update `CameraMeta` mutation. */
export type UpdateCameraMetaPayload = {
  __typename?: 'UpdateCameraMetaPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CameraMeta` that was updated by this mutation. */
  cameraMeta?: Maybe<CameraMeta>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `SideIntrinsic` that is related to this `CameraMeta`. */
  leftIntrinsics?: Maybe<SideIntrinsic>;
  /** Reads a single `SideIntrinsic` that is related to this `CameraMeta`. */
  rightIntrinsics?: Maybe<SideIntrinsic>;
  /** Reads a single `StereoExtrinsic` that is related to this `CameraMeta`. */
  stereoExtrinsics?: Maybe<StereoExtrinsic>;
  /** Reads a single `TractorExtrinsic` that is related to this `CameraMeta`. */
  tractorExtrinsics?: Maybe<TractorExtrinsic>;
  /** Reads a single `CameraMetaE` that is related to this `CameraMeta`. */
  e?: Maybe<CameraMetaE>;
  /** Reads a single `CameraMetaF` that is related to this `CameraMeta`. */
  f?: Maybe<CameraMetaF>;
  /** Reads a single `CameraMetaR1` that is related to this `CameraMeta`. */
  r1?: Maybe<CameraMetaR1>;
  /** Reads a single `CameraMetaR2` that is related to this `CameraMeta`. */
  r2?: Maybe<CameraMetaR2>;
  /** Reads a single `CameraMetaP1` that is related to this `CameraMeta`. */
  p1?: Maybe<CameraMetaP1>;
  /** Reads a single `CameraMetaP2` that is related to this `CameraMeta`. */
  p2?: Maybe<CameraMetaP2>;
  /** Reads a single `CameraMetaQ` that is related to this `CameraMeta`. */
  q?: Maybe<CameraMetaQ>;
  /** Reads a single `CameraRoi` that is related to this `CameraMeta`. */
  leftRoi?: Maybe<CameraRoi>;
  /** Reads a single `CameraRoi` that is related to this `CameraMeta`. */
  rightRoi?: Maybe<CameraRoi>;
  /** Reads a single `CameraHistogram` that is related to this `CameraMeta`. */
  leftHistogram?: Maybe<CameraHistogram>;
  /** Reads a single `CameraHistogram` that is related to this `CameraMeta`. */
  rightHistogram?: Maybe<CameraHistogram>;
  /** An edge for our `CameraMeta`. May be used by Relay 1. */
  cameraMetaEdge?: Maybe<CameraMetasEdge>;
};


/** The output of our update `CameraMeta` mutation. */
export type UpdateCameraMetaPayloadCameraMetaEdgeArgs = {
  orderBy?: Maybe<Array<CameraMetasOrderBy>>;
};

/** All input for the `updateCameraPairByNodeId` mutation. */
export type UpdateCameraPairByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `CameraPair` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `CameraPair` being updated. */
  patch: CameraPairPatch;
};

/** All input for the `updateCameraPair` mutation. */
export type UpdateCameraPairInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `CameraPair` being updated. */
  patch: CameraPairPatch;
  /** id auto-incremented by database */
  id: Scalars['BigInt'];
};

/** All input for the `updateCameraPairMessageByNodeId` mutation. */
export type UpdateCameraPairMessageByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `CameraPairMessage` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `CameraPairMessage` being updated. */
  patch: CameraPairMessagePatch;
};

/** All input for the `updateCameraPairMessage` mutation. */
export type UpdateCameraPairMessageInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `CameraPairMessage` being updated. */
  patch: CameraPairMessagePatch;
  /** id auto-incremented by database */
  id: Scalars['BigInt'];
};

/** The output of our update `CameraPairMessage` mutation. */
export type UpdateCameraPairMessagePayload = {
  __typename?: 'UpdateCameraPairMessagePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CameraPairMessage` that was updated by this mutation. */
  cameraPairMessage?: Maybe<CameraPairMessage>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `CameraMessageHeader` that is related to this `CameraPairMessage`. */
  header?: Maybe<CameraMessageHeader>;
  /** Reads a single `Image` that is related to this `CameraPairMessage`. */
  leftImage?: Maybe<Image>;
  /** Reads a single `Image` that is related to this `CameraPairMessage`. */
  rightImage?: Maybe<Image>;
  /** Reads a single `CameraMeta` that is related to this `CameraPairMessage`. */
  cameraMeta?: Maybe<CameraMeta>;
  /** An edge for our `CameraPairMessage`. May be used by Relay 1. */
  cameraPairMessageEdge?: Maybe<CameraPairMessagesEdge>;
};


/** The output of our update `CameraPairMessage` mutation. */
export type UpdateCameraPairMessagePayloadCameraPairMessageEdgeArgs = {
  orderBy?: Maybe<Array<CameraPairMessagesOrderBy>>;
};

/** The output of our update `CameraPair` mutation. */
export type UpdateCameraPairPayload = {
  __typename?: 'UpdateCameraPairPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CameraPair` that was updated by this mutation. */
  cameraPair?: Maybe<CameraPair>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Topic` that is related to this `CameraPair`. */
  topic?: Maybe<Topic>;
  /** Reads a single `CameraPairMessage` that is related to this `CameraPair`. */
  msg?: Maybe<CameraPairMessage>;
  /** Reads a single `TopicType` that is related to this `CameraPair`. */
  topicType?: Maybe<TopicType>;
  /** Reads a single `Vehicle` that is related to this `CameraPair`. */
  vehicle?: Maybe<Vehicle>;
  /** An edge for our `CameraPair`. May be used by Relay 1. */
  cameraPairEdge?: Maybe<CameraPairsEdge>;
};


/** The output of our update `CameraPair` mutation. */
export type UpdateCameraPairPayloadCameraPairEdgeArgs = {
  orderBy?: Maybe<Array<CameraPairsOrderBy>>;
};

/** The output of our update `Camera` mutation. */
export type UpdateCameraPayload = {
  __typename?: 'UpdateCameraPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Camera` that was updated by this mutation. */
  camera?: Maybe<Camera>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Topic` that is related to this `Camera`. */
  topic?: Maybe<Topic>;
  /** Reads a single `CameraMessage` that is related to this `Camera`. */
  msg?: Maybe<CameraMessage>;
  /** Reads a single `Vehicle` that is related to this `Camera`. */
  vehicle?: Maybe<Vehicle>;
  /** An edge for our `Camera`. May be used by Relay 1. */
  cameraEdge?: Maybe<CamerasEdge>;
};


/** The output of our update `Camera` mutation. */
export type UpdateCameraPayloadCameraEdgeArgs = {
  orderBy?: Maybe<Array<CamerasOrderBy>>;
};

/** All input for the `updateObjectByNodeId` mutation. */
export type UpdateObjectByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Object` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Object` being updated. */
  patch: ObjectPatch;
};

/** All input for the `updateObject` mutation. */
export type UpdateObjectInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Object` being updated. */
  patch: ObjectPatch;
  /** The id of the row that is autoincremented */
  id: Scalars['BigInt'];
};

/** All input for the `updateObjectMessageFieldOriginByNodeId` mutation. */
export type UpdateObjectMessageFieldOriginByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `ObjectMessageFieldOrigin` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `ObjectMessageFieldOrigin` being updated. */
  patch: ObjectMessageFieldOriginPatch;
};

/** All input for the `updateObjectMessageFieldOrigin` mutation. */
export type UpdateObjectMessageFieldOriginInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `ObjectMessageFieldOrigin` being updated. */
  patch: ObjectMessageFieldOriginPatch;
  /** The id of the row that is autoincremented */
  id: Scalars['BigInt'];
};

/** The output of our update `ObjectMessageFieldOrigin` mutation. */
export type UpdateObjectMessageFieldOriginPayload = {
  __typename?: 'UpdateObjectMessageFieldOriginPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ObjectMessageFieldOrigin` that was updated by this mutation. */
  objectMessageFieldOrigin?: Maybe<ObjectMessageFieldOrigin>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `ObjectMessageFieldOrigin`. May be used by Relay 1. */
  objectMessageFieldOriginEdge?: Maybe<ObjectMessageFieldOriginsEdge>;
};


/** The output of our update `ObjectMessageFieldOrigin` mutation. */
export type UpdateObjectMessageFieldOriginPayloadObjectMessageFieldOriginEdgeArgs = {
  orderBy?: Maybe<Array<ObjectMessageFieldOriginsOrderBy>>;
};

/** All input for the `updateObjectMessageHeaderByNodeId` mutation. */
export type UpdateObjectMessageHeaderByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `ObjectMessageHeader` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `ObjectMessageHeader` being updated. */
  patch: ObjectMessageHeaderPatch;
};

/** All input for the `updateObjectMessageHeader` mutation. */
export type UpdateObjectMessageHeaderInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `ObjectMessageHeader` being updated. */
  patch: ObjectMessageHeaderPatch;
  /** The id of the row that is autoincremented */
  id: Scalars['BigInt'];
};

/** The output of our update `ObjectMessageHeader` mutation. */
export type UpdateObjectMessageHeaderPayload = {
  __typename?: 'UpdateObjectMessageHeaderPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ObjectMessageHeader` that was updated by this mutation. */
  objectMessageHeader?: Maybe<ObjectMessageHeader>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `ObjectMessageHeader`. May be used by Relay 1. */
  objectMessageHeaderEdge?: Maybe<ObjectMessageHeadersEdge>;
};


/** The output of our update `ObjectMessageHeader` mutation. */
export type UpdateObjectMessageHeaderPayloadObjectMessageHeaderEdgeArgs = {
  orderBy?: Maybe<Array<ObjectMessageHeadersOrderBy>>;
};

/** The output of our update `Object` mutation. */
export type UpdateObjectPayload = {
  __typename?: 'UpdateObjectPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Object` that was updated by this mutation. */
  object?: Maybe<Object>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Vehicle` that is related to this `Object`. */
  vehicle?: Maybe<Vehicle>;
  /** Reads a single `Topic` that is related to this `Object`. */
  topic?: Maybe<Topic>;
  /** Reads a single `ObjectMessage` that is related to this `Object`. */
  message?: Maybe<ObjectMessage>;
  /** An edge for our `Object`. May be used by Relay 1. */
  objectEdge?: Maybe<ObjectsEdge>;
};


/** The output of our update `Object` mutation. */
export type UpdateObjectPayloadObjectEdgeArgs = {
  orderBy?: Maybe<Array<ObjectsOrderBy>>;
};

/** All input for the `updateSegmentationMapByNodeId` mutation. */
export type UpdateSegmentationMapByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `SegmentationMap` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `SegmentationMap` being updated. */
  patch: SegmentationMapPatch;
};

/** All input for the `updateSegmentationMap` mutation. */
export type UpdateSegmentationMapInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `SegmentationMap` being updated. */
  patch: SegmentationMapPatch;
  /** id auto-incremented by database */
  id: Scalars['BigInt'];
};

/** The output of our update `SegmentationMap` mutation. */
export type UpdateSegmentationMapPayload = {
  __typename?: 'UpdateSegmentationMapPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `SegmentationMap` that was updated by this mutation. */
  segmentationMap?: Maybe<SegmentationMap>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Topic` that is related to this `SegmentationMap`. */
  topic?: Maybe<Topic>;
  /** Reads a single `CameraMessage` that is related to this `SegmentationMap`. */
  msg?: Maybe<CameraMessage>;
  /** Reads a single `Vehicle` that is related to this `SegmentationMap`. */
  vehicle?: Maybe<Vehicle>;
  /** An edge for our `SegmentationMap`. May be used by Relay 1. */
  segmentationMapEdge?: Maybe<SegmentationMapsEdge>;
};


/** The output of our update `SegmentationMap` mutation. */
export type UpdateSegmentationMapPayloadSegmentationMapEdgeArgs = {
  orderBy?: Maybe<Array<SegmentationMapsOrderBy>>;
};

/** All input for the `updateSideIntrinsicsDByNodeId` mutation. */
export type UpdateSideIntrinsicsDByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `SideIntrinsicsD` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `SideIntrinsicsD` being updated. */
  patch: SideIntrinsicsDPatch;
};

/** All input for the `updateSideIntrinsicsD` mutation. */
export type UpdateSideIntrinsicsDInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `SideIntrinsicsD` being updated. */
  patch: SideIntrinsicsDPatch;
  /** Id generated by database, auto incremented */
  id: Scalars['BigInt'];
};

/** The output of our update `SideIntrinsicsD` mutation. */
export type UpdateSideIntrinsicsDPayload = {
  __typename?: 'UpdateSideIntrinsicsDPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `SideIntrinsicsD` that was updated by this mutation. */
  sideIntrinsicsD?: Maybe<SideIntrinsicsD>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `SideIntrinsicsD`. May be used by Relay 1. */
  sideIntrinsicsDEdge?: Maybe<SideIntrinsicsDsEdge>;
};


/** The output of our update `SideIntrinsicsD` mutation. */
export type UpdateSideIntrinsicsDPayloadSideIntrinsicsDEdgeArgs = {
  orderBy?: Maybe<Array<SideIntrinsicsDsOrderBy>>;
};

/** All input for the `updateSideIntrinsicsKByNodeId` mutation. */
export type UpdateSideIntrinsicsKByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `SideIntrinsicsK` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `SideIntrinsicsK` being updated. */
  patch: SideIntrinsicsKPatch;
};

/** All input for the `updateSideIntrinsicsK` mutation. */
export type UpdateSideIntrinsicsKInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `SideIntrinsicsK` being updated. */
  patch: SideIntrinsicsKPatch;
  /** Id generated by database, auto incremented */
  id: Scalars['BigInt'];
};

/** The output of our update `SideIntrinsicsK` mutation. */
export type UpdateSideIntrinsicsKPayload = {
  __typename?: 'UpdateSideIntrinsicsKPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `SideIntrinsicsK` that was updated by this mutation. */
  sideIntrinsicsK?: Maybe<SideIntrinsicsK>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `SideIntrinsicsK`. May be used by Relay 1. */
  sideIntrinsicsKEdge?: Maybe<SideIntrinsicsKsEdge>;
};


/** The output of our update `SideIntrinsicsK` mutation. */
export type UpdateSideIntrinsicsKPayloadSideIntrinsicsKEdgeArgs = {
  orderBy?: Maybe<Array<SideIntrinsicsKsOrderBy>>;
};

/** All input for the `updateStarfireByNodeId` mutation. */
export type UpdateStarfireByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Starfire` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Starfire` being updated. */
  patch: StarfirePatch;
};

/** All input for the `updateStarfireHeaderByNodeId` mutation. */
export type UpdateStarfireHeaderByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `StarfireHeader` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `StarfireHeader` being updated. */
  patch: StarfireHeaderPatch;
};

/** All input for the `updateStarfireHeader` mutation. */
export type UpdateStarfireHeaderInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `StarfireHeader` being updated. */
  patch: StarfireHeaderPatch;
  /** The ID of starfire header assigned by the database */
  id: Scalars['BigInt'];
};

/** The output of our update `StarfireHeader` mutation. */
export type UpdateStarfireHeaderPayload = {
  __typename?: 'UpdateStarfireHeaderPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `StarfireHeader` that was updated by this mutation. */
  starfireHeader?: Maybe<StarfireHeader>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `StarfireHeader`. May be used by Relay 1. */
  starfireHeaderEdge?: Maybe<StarfireHeadersEdge>;
};


/** The output of our update `StarfireHeader` mutation. */
export type UpdateStarfireHeaderPayloadStarfireHeaderEdgeArgs = {
  orderBy?: Maybe<Array<StarfireHeadersOrderBy>>;
};

/** All input for the `updateStarfire` mutation. */
export type UpdateStarfireInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Starfire` being updated. */
  patch: StarfirePatch;
  /** The ID of starfire assigned by the database */
  id: Scalars['BigInt'];
};

/** All input for the `updateStarfireMessageByNodeId` mutation. */
export type UpdateStarfireMessageByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `StarfireMessage` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `StarfireMessage` being updated. */
  patch: StarfireMessagePatch;
};

/** All input for the `updateStarfireMessage` mutation. */
export type UpdateStarfireMessageInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `StarfireMessage` being updated. */
  patch: StarfireMessagePatch;
  /** The ID of starfire message assigned by the database */
  id: Scalars['BigInt'];
};

/** The output of our update `StarfireMessage` mutation. */
export type UpdateStarfireMessagePayload = {
  __typename?: 'UpdateStarfireMessagePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `StarfireMessage` that was updated by this mutation. */
  starfireMessage?: Maybe<StarfireMessage>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `StarfireHeader` that is related to this `StarfireMessage`. */
  header?: Maybe<StarfireHeader>;
  /** An edge for our `StarfireMessage`. May be used by Relay 1. */
  starfireMessageEdge?: Maybe<StarfireMessagesEdge>;
};


/** The output of our update `StarfireMessage` mutation. */
export type UpdateStarfireMessagePayloadStarfireMessageEdgeArgs = {
  orderBy?: Maybe<Array<StarfireMessagesOrderBy>>;
};

/** The output of our update `Starfire` mutation. */
export type UpdateStarfirePayload = {
  __typename?: 'UpdateStarfirePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Starfire` that was updated by this mutation. */
  starfire?: Maybe<Starfire>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Topic` that is related to this `Starfire`. */
  topic?: Maybe<Topic>;
  /** Reads a single `StarfireMessage` that is related to this `Starfire`. */
  msg?: Maybe<StarfireMessage>;
  /** Reads a single `Vehicle` that is related to this `Starfire`. */
  vehicle?: Maybe<Vehicle>;
  /** An edge for our `Starfire`. May be used by Relay 1. */
  starfireEdge?: Maybe<StarfiresEdge>;
};


/** The output of our update `Starfire` mutation. */
export type UpdateStarfirePayloadStarfireEdgeArgs = {
  orderBy?: Maybe<Array<StarfiresOrderBy>>;
};

/** All input for the `updateStatusMessageByNodeId` mutation. */
export type UpdateStatusMessageByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `StatusMessage` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `StatusMessage` being updated. */
  patch: StatusMessagePatch;
};

/** All input for the `updateStatusMessage` mutation. */
export type UpdateStatusMessageInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `StatusMessage` being updated. */
  patch: StatusMessagePatch;
  /** Column is auto incremented by database */
  id: Scalars['BigInt'];
};

/** The output of our update `StatusMessage` mutation. */
export type UpdateStatusMessagePayload = {
  __typename?: 'UpdateStatusMessagePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `StatusMessage` that was updated by this mutation. */
  statusMessage?: Maybe<StatusMessage>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `StatusMessageHeader` that is related to this `StatusMessage`. */
  header?: Maybe<StatusMessageHeader>;
  /** Reads a single `StatusMessageMissionStat` that is related to this `StatusMessage`. */
  missionStats?: Maybe<StatusMessageMissionStat>;
  /** An edge for our `StatusMessage`. May be used by Relay 1. */
  statusMessageEdge?: Maybe<StatusMessagesEdge>;
};


/** The output of our update `StatusMessage` mutation. */
export type UpdateStatusMessagePayloadStatusMessageEdgeArgs = {
  orderBy?: Maybe<Array<StatusMessagesOrderBy>>;
};

/** All input for the `updateStereoExtrinsicsRByNodeId` mutation. */
export type UpdateStereoExtrinsicsRByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `StereoExtrinsicsR` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `StereoExtrinsicsR` being updated. */
  patch: StereoExtrinsicsRPatch;
};

/** All input for the `updateStereoExtrinsicsR` mutation. */
export type UpdateStereoExtrinsicsRInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `StereoExtrinsicsR` being updated. */
  patch: StereoExtrinsicsRPatch;
  /** Id generated by database, auto incremented */
  id: Scalars['BigInt'];
};

/** The output of our update `StereoExtrinsicsR` mutation. */
export type UpdateStereoExtrinsicsRPayload = {
  __typename?: 'UpdateStereoExtrinsicsRPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `StereoExtrinsicsR` that was updated by this mutation. */
  stereoExtrinsicsR?: Maybe<StereoExtrinsicsR>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `StereoExtrinsicsR`. May be used by Relay 1. */
  stereoExtrinsicsREdge?: Maybe<StereoExtrinsicsRsEdge>;
};


/** The output of our update `StereoExtrinsicsR` mutation. */
export type UpdateStereoExtrinsicsRPayloadStereoExtrinsicsREdgeArgs = {
  orderBy?: Maybe<Array<StereoExtrinsicsRsOrderBy>>;
};

/** All input for the `updateTestByNodeId` mutation. */
export type UpdateTestByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Test` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Test` being updated. */
  patch: TestPatch;
};

/** All input for the `updateTest` mutation. */
export type UpdateTestInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Test` being updated. */
  patch: TestPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `Test` mutation. */
export type UpdateTestPayload = {
  __typename?: 'UpdateTestPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Test` that was updated by this mutation. */
  test?: Maybe<Test>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Test`. May be used by Relay 1. */
  testEdge?: Maybe<TestsEdge>;
};


/** The output of our update `Test` mutation. */
export type UpdateTestPayloadTestEdgeArgs = {
  orderBy?: Maybe<Array<TestsOrderBy>>;
};

/** All input for the `updateTopicByName` mutation. */
export type UpdateTopicByNameInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Topic` being updated. */
  patch: TopicPatch;
  /** The name of topic */
  name: Scalars['String'];
};

/** All input for the `updateTopicByNodeId` mutation. */
export type UpdateTopicByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Topic` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Topic` being updated. */
  patch: TopicPatch;
};

/** All input for the `updateTopic` mutation. */
export type UpdateTopicInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Topic` being updated. */
  patch: TopicPatch;
  /** The ID of topic assigned by the database */
  id: Scalars['BigInt'];
};

/** The output of our update `Topic` mutation. */
export type UpdateTopicPayload = {
  __typename?: 'UpdateTopicPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Topic` that was updated by this mutation. */
  topic?: Maybe<Topic>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `TopicType` that is related to this `Topic`. */
  type?: Maybe<TopicType>;
  /** Reads a single `TopicCategory` that is related to this `Topic`. */
  topicCategory?: Maybe<TopicCategory>;
  /** An edge for our `Topic`. May be used by Relay 1. */
  topicEdge?: Maybe<TopicsEdge>;
};


/** The output of our update `Topic` mutation. */
export type UpdateTopicPayloadTopicEdgeArgs = {
  orderBy?: Maybe<Array<TopicsOrderBy>>;
};

/** All input for the `updateTopicTypeByModule` mutation. */
export type UpdateTopicTypeByModuleInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `TopicType` being updated. */
  patch: TopicTypePatch;
  /** The module of topic type */
  module: Scalars['String'];
};

/** All input for the `updateTopicTypeByNodeId` mutation. */
export type UpdateTopicTypeByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `TopicType` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `TopicType` being updated. */
  patch: TopicTypePatch;
};

/** All input for the `updateTopicType` mutation. */
export type UpdateTopicTypeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `TopicType` being updated. */
  patch: TopicTypePatch;
  /** The ID of topic type assigned by the database */
  id: Scalars['BigInt'];
};

/** The output of our update `TopicType` mutation. */
export type UpdateTopicTypePayload = {
  __typename?: 'UpdateTopicTypePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `TopicType` that was updated by this mutation. */
  topicType?: Maybe<TopicType>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `TopicType`. May be used by Relay 1. */
  topicTypeEdge?: Maybe<TopicTypesEdge>;
};


/** The output of our update `TopicType` mutation. */
export type UpdateTopicTypePayloadTopicTypeEdgeArgs = {
  orderBy?: Maybe<Array<TopicTypesOrderBy>>;
};

/** All input for the `updateVehicleByDeviceId` mutation. */
export type UpdateVehicleByDeviceIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Vehicle` being updated. */
  patch: VehiclePatch;
  /** The ID of vehicle provided by the vehicle */
  deviceId: Scalars['String'];
};

/** All input for the `updateVehicleByNodeId` mutation. */
export type UpdateVehicleByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Vehicle` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Vehicle` being updated. */
  patch: VehiclePatch;
};

/** All input for the `updateVehicle` mutation. */
export type UpdateVehicleInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Vehicle` being updated. */
  patch: VehiclePatch;
  /** The ID of vehicle assigned by the database */
  id: Scalars['BigInt'];
};

/** The output of our update `Vehicle` mutation. */
export type UpdateVehiclePayload = {
  __typename?: 'UpdateVehiclePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Vehicle` that was updated by this mutation. */
  vehicle?: Maybe<Vehicle>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `VehicleType` that is related to this `Vehicle`. */
  type?: Maybe<VehicleType>;
  /** An edge for our `Vehicle`. May be used by Relay 1. */
  vehicleEdge?: Maybe<VehiclesEdge>;
};


/** The output of our update `Vehicle` mutation. */
export type UpdateVehiclePayloadVehicleEdgeArgs = {
  orderBy?: Maybe<Array<VehiclesOrderBy>>;
};

/** All input for the `updateVehicleStateByCode` mutation. */
export type UpdateVehicleStateByCodeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `VehicleState` being updated. */
  patch: VehicleStatePatch;
  code: Scalars['Int'];
};

/** All input for the `updateVehicleStateByName` mutation. */
export type UpdateVehicleStateByNameInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `VehicleState` being updated. */
  patch: VehicleStatePatch;
  /** The name of vehicle state type */
  name: Scalars['String'];
};

/** All input for the `updateVehicleStateByNodeId` mutation. */
export type UpdateVehicleStateByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `VehicleState` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `VehicleState` being updated. */
  patch: VehicleStatePatch;
};

/** All input for the `updateVehicleState` mutation. */
export type UpdateVehicleStateInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `VehicleState` being updated. */
  patch: VehicleStatePatch;
  /** The ID of vehicle state type assigned by the database */
  id: Scalars['BigInt'];
};

/** The output of our update `VehicleState` mutation. */
export type UpdateVehicleStatePayload = {
  __typename?: 'UpdateVehicleStatePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `VehicleState` that was updated by this mutation. */
  vehicleState?: Maybe<VehicleState>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `VehicleState`. May be used by Relay 1. */
  vehicleStateEdge?: Maybe<VehicleStatesEdge>;
};


/** The output of our update `VehicleState` mutation. */
export type UpdateVehicleStatePayloadVehicleStateEdgeArgs = {
  orderBy?: Maybe<Array<VehicleStatesOrderBy>>;
};

/** All input for the `updateVehicleStateReasonByNodeId` mutation. */
export type UpdateVehicleStateReasonByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `VehicleStateReason` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `VehicleStateReason` being updated. */
  patch: VehicleStateReasonPatch;
};

/** All input for the `updateVehicleStateReason` mutation. */
export type UpdateVehicleStateReasonInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `VehicleStateReason` being updated. */
  patch: VehicleStateReasonPatch;
  /** The ID of the state reasone assigned by the database */
  id: Scalars['BigInt'];
};

/** The output of our update `VehicleStateReason` mutation. */
export type UpdateVehicleStateReasonPayload = {
  __typename?: 'UpdateVehicleStateReasonPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `VehicleStateReason` that was updated by this mutation. */
  vehicleStateReason?: Maybe<VehicleStateReason>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `VehicleStateReason`. May be used by Relay 1. */
  vehicleStateReasonEdge?: Maybe<VehicleStateReasonsEdge>;
};


/** The output of our update `VehicleStateReason` mutation. */
export type UpdateVehicleStateReasonPayloadVehicleStateReasonEdgeArgs = {
  orderBy?: Maybe<Array<VehicleStateReasonsOrderBy>>;
};

/** All input for the `updateVehicleStatusByNodeId` mutation. */
export type UpdateVehicleStatusByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `VehicleStatus` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `VehicleStatus` being updated. */
  patch: VehicleStatusPatch;
};

/** All input for the `updateVehicleStatusDetailByNodeId` mutation. */
export type UpdateVehicleStatusDetailByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `VehicleStatusDetail` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `VehicleStatusDetail` being updated. */
  patch: VehicleStatusDetailPatch;
};

/** All input for the `updateVehicleStatusDetail` mutation. */
export type UpdateVehicleStatusDetailInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `VehicleStatusDetail` being updated. */
  patch: VehicleStatusDetailPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `VehicleStatusDetail` mutation. */
export type UpdateVehicleStatusDetailPayload = {
  __typename?: 'UpdateVehicleStatusDetailPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `VehicleStatusDetail` that was updated by this mutation. */
  vehicleStatusDetail?: Maybe<VehicleStatusDetail>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `VehicleStatus` that is related to this `VehicleStatusDetail`. */
  vehicleStatus?: Maybe<VehicleStatus>;
  /** Reads a single `VehicleStateReason` that is related to this `VehicleStatusDetail`. */
  vehicleStatusReason?: Maybe<VehicleStateReason>;
  /** An edge for our `VehicleStatusDetail`. May be used by Relay 1. */
  vehicleStatusDetailEdge?: Maybe<VehicleStatusDetailsEdge>;
};


/** The output of our update `VehicleStatusDetail` mutation. */
export type UpdateVehicleStatusDetailPayloadVehicleStatusDetailEdgeArgs = {
  orderBy?: Maybe<Array<VehicleStatusDetailsOrderBy>>;
};

/** All input for the `updateVehicleStatus` mutation. */
export type UpdateVehicleStatusInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `VehicleStatus` being updated. */
  patch: VehicleStatusPatch;
  /** The ID of vehicles status assigned by the database */
  id: Scalars['BigInt'];
};

/** The output of our update `VehicleStatus` mutation. */
export type UpdateVehicleStatusPayload = {
  __typename?: 'UpdateVehicleStatusPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `VehicleStatus` that was updated by this mutation. */
  vehicleStatus?: Maybe<VehicleStatus>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Vehicle` that is related to this `VehicleStatus`. */
  vehicle?: Maybe<Vehicle>;
  /** Reads a single `VehicleState` that is related to this `VehicleStatus`. */
  state?: Maybe<VehicleState>;
  /** Reads a single `StatusMessage` that is related to this `VehicleStatus`. */
  statusMessage?: Maybe<StatusMessage>;
  /** Reads a single `Topic` that is related to this `VehicleStatus`. */
  topic?: Maybe<Topic>;
  /** An edge for our `VehicleStatus`. May be used by Relay 1. */
  vehicleStatusEdge?: Maybe<VehicleStatusesEdge>;
};


/** The output of our update `VehicleStatus` mutation. */
export type UpdateVehicleStatusPayloadVehicleStatusEdgeArgs = {
  orderBy?: Maybe<Array<VehicleStatusesOrderBy>>;
};

/** All input for the `updateVehicleTypeByNodeId` mutation. */
export type UpdateVehicleTypeByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `VehicleType` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `VehicleType` being updated. */
  patch: VehicleTypePatch;
};

/** All input for the `updateVehicleTypeByType` mutation. */
export type UpdateVehicleTypeByTypeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `VehicleType` being updated. */
  patch: VehicleTypePatch;
  /** The name of vehicle type */
  type: Scalars['String'];
};

/** All input for the `updateVehicleType` mutation. */
export type UpdateVehicleTypeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `VehicleType` being updated. */
  patch: VehicleTypePatch;
  /** The ID of vehicle type assigned by the database */
  id: Scalars['BigInt'];
};

/** The output of our update `VehicleType` mutation. */
export type UpdateVehicleTypePayload = {
  __typename?: 'UpdateVehicleTypePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `VehicleType` that was updated by this mutation. */
  vehicleType?: Maybe<VehicleType>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `VehicleType`. May be used by Relay 1. */
  vehicleTypeEdge?: Maybe<VehicleTypesEdge>;
};


/** The output of our update `VehicleType` mutation. */
export type UpdateVehicleTypePayloadVehicleTypeEdgeArgs = {
  orderBy?: Maybe<Array<VehicleTypesOrderBy>>;
};

/** All input for the `updateVehiclesOnlineByNodeId` mutation. */
export type UpdateVehiclesOnlineByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `VehiclesOnline` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `VehiclesOnline` being updated. */
  patch: VehiclesOnlinePatch;
};

/** All input for the `updateVehiclesOnlineByVehicleId` mutation. */
export type UpdateVehiclesOnlineByVehicleIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `VehiclesOnline` being updated. */
  patch: VehiclesOnlinePatch;
  /** The vehicle id of vehicle online */
  vehicleId: Scalars['BigInt'];
};

/** All input for the `updateVehiclesOnline` mutation. */
export type UpdateVehiclesOnlineInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `VehiclesOnline` being updated. */
  patch: VehiclesOnlinePatch;
  /** The ID of vehicles online assigned by the database */
  id: Scalars['BigInt'];
};

/** The output of our update `VehiclesOnline` mutation. */
export type UpdateVehiclesOnlinePayload = {
  __typename?: 'UpdateVehiclesOnlinePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `VehiclesOnline` that was updated by this mutation. */
  vehiclesOnline?: Maybe<VehiclesOnline>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Vehicle` that is related to this `VehiclesOnline`. */
  vehicle?: Maybe<Vehicle>;
  /** An edge for our `VehiclesOnline`. May be used by Relay 1. */
  vehiclesOnlineEdge?: Maybe<VehiclesOnlinesEdge>;
};


/** The output of our update `VehiclesOnline` mutation. */
export type UpdateVehiclesOnlinePayloadVehiclesOnlineEdgeArgs = {
  orderBy?: Maybe<Array<VehiclesOnlinesOrderBy>>;
};

/** This is the vehicles table, which is related vehicles that are registered and in use */
export type Vehicle = Node & {
  __typename?: 'Vehicle';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  /** The ID of vehicle assigned by the database */
  id: Scalars['BigInt'];
  /** The name of the vehicle provided by the vehicle */
  name: Scalars['String'];
  /** The type of the vehicle */
  typeId: Scalars['BigInt'];
  /** The date of vehicle was updated to the db */
  createdAt: Scalars['Datetime'];
  updatedAt: Scalars['Datetime'];
  /** The ID of vehicle provided by the vehicle */
  deviceId: Scalars['String'];
  ip: Scalars['String'];
  /** Reads a single `VehicleType` that is related to this `Vehicle`. */
  type?: Maybe<VehicleType>;
  /** Reads a single `VehiclesOnline` that is related to this `Vehicle`. */
  vehiclesOnline?: Maybe<VehiclesOnline>;
  /**
   * Reads and enables pagination through a set of `VehiclesOnline`.
   * @deprecated Please use vehiclesOnline instead
   */
  vehiclesOnlines: VehiclesOnlinesConnection;
  /** Reads and enables pagination through a set of `CameraPair`. */
  cameraPairs: CameraPairsConnection;
  /** Reads and enables pagination through a set of `Starfire`. */
  starfires: StarfiresConnection;
  /** Reads and enables pagination through a set of `Camera`. */
  cameras: CamerasConnection;
  /** Reads and enables pagination through a set of `VehicleTopic`. */
  vehicleTopics: VehicleTopicsConnection;
  /** Reads and enables pagination through a set of `SegmentationMap`. */
  segmentationMaps: SegmentationMapsConnection;
  /** Reads and enables pagination through a set of `VehicleStatus`. */
  vehicleStatuses: VehicleStatusesConnection;
  /** Reads and enables pagination through a set of `Object`. */
  objects: ObjectsConnection;
  /** Reads and enables pagination through a set of `VehicleLog`. */
  vehicleLogs: VehicleLogsConnection;
};


/** This is the vehicles table, which is related vehicles that are registered and in use */
export type VehicleVehiclesOnlinesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<VehiclesOnlinesOrderBy>>;
  condition?: Maybe<VehiclesOnlineCondition>;
  filter?: Maybe<VehiclesOnlineFilter>;
};


/** This is the vehicles table, which is related vehicles that are registered and in use */
export type VehicleCameraPairsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CameraPairsOrderBy>>;
  condition?: Maybe<CameraPairCondition>;
  filter?: Maybe<CameraPairFilter>;
};


/** This is the vehicles table, which is related vehicles that are registered and in use */
export type VehicleStarfiresArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<StarfiresOrderBy>>;
  condition?: Maybe<StarfireCondition>;
  filter?: Maybe<StarfireFilter>;
};


/** This is the vehicles table, which is related vehicles that are registered and in use */
export type VehicleCamerasArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CamerasOrderBy>>;
  condition?: Maybe<CameraCondition>;
  filter?: Maybe<CameraFilter>;
};


/** This is the vehicles table, which is related vehicles that are registered and in use */
export type VehicleVehicleTopicsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<VehicleTopicsOrderBy>>;
  condition?: Maybe<VehicleTopicCondition>;
  filter?: Maybe<VehicleTopicFilter>;
};


/** This is the vehicles table, which is related vehicles that are registered and in use */
export type VehicleSegmentationMapsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<SegmentationMapsOrderBy>>;
  condition?: Maybe<SegmentationMapCondition>;
  filter?: Maybe<SegmentationMapFilter>;
};


/** This is the vehicles table, which is related vehicles that are registered and in use */
export type VehicleVehicleStatusesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<VehicleStatusesOrderBy>>;
  condition?: Maybe<VehicleStatusCondition>;
  filter?: Maybe<VehicleStatusFilter>;
};


/** This is the vehicles table, which is related vehicles that are registered and in use */
export type VehicleObjectsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ObjectsOrderBy>>;
  condition?: Maybe<ObjectCondition>;
  filter?: Maybe<ObjectFilter>;
};


/** This is the vehicles table, which is related vehicles that are registered and in use */
export type VehicleVehicleLogsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<VehicleLogsOrderBy>>;
  condition?: Maybe<VehicleLogCondition>;
  filter?: Maybe<VehicleLogFilter>;
};

/** A condition to be used against `Vehicle` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type VehicleCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `name` field. */
  name?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `typeId` field. */
  typeId?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `deviceId` field. */
  deviceId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `ip` field. */
  ip?: Maybe<Scalars['String']>;
};

/** A filter to be used against `Vehicle` object types. All fields are combined with a logical ‘and.’ */
export type VehicleFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `name` field. */
  name?: Maybe<StringFilter>;
  /** Filter by the object’s `typeId` field. */
  typeId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `deviceId` field. */
  deviceId?: Maybe<StringFilter>;
  /** Filter by the object’s `ip` field. */
  ip?: Maybe<StringFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<VehicleFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<VehicleFilter>>;
  /** Negates the expression. */
  not?: Maybe<VehicleFilter>;
};

/** An input for mutations affecting `Vehicle` */
export type VehicleInput = {
  /** The name of the vehicle provided by the vehicle */
  name: Scalars['String'];
  /** The type of the vehicle */
  typeId: Scalars['BigInt'];
  /** The date of vehicle was updated to the db */
  createdAt?: Maybe<Scalars['Datetime']>;
  updatedAt?: Maybe<Scalars['Datetime']>;
  /** The ID of vehicle provided by the vehicle */
  deviceId: Scalars['String'];
  ip: Scalars['String'];
};

/** Vehicle logs table contains the logs the are streamed from the vehicle */
export type VehicleLog = Node & {
  __typename?: 'VehicleLog';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  /** This is the id of the log and its autoincremented */
  id: Scalars['BigInt'];
  /** This is the log message id assocated with the  log */
  messageId: Scalars['BigInt'];
  /** This is the vehicle id the log is associated with */
  vehicleId: Scalars['BigInt'];
  /** The topic associated with the log */
  topicId: Scalars['BigInt'];
  /** The timestamp the log was created on the vehicle */
  readingat: Scalars['Datetime'];
  /** The timestamp the log inserted into database */
  createdAt: Scalars['Datetime'];
  /** Reads a single `VehicleLogMessage` that is related to this `VehicleLog`. */
  message?: Maybe<VehicleLogMessage>;
  /** Reads a single `Vehicle` that is related to this `VehicleLog`. */
  vehicle?: Maybe<Vehicle>;
  /** Reads a single `Topic` that is related to this `VehicleLog`. */
  topic?: Maybe<Topic>;
};

/**
 * A condition to be used against `VehicleLog` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type VehicleLogCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `messageId` field. */
  messageId?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `vehicleId` field. */
  vehicleId?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `topicId` field. */
  topicId?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `readingat` field. */
  readingat?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: Maybe<Scalars['Datetime']>;
};

/** A filter to be used against `VehicleLog` object types. All fields are combined with a logical ‘and.’ */
export type VehicleLogFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `messageId` field. */
  messageId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `vehicleId` field. */
  vehicleId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `topicId` field. */
  topicId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `readingat` field. */
  readingat?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: Maybe<DatetimeFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<VehicleLogFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<VehicleLogFilter>>;
  /** Negates the expression. */
  not?: Maybe<VehicleLogFilter>;
};

/** Vehicle logs messages table */
export type VehicleLogMessage = Node & {
  __typename?: 'VehicleLogMessage';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  /** This is the id of the log and its autoincremented */
  id: Scalars['BigInt'];
  /** This is the level or severity of log */
  level: Scalars['BigInt'];
  /** This is the name of log */
  name: Scalars['String'];
  /** This is the description of the log */
  msg?: Maybe<Scalars['String']>;
  /** This is the file from which the log was generated from */
  file: Scalars['String'];
  /** This is the function from which the log was generated from */
  function: Scalars['String'];
  /** This is the line from which the log was generated from */
  line: Scalars['Int'];
  /** This stamp associated wih the logging message of the log */
  stampId: Scalars['BigInt'];
  /** Reads a single `VehicleLogMessageStamp` that is related to this `VehicleLogMessage`. */
  stamp?: Maybe<VehicleLogMessageStamp>;
  /** Reads and enables pagination through a set of `VehicleLog`. */
  vehicleLogsByMessageId: VehicleLogsConnection;
};


/** Vehicle logs messages table */
export type VehicleLogMessageVehicleLogsByMessageIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<VehicleLogsOrderBy>>;
  condition?: Maybe<VehicleLogCondition>;
  filter?: Maybe<VehicleLogFilter>;
};

/**
 * A condition to be used against `VehicleLogMessage` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type VehicleLogMessageCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `level` field. */
  level?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `name` field. */
  name?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `msg` field. */
  msg?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `file` field. */
  file?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `function` field. */
  function?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `line` field. */
  line?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `stampId` field. */
  stampId?: Maybe<Scalars['BigInt']>;
};

/** A filter to be used against `VehicleLogMessage` object types. All fields are combined with a logical ‘and.’ */
export type VehicleLogMessageFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `level` field. */
  level?: Maybe<BigIntFilter>;
  /** Filter by the object’s `name` field. */
  name?: Maybe<StringFilter>;
  /** Filter by the object’s `msg` field. */
  msg?: Maybe<StringFilter>;
  /** Filter by the object’s `file` field. */
  file?: Maybe<StringFilter>;
  /** Filter by the object’s `function` field. */
  function?: Maybe<StringFilter>;
  /** Filter by the object’s `line` field. */
  line?: Maybe<IntFilter>;
  /** Filter by the object’s `stampId` field. */
  stampId?: Maybe<BigIntFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<VehicleLogMessageFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<VehicleLogMessageFilter>>;
  /** Negates the expression. */
  not?: Maybe<VehicleLogMessageFilter>;
};

/** Vehicle logs messages stamps table */
export type VehicleLogMessageStamp = Node & {
  __typename?: 'VehicleLogMessageStamp';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  /** This is the id of the log and its autoincremented */
  id: Scalars['BigInt'];
  /** This is the sec of the log stamp */
  sec: Scalars['BigInt'];
  /** This is the snanosecec of the log stamp */
  nanosec: Scalars['BigInt'];
  /** Reads and enables pagination through a set of `VehicleLogMessage`. */
  vehicleLogMessagesByStampId: VehicleLogMessagesConnection;
};


/** Vehicle logs messages stamps table */
export type VehicleLogMessageStampVehicleLogMessagesByStampIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<VehicleLogMessagesOrderBy>>;
  condition?: Maybe<VehicleLogMessageCondition>;
  filter?: Maybe<VehicleLogMessageFilter>;
};

/**
 * A condition to be used against `VehicleLogMessageStamp` object types. All fields
 * are tested for equality and combined with a logical ‘and.’
 */
export type VehicleLogMessageStampCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `sec` field. */
  sec?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `nanosec` field. */
  nanosec?: Maybe<Scalars['BigInt']>;
};

/** A filter to be used against `VehicleLogMessageStamp` object types. All fields are combined with a logical ‘and.’ */
export type VehicleLogMessageStampFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `sec` field. */
  sec?: Maybe<BigIntFilter>;
  /** Filter by the object’s `nanosec` field. */
  nanosec?: Maybe<BigIntFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<VehicleLogMessageStampFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<VehicleLogMessageStampFilter>>;
  /** Negates the expression. */
  not?: Maybe<VehicleLogMessageStampFilter>;
};

/** A connection to a list of `VehicleLogMessageStamp` values. */
export type VehicleLogMessageStampsConnection = {
  __typename?: 'VehicleLogMessageStampsConnection';
  /** A list of `VehicleLogMessageStamp` objects. */
  nodes: Array<Maybe<VehicleLogMessageStamp>>;
  /** A list of edges which contains the `VehicleLogMessageStamp` and cursor to aid in pagination. */
  edges: Array<VehicleLogMessageStampsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `VehicleLogMessageStamp` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `VehicleLogMessageStamp` edge in the connection. */
export type VehicleLogMessageStampsEdge = {
  __typename?: 'VehicleLogMessageStampsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `VehicleLogMessageStamp` at the end of the edge. */
  node?: Maybe<VehicleLogMessageStamp>;
};

/** Methods to use when ordering `VehicleLogMessageStamp`. */
export enum VehicleLogMessageStampsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  SecAsc = 'SEC_ASC',
  SecDesc = 'SEC_DESC',
  NanosecAsc = 'NANOSEC_ASC',
  NanosecDesc = 'NANOSEC_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/** A connection to a list of `VehicleLogMessage` values. */
export type VehicleLogMessagesConnection = {
  __typename?: 'VehicleLogMessagesConnection';
  /** A list of `VehicleLogMessage` objects. */
  nodes: Array<Maybe<VehicleLogMessage>>;
  /** A list of edges which contains the `VehicleLogMessage` and cursor to aid in pagination. */
  edges: Array<VehicleLogMessagesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `VehicleLogMessage` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `VehicleLogMessage` edge in the connection. */
export type VehicleLogMessagesEdge = {
  __typename?: 'VehicleLogMessagesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `VehicleLogMessage` at the end of the edge. */
  node?: Maybe<VehicleLogMessage>;
};

/** Methods to use when ordering `VehicleLogMessage`. */
export enum VehicleLogMessagesOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  LevelAsc = 'LEVEL_ASC',
  LevelDesc = 'LEVEL_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  MsgAsc = 'MSG_ASC',
  MsgDesc = 'MSG_DESC',
  FileAsc = 'FILE_ASC',
  FileDesc = 'FILE_DESC',
  FunctionAsc = 'FUNCTION_ASC',
  FunctionDesc = 'FUNCTION_DESC',
  LineAsc = 'LINE_ASC',
  LineDesc = 'LINE_DESC',
  StampIdAsc = 'STAMP_ID_ASC',
  StampIdDesc = 'STAMP_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

export type VehicleLogNodeType = {
  __typename?: 'VehicleLogNodeType';
  nodeType?: Maybe<Scalars['String']>;
  vehicleId?: Maybe<Scalars['BigInt']>;
  vehicleName?: Maybe<Scalars['String']>;
};

/**
 * A condition to be used against `VehicleLogNodeType` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type VehicleLogNodeTypeCondition = {
  /** Checks for equality with the object’s `nodeType` field. */
  nodeType?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `vehicleId` field. */
  vehicleId?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `vehicleName` field. */
  vehicleName?: Maybe<Scalars['String']>;
};

/** A filter to be used against `VehicleLogNodeType` object types. All fields are combined with a logical ‘and.’ */
export type VehicleLogNodeTypeFilter = {
  /** Filter by the object’s `nodeType` field. */
  nodeType?: Maybe<StringFilter>;
  /** Filter by the object’s `vehicleId` field. */
  vehicleId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `vehicleName` field. */
  vehicleName?: Maybe<StringFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<VehicleLogNodeTypeFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<VehicleLogNodeTypeFilter>>;
  /** Negates the expression. */
  not?: Maybe<VehicleLogNodeTypeFilter>;
};

/** A connection to a list of `VehicleLogNodeType` values. */
export type VehicleLogNodeTypesConnection = {
  __typename?: 'VehicleLogNodeTypesConnection';
  /** A list of `VehicleLogNodeType` objects. */
  nodes: Array<Maybe<VehicleLogNodeType>>;
  /** A list of edges which contains the `VehicleLogNodeType` and cursor to aid in pagination. */
  edges: Array<VehicleLogNodeTypesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `VehicleLogNodeType` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `VehicleLogNodeType` edge in the connection. */
export type VehicleLogNodeTypesEdge = {
  __typename?: 'VehicleLogNodeTypesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `VehicleLogNodeType` at the end of the edge. */
  node?: Maybe<VehicleLogNodeType>;
};

/** Methods to use when ordering `VehicleLogNodeType`. */
export enum VehicleLogNodeTypesOrderBy {
  Natural = 'NATURAL',
  NodeTypeAsc = 'NODE_TYPE_ASC',
  NodeTypeDesc = 'NODE_TYPE_DESC',
  VehicleIdAsc = 'VEHICLE_ID_ASC',
  VehicleIdDesc = 'VEHICLE_ID_DESC',
  VehicleNameAsc = 'VEHICLE_NAME_ASC',
  VehicleNameDesc = 'VEHICLE_NAME_DESC'
}

/** A connection to a list of `VehicleLog` values. */
export type VehicleLogsConnection = {
  __typename?: 'VehicleLogsConnection';
  /** A list of `VehicleLog` objects. */
  nodes: Array<Maybe<VehicleLog>>;
  /** A list of edges which contains the `VehicleLog` and cursor to aid in pagination. */
  edges: Array<VehicleLogsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `VehicleLog` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `VehicleLog` edge in the connection. */
export type VehicleLogsEdge = {
  __typename?: 'VehicleLogsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `VehicleLog` at the end of the edge. */
  node?: Maybe<VehicleLog>;
};

/** Methods to use when ordering `VehicleLog`. */
export enum VehicleLogsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  MessageIdAsc = 'MESSAGE_ID_ASC',
  MessageIdDesc = 'MESSAGE_ID_DESC',
  VehicleIdAsc = 'VEHICLE_ID_ASC',
  VehicleIdDesc = 'VEHICLE_ID_DESC',
  TopicIdAsc = 'TOPIC_ID_ASC',
  TopicIdDesc = 'TOPIC_ID_DESC',
  ReadingatAsc = 'READINGAT_ASC',
  ReadingatDesc = 'READINGAT_DESC',
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/** Represents an update to a `Vehicle`. Fields that are set will be updated. */
export type VehiclePatch = {
  /** The name of the vehicle provided by the vehicle */
  name?: Maybe<Scalars['String']>;
  /** The type of the vehicle */
  typeId?: Maybe<Scalars['BigInt']>;
  /** The date of vehicle was updated to the db */
  createdAt?: Maybe<Scalars['Datetime']>;
  updatedAt?: Maybe<Scalars['Datetime']>;
  /** The ID of vehicle provided by the vehicle */
  deviceId?: Maybe<Scalars['String']>;
  ip?: Maybe<Scalars['String']>;
};

export type VehicleState = Node & {
  __typename?: 'VehicleState';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  /** The ID of vehicle state type assigned by the database */
  id: Scalars['BigInt'];
  /** The name of vehicle state type */
  name: Scalars['String'];
  code: Scalars['Int'];
  /** The description of vehicle state type */
  description?: Maybe<Scalars['String']>;
  /** The date of vehicle state type was added to database */
  createdAt: Scalars['Datetime'];
  /** The date of vehicle state type was updated in database */
  updatedAt: Scalars['Datetime'];
  /** Reads and enables pagination through a set of `VehicleStatus`. */
  vehicleStatusesByStateId: VehicleStatusesConnection;
};


export type VehicleStateVehicleStatusesByStateIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<VehicleStatusesOrderBy>>;
  condition?: Maybe<VehicleStatusCondition>;
  filter?: Maybe<VehicleStatusFilter>;
};

/**
 * A condition to be used against `VehicleState` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type VehicleStateCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `name` field. */
  name?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `code` field. */
  code?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `description` field. */
  description?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: Maybe<Scalars['Datetime']>;
};

/** A filter to be used against `VehicleState` object types. All fields are combined with a logical ‘and.’ */
export type VehicleStateFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `name` field. */
  name?: Maybe<StringFilter>;
  /** Filter by the object’s `code` field. */
  code?: Maybe<IntFilter>;
  /** Filter by the object’s `description` field. */
  description?: Maybe<StringFilter>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: Maybe<DatetimeFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<VehicleStateFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<VehicleStateFilter>>;
  /** Negates the expression. */
  not?: Maybe<VehicleStateFilter>;
};

/** An input for mutations affecting `VehicleState` */
export type VehicleStateInput = {
  /** The name of vehicle state type */
  name: Scalars['String'];
  code: Scalars['Int'];
  /** The description of vehicle state type */
  description?: Maybe<Scalars['String']>;
  /** The date of vehicle state type was updated in database */
  updatedAt?: Maybe<Scalars['Datetime']>;
};

/** Represents an update to a `VehicleState`. Fields that are set will be updated. */
export type VehicleStatePatch = {
  /** The name of vehicle state type */
  name?: Maybe<Scalars['String']>;
  code?: Maybe<Scalars['Int']>;
  /** The description of vehicle state type */
  description?: Maybe<Scalars['String']>;
  /** The date of vehicle state type was updated in database */
  updatedAt?: Maybe<Scalars['Datetime']>;
};

/** This is table is used to store the enum state reasons */
export type VehicleStateReason = Node & {
  __typename?: 'VehicleStateReason';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  /** The ID of the state reasone assigned by the database */
  id: Scalars['BigInt'];
  /** The enum value for the reason */
  code: Scalars['BigInt'];
  /** The name for the reason */
  name: Scalars['String'];
  /** Reads and enables pagination through a set of `VehicleStatusDetail`. */
  vehicleStatusDetailsByVehicleStatusReasonId: VehicleStatusDetailsConnection;
};


/** This is table is used to store the enum state reasons */
export type VehicleStateReasonVehicleStatusDetailsByVehicleStatusReasonIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<VehicleStatusDetailsOrderBy>>;
  condition?: Maybe<VehicleStatusDetailCondition>;
  filter?: Maybe<VehicleStatusDetailFilter>;
};

/**
 * A condition to be used against `VehicleStateReason` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type VehicleStateReasonCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `code` field. */
  code?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `name` field. */
  name?: Maybe<Scalars['String']>;
};

/** A filter to be used against `VehicleStateReason` object types. All fields are combined with a logical ‘and.’ */
export type VehicleStateReasonFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `code` field. */
  code?: Maybe<BigIntFilter>;
  /** Filter by the object’s `name` field. */
  name?: Maybe<StringFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<VehicleStateReasonFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<VehicleStateReasonFilter>>;
  /** Negates the expression. */
  not?: Maybe<VehicleStateReasonFilter>;
};

/** An input for mutations affecting `VehicleStateReason` */
export type VehicleStateReasonInput = {
  /** The name for the reason */
  name: Scalars['String'];
};

/** Represents an update to a `VehicleStateReason`. Fields that are set will be updated. */
export type VehicleStateReasonPatch = {
  /** The name for the reason */
  name?: Maybe<Scalars['String']>;
};

/** A connection to a list of `VehicleStateReason` values. */
export type VehicleStateReasonsConnection = {
  __typename?: 'VehicleStateReasonsConnection';
  /** A list of `VehicleStateReason` objects. */
  nodes: Array<Maybe<VehicleStateReason>>;
  /** A list of edges which contains the `VehicleStateReason` and cursor to aid in pagination. */
  edges: Array<VehicleStateReasonsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `VehicleStateReason` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `VehicleStateReason` edge in the connection. */
export type VehicleStateReasonsEdge = {
  __typename?: 'VehicleStateReasonsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `VehicleStateReason` at the end of the edge. */
  node?: Maybe<VehicleStateReason>;
};

/** Methods to use when ordering `VehicleStateReason`. */
export enum VehicleStateReasonsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  CodeAsc = 'CODE_ASC',
  CodeDesc = 'CODE_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/** A connection to a list of `VehicleState` values. */
export type VehicleStatesConnection = {
  __typename?: 'VehicleStatesConnection';
  /** A list of `VehicleState` objects. */
  nodes: Array<Maybe<VehicleState>>;
  /** A list of edges which contains the `VehicleState` and cursor to aid in pagination. */
  edges: Array<VehicleStatesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `VehicleState` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `VehicleState` edge in the connection. */
export type VehicleStatesEdge = {
  __typename?: 'VehicleStatesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `VehicleState` at the end of the edge. */
  node?: Maybe<VehicleState>;
};

/** Methods to use when ordering `VehicleState`. */
export enum VehicleStatesOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  CodeAsc = 'CODE_ASC',
  CodeDesc = 'CODE_DESC',
  DescriptionAsc = 'DESCRIPTION_ASC',
  DescriptionDesc = 'DESCRIPTION_DESC',
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

export type VehicleStatus = Node & {
  __typename?: 'VehicleStatus';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  /** The ID of vehicles status assigned by the database */
  id: Scalars['BigInt'];
  /** The vehicle id of vehicle status */
  vehicleId: Scalars['BigInt'];
  /** The current state of the vehicle */
  stateId: Scalars['BigInt'];
  /** The timestamp vehicle status was added to the db */
  createdAt: Scalars['Datetime'];
  /** The timestamp vehicle status was updated on the db */
  updatedAt: Scalars['Datetime'];
  statusMessageId: Scalars['BigInt'];
  topicId: Scalars['BigInt'];
  readingat: Scalars['Datetime'];
  /** Reads a single `Vehicle` that is related to this `VehicleStatus`. */
  vehicle?: Maybe<Vehicle>;
  /** Reads a single `VehicleState` that is related to this `VehicleStatus`. */
  state?: Maybe<VehicleState>;
  /** Reads a single `StatusMessage` that is related to this `VehicleStatus`. */
  statusMessage?: Maybe<StatusMessage>;
  /** Reads a single `Topic` that is related to this `VehicleStatus`. */
  topic?: Maybe<Topic>;
  /** Reads and enables pagination through a set of `Alert`. */
  alerts: AlertsConnection;
  /** Reads and enables pagination through a set of `VehicleStatusDetail`. */
  vehicleStatusDetails: VehicleStatusDetailsConnection;
};


export type VehicleStatusAlertsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<AlertsOrderBy>>;
  condition?: Maybe<AlertCondition>;
  filter?: Maybe<AlertFilter>;
};


export type VehicleStatusVehicleStatusDetailsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<VehicleStatusDetailsOrderBy>>;
  condition?: Maybe<VehicleStatusDetailCondition>;
  filter?: Maybe<VehicleStatusDetailFilter>;
};

/**
 * A condition to be used against `VehicleStatus` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type VehicleStatusCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `vehicleId` field. */
  vehicleId?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `stateId` field. */
  stateId?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `statusMessageId` field. */
  statusMessageId?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `topicId` field. */
  topicId?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `readingat` field. */
  readingat?: Maybe<Scalars['Datetime']>;
};

/** This table provides the reason as to why the status of the vehicle changed */
export type VehicleStatusDetail = Node & {
  __typename?: 'VehicleStatusDetail';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  /** This is the id of the status this reason is related to */
  vehicleStatusId: Scalars['BigInt'];
  /** This is the id of the state reason that is associated with this status reason */
  vehicleStatusReasonId: Scalars['BigInt'];
  /** This used to indicate if reason is active */
  isActive: Scalars['Boolean'];
  /** This used to indicate if issue is recoverable */
  isRecoverable: Scalars['Boolean'];
  /** This used to give a descriptiom of the issue */
  description?: Maybe<Scalars['String']>;
  /** Reads a single `VehicleStatus` that is related to this `VehicleStatusDetail`. */
  vehicleStatus?: Maybe<VehicleStatus>;
  /** Reads a single `VehicleStateReason` that is related to this `VehicleStatusDetail`. */
  vehicleStatusReason?: Maybe<VehicleStateReason>;
};

/**
 * A condition to be used against `VehicleStatusDetail` object types. All fields
 * are tested for equality and combined with a logical ‘and.’
 */
export type VehicleStatusDetailCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `vehicleStatusId` field. */
  vehicleStatusId?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `vehicleStatusReasonId` field. */
  vehicleStatusReasonId?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `isActive` field. */
  isActive?: Maybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `isRecoverable` field. */
  isRecoverable?: Maybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `description` field. */
  description?: Maybe<Scalars['String']>;
};

/** A filter to be used against `VehicleStatusDetail` object types. All fields are combined with a logical ‘and.’ */
export type VehicleStatusDetailFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `vehicleStatusId` field. */
  vehicleStatusId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `vehicleStatusReasonId` field. */
  vehicleStatusReasonId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `isActive` field. */
  isActive?: Maybe<BooleanFilter>;
  /** Filter by the object’s `isRecoverable` field. */
  isRecoverable?: Maybe<BooleanFilter>;
  /** Filter by the object’s `description` field. */
  description?: Maybe<StringFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<VehicleStatusDetailFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<VehicleStatusDetailFilter>>;
  /** Negates the expression. */
  not?: Maybe<VehicleStatusDetailFilter>;
};

/** An input for mutations affecting `VehicleStatusDetail` */
export type VehicleStatusDetailInput = {
  id?: Maybe<Scalars['BigInt']>;
};

/** Represents an update to a `VehicleStatusDetail`. Fields that are set will be updated. */
export type VehicleStatusDetailPatch = {
  id?: Maybe<Scalars['BigInt']>;
};

/** A connection to a list of `VehicleStatusDetail` values. */
export type VehicleStatusDetailsConnection = {
  __typename?: 'VehicleStatusDetailsConnection';
  /** A list of `VehicleStatusDetail` objects. */
  nodes: Array<Maybe<VehicleStatusDetail>>;
  /** A list of edges which contains the `VehicleStatusDetail` and cursor to aid in pagination. */
  edges: Array<VehicleStatusDetailsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `VehicleStatusDetail` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `VehicleStatusDetail` edge in the connection. */
export type VehicleStatusDetailsEdge = {
  __typename?: 'VehicleStatusDetailsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `VehicleStatusDetail` at the end of the edge. */
  node?: Maybe<VehicleStatusDetail>;
};

/** Methods to use when ordering `VehicleStatusDetail`. */
export enum VehicleStatusDetailsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  VehicleStatusIdAsc = 'VEHICLE_STATUS_ID_ASC',
  VehicleStatusIdDesc = 'VEHICLE_STATUS_ID_DESC',
  VehicleStatusReasonIdAsc = 'VEHICLE_STATUS_REASON_ID_ASC',
  VehicleStatusReasonIdDesc = 'VEHICLE_STATUS_REASON_ID_DESC',
  IsActiveAsc = 'IS_ACTIVE_ASC',
  IsActiveDesc = 'IS_ACTIVE_DESC',
  IsRecoverableAsc = 'IS_RECOVERABLE_ASC',
  IsRecoverableDesc = 'IS_RECOVERABLE_DESC',
  DescriptionAsc = 'DESCRIPTION_ASC',
  DescriptionDesc = 'DESCRIPTION_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/** A filter to be used against `VehicleStatus` object types. All fields are combined with a logical ‘and.’ */
export type VehicleStatusFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `vehicleId` field. */
  vehicleId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `stateId` field. */
  stateId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `statusMessageId` field. */
  statusMessageId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `topicId` field. */
  topicId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `readingat` field. */
  readingat?: Maybe<DatetimeFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<VehicleStatusFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<VehicleStatusFilter>>;
  /** Negates the expression. */
  not?: Maybe<VehicleStatusFilter>;
};

/** An input for mutations affecting `VehicleStatus` */
export type VehicleStatusInput = {
  /** The vehicle id of vehicle status */
  vehicleId: Scalars['BigInt'];
  /** The current state of the vehicle */
  stateId: Scalars['BigInt'];
  /** The timestamp vehicle status was updated on the db */
  updatedAt?: Maybe<Scalars['Datetime']>;
  statusMessageId: Scalars['BigInt'];
  topicId: Scalars['BigInt'];
  readingat: Scalars['Datetime'];
};

/** Represents an update to a `VehicleStatus`. Fields that are set will be updated. */
export type VehicleStatusPatch = {
  /** The vehicle id of vehicle status */
  vehicleId?: Maybe<Scalars['BigInt']>;
  /** The current state of the vehicle */
  stateId?: Maybe<Scalars['BigInt']>;
  /** The timestamp vehicle status was updated on the db */
  updatedAt?: Maybe<Scalars['Datetime']>;
  statusMessageId?: Maybe<Scalars['BigInt']>;
  topicId?: Maybe<Scalars['BigInt']>;
  readingat?: Maybe<Scalars['Datetime']>;
};

/** A connection to a list of `VehicleStatus` values. */
export type VehicleStatusesConnection = {
  __typename?: 'VehicleStatusesConnection';
  /** A list of `VehicleStatus` objects. */
  nodes: Array<Maybe<VehicleStatus>>;
  /** A list of edges which contains the `VehicleStatus` and cursor to aid in pagination. */
  edges: Array<VehicleStatusesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `VehicleStatus` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `VehicleStatus` edge in the connection. */
export type VehicleStatusesEdge = {
  __typename?: 'VehicleStatusesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `VehicleStatus` at the end of the edge. */
  node?: Maybe<VehicleStatus>;
};

/** Methods to use when ordering `VehicleStatus`. */
export enum VehicleStatusesOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  VehicleIdAsc = 'VEHICLE_ID_ASC',
  VehicleIdDesc = 'VEHICLE_ID_DESC',
  StateIdAsc = 'STATE_ID_ASC',
  StateIdDesc = 'STATE_ID_DESC',
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC',
  StatusMessageIdAsc = 'STATUS_MESSAGE_ID_ASC',
  StatusMessageIdDesc = 'STATUS_MESSAGE_ID_DESC',
  TopicIdAsc = 'TOPIC_ID_ASC',
  TopicIdDesc = 'TOPIC_ID_DESC',
  ReadingatAsc = 'READINGAT_ASC',
  ReadingatDesc = 'READINGAT_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/** This is the vehicles topics table, which is related to vehicles topics if produces */
export type VehicleTopic = Node & {
  __typename?: 'VehicleTopic';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  /** The ID of vehicles topics assigned by the database */
  id: Scalars['BigInt'];
  /** The vehicle id of vehicle that sent topic */
  vehicleId: Scalars['BigInt'];
  /** The topic id  of topic vehicle sent */
  topicId: Scalars['BigInt'];
  /** The timestamp of topic vehicle sent */
  createdAt: Scalars['Datetime'];
  /** Reads a single `Vehicle` that is related to this `VehicleTopic`. */
  vehicle?: Maybe<Vehicle>;
  /** Reads a single `Topic` that is related to this `VehicleTopic`. */
  topic?: Maybe<Topic>;
};

/**
 * A condition to be used against `VehicleTopic` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type VehicleTopicCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `vehicleId` field. */
  vehicleId?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `topicId` field. */
  topicId?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: Maybe<Scalars['Datetime']>;
};

/** A filter to be used against `VehicleTopic` object types. All fields are combined with a logical ‘and.’ */
export type VehicleTopicFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `vehicleId` field. */
  vehicleId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `topicId` field. */
  topicId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: Maybe<DatetimeFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<VehicleTopicFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<VehicleTopicFilter>>;
  /** Negates the expression. */
  not?: Maybe<VehicleTopicFilter>;
};

/** A connection to a list of `VehicleTopic` values. */
export type VehicleTopicsConnection = {
  __typename?: 'VehicleTopicsConnection';
  /** A list of `VehicleTopic` objects. */
  nodes: Array<Maybe<VehicleTopic>>;
  /** A list of edges which contains the `VehicleTopic` and cursor to aid in pagination. */
  edges: Array<VehicleTopicsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `VehicleTopic` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `VehicleTopic` edge in the connection. */
export type VehicleTopicsEdge = {
  __typename?: 'VehicleTopicsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `VehicleTopic` at the end of the edge. */
  node?: Maybe<VehicleTopic>;
};

/** Methods to use when ordering `VehicleTopic`. */
export enum VehicleTopicsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  VehicleIdAsc = 'VEHICLE_ID_ASC',
  VehicleIdDesc = 'VEHICLE_ID_DESC',
  TopicIdAsc = 'TOPIC_ID_ASC',
  TopicIdDesc = 'TOPIC_ID_DESC',
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/** This is the vehicle type table, which is related to the type of vehicles that is sending data */
export type VehicleType = Node & {
  __typename?: 'VehicleType';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  /** The ID of vehicle type assigned by the database */
  id: Scalars['BigInt'];
  /** The name of vehicle type */
  type: Scalars['String'];
  /** The description of vehicle type */
  description?: Maybe<Scalars['String']>;
  /** Reads and enables pagination through a set of `Vehicle`. */
  vehiclesByTypeId: VehiclesConnection;
};


/** This is the vehicle type table, which is related to the type of vehicles that is sending data */
export type VehicleTypeVehiclesByTypeIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<VehiclesOrderBy>>;
  condition?: Maybe<VehicleCondition>;
  filter?: Maybe<VehicleFilter>;
};

/**
 * A condition to be used against `VehicleType` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type VehicleTypeCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `type` field. */
  type?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `description` field. */
  description?: Maybe<Scalars['String']>;
};

/** A filter to be used against `VehicleType` object types. All fields are combined with a logical ‘and.’ */
export type VehicleTypeFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `type` field. */
  type?: Maybe<StringFilter>;
  /** Filter by the object’s `description` field. */
  description?: Maybe<StringFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<VehicleTypeFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<VehicleTypeFilter>>;
  /** Negates the expression. */
  not?: Maybe<VehicleTypeFilter>;
};

/** An input for mutations affecting `VehicleType` */
export type VehicleTypeInput = {
  /** The name of vehicle type */
  type: Scalars['String'];
  /** The description of vehicle type */
  description?: Maybe<Scalars['String']>;
};

/** Represents an update to a `VehicleType`. Fields that are set will be updated. */
export type VehicleTypePatch = {
  /** The name of vehicle type */
  type?: Maybe<Scalars['String']>;
  /** The description of vehicle type */
  description?: Maybe<Scalars['String']>;
};

/** A connection to a list of `VehicleType` values. */
export type VehicleTypesConnection = {
  __typename?: 'VehicleTypesConnection';
  /** A list of `VehicleType` objects. */
  nodes: Array<Maybe<VehicleType>>;
  /** A list of edges which contains the `VehicleType` and cursor to aid in pagination. */
  edges: Array<VehicleTypesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `VehicleType` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `VehicleType` edge in the connection. */
export type VehicleTypesEdge = {
  __typename?: 'VehicleTypesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `VehicleType` at the end of the edge. */
  node?: Maybe<VehicleType>;
};

/** Methods to use when ordering `VehicleType`. */
export enum VehicleTypesOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  TypeAsc = 'TYPE_ASC',
  TypeDesc = 'TYPE_DESC',
  DescriptionAsc = 'DESCRIPTION_ASC',
  DescriptionDesc = 'DESCRIPTION_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/** A connection to a list of `Vehicle` values. */
export type VehiclesConnection = {
  __typename?: 'VehiclesConnection';
  /** A list of `Vehicle` objects. */
  nodes: Array<Maybe<Vehicle>>;
  /** A list of edges which contains the `Vehicle` and cursor to aid in pagination. */
  edges: Array<VehiclesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Vehicle` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `Vehicle` edge in the connection. */
export type VehiclesEdge = {
  __typename?: 'VehiclesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Vehicle` at the end of the edge. */
  node?: Maybe<Vehicle>;
};

export type VehiclesOffline = {
  __typename?: 'VehiclesOffline';
  id?: Maybe<Scalars['BigInt']>;
  name?: Maybe<Scalars['String']>;
  typeId?: Maybe<Scalars['BigInt']>;
  createdAt?: Maybe<Scalars['Datetime']>;
  updatedAt?: Maybe<Scalars['Datetime']>;
  deviceId?: Maybe<Scalars['String']>;
  ip?: Maybe<Scalars['String']>;
};

/**
 * A condition to be used against `VehiclesOffline` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type VehiclesOfflineCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `name` field. */
  name?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `typeId` field. */
  typeId?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `deviceId` field. */
  deviceId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `ip` field. */
  ip?: Maybe<Scalars['String']>;
};

/** A filter to be used against `VehiclesOffline` object types. All fields are combined with a logical ‘and.’ */
export type VehiclesOfflineFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `name` field. */
  name?: Maybe<StringFilter>;
  /** Filter by the object’s `typeId` field. */
  typeId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `deviceId` field. */
  deviceId?: Maybe<StringFilter>;
  /** Filter by the object’s `ip` field. */
  ip?: Maybe<StringFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<VehiclesOfflineFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<VehiclesOfflineFilter>>;
  /** Negates the expression. */
  not?: Maybe<VehiclesOfflineFilter>;
};

/** An input for mutations affecting `VehiclesOffline` */
export type VehiclesOfflineInput = {
  id?: Maybe<Scalars['BigInt']>;
  name?: Maybe<Scalars['String']>;
  typeId?: Maybe<Scalars['BigInt']>;
  createdAt?: Maybe<Scalars['Datetime']>;
  updatedAt?: Maybe<Scalars['Datetime']>;
  deviceId?: Maybe<Scalars['String']>;
  ip?: Maybe<Scalars['String']>;
};

/** A connection to a list of `VehiclesOffline` values. */
export type VehiclesOfflinesConnection = {
  __typename?: 'VehiclesOfflinesConnection';
  /** A list of `VehiclesOffline` objects. */
  nodes: Array<Maybe<VehiclesOffline>>;
  /** A list of edges which contains the `VehiclesOffline` and cursor to aid in pagination. */
  edges: Array<VehiclesOfflinesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `VehiclesOffline` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `VehiclesOffline` edge in the connection. */
export type VehiclesOfflinesEdge = {
  __typename?: 'VehiclesOfflinesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `VehiclesOffline` at the end of the edge. */
  node?: Maybe<VehiclesOffline>;
};

/** Methods to use when ordering `VehiclesOffline`. */
export enum VehiclesOfflinesOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  TypeIdAsc = 'TYPE_ID_ASC',
  TypeIdDesc = 'TYPE_ID_DESC',
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC',
  DeviceIdAsc = 'DEVICE_ID_ASC',
  DeviceIdDesc = 'DEVICE_ID_DESC',
  IpAsc = 'IP_ASC',
  IpDesc = 'IP_DESC'
}

/** This is the vehicles online table, which is related to vehicles that are currently online */
export type VehiclesOnline = Node & {
  __typename?: 'VehiclesOnline';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  /** The ID of vehicles online assigned by the database */
  id: Scalars['BigInt'];
  /** The vehicle id of vehicle online */
  vehicleId: Scalars['BigInt'];
  /** The timestamp vehicle came on line */
  createdAt: Scalars['Datetime'];
  /** The timestamp vehicle was last on line */
  updatedAt: Scalars['Datetime'];
  /** Reads a single `Vehicle` that is related to this `VehiclesOnline`. */
  vehicle?: Maybe<Vehicle>;
};

/**
 * A condition to be used against `VehiclesOnline` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type VehiclesOnlineCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `vehicleId` field. */
  vehicleId?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: Maybe<Scalars['Datetime']>;
};

/** A filter to be used against `VehiclesOnline` object types. All fields are combined with a logical ‘and.’ */
export type VehiclesOnlineFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `vehicleId` field. */
  vehicleId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: Maybe<DatetimeFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<VehiclesOnlineFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<VehiclesOnlineFilter>>;
  /** Negates the expression. */
  not?: Maybe<VehiclesOnlineFilter>;
};

/** An input for mutations affecting `VehiclesOnline` */
export type VehiclesOnlineInput = {
  /** The vehicle id of vehicle online */
  vehicleId: Scalars['BigInt'];
  /** The timestamp vehicle was last on line */
  updatedAt?: Maybe<Scalars['Datetime']>;
};

/** Represents an update to a `VehiclesOnline`. Fields that are set will be updated. */
export type VehiclesOnlinePatch = {
  /** The vehicle id of vehicle online */
  vehicleId?: Maybe<Scalars['BigInt']>;
  /** The timestamp vehicle was last on line */
  updatedAt?: Maybe<Scalars['Datetime']>;
};

/** A connection to a list of `VehiclesOnline` values. */
export type VehiclesOnlinesConnection = {
  __typename?: 'VehiclesOnlinesConnection';
  /** A list of `VehiclesOnline` objects. */
  nodes: Array<Maybe<VehiclesOnline>>;
  /** A list of edges which contains the `VehiclesOnline` and cursor to aid in pagination. */
  edges: Array<VehiclesOnlinesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `VehiclesOnline` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `VehiclesOnline` edge in the connection. */
export type VehiclesOnlinesEdge = {
  __typename?: 'VehiclesOnlinesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `VehiclesOnline` at the end of the edge. */
  node?: Maybe<VehiclesOnline>;
};

/** Methods to use when ordering `VehiclesOnline`. */
export enum VehiclesOnlinesOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  VehicleIdAsc = 'VEHICLE_ID_ASC',
  VehicleIdDesc = 'VEHICLE_ID_DESC',
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/** Methods to use when ordering `Vehicle`. */
export enum VehiclesOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  TypeIdAsc = 'TYPE_ID_ASC',
  TypeIdDesc = 'TYPE_ID_DESC',
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC',
  DeviceIdAsc = 'DEVICE_ID_ASC',
  DeviceIdDesc = 'DEVICE_ID_DESC',
  IpAsc = 'IP_ASC',
  IpDesc = 'IP_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}
